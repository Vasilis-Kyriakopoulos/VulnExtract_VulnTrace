text,code
"The aarch64_ext_ldst_reglist function in opcodes/aarch64-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+  if (value >= ARRAY_SIZE (data))
+    return 0;"
Fix seg-faults in objdump when disassembling a corrupt versados binary.,-         int offsetlen = flag & 0x7;
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
x86: Check for valid PLT section size Update x86 get_synthetic_symtab to check for valid PLT section size before examining PLT section contents.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-         int offsetlen = flag & 0x7;
Check for the index exceeding OP_BUF_LEN.,+#define GETBYTE() (ld->rl78->n_bytes < (OP_BUF_LEN - 1) ? ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr): 0)
Handle archives with corrupt extended name tables.,"+      if (amt > (bfd_size_type) bfd_get_size (abfd))
+       goto byebye;"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-         char hdr[8];
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347, rloc + reloc_size will cause integer overflow in line 13348.", 	  rloc = start + rp->r_offset;
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  size = bfd_get_section_size (sect);
Fix handling of corrupt STABS enum type strings.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
"The disassemble_bytes function in objdump.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of rae insns printing for this file during ""objdump -D"" execution.","-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
Fix address violation when disassembling a corrupt binary.,"-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
Fix a seg-fault triggered by reading a mal-formed archive.,"       if (amt + 1 == 0)
        goto byebye;"
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
Check for corrupt NAME:VALUE pairs.,"+      while (*p != ':' && *p != 0)
        ++p;"
Fix null pointer dereference when parsing a corrupt ELF binary.,          idx = (Elf_Internal_Group *) shdr->contents;
(alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix handling of corrupt STABS enum type strings.,"+      while (*p != ':' && *p != 0)
        ++p;"
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,-                 char datum = * ((char *) eopt + offset + len);
Check for corrupt NAME:VALUE pairs.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-             ent = print_mips_got_entry (data, pltgot, ent, data_end);"
Add sentinel.,"static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
Fix seg-fault reading malformed archive.,+         bfd_ardata (abfd)->extended_names = NULL;
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
But it does not forbid directory traversal in the paths.,+         bfd_ardata (abfd)->extended_names_size = 0;
Pass num_syms to target_specific_reloc_handling.," static bfd_boolean
 target_specific_reloc_handling (Elf_Internal_Rela * reloc,
                                unsigned char *     start,
                                unsigned char *     end,
+                               Elf_Internal_Sym *  symtab,
+                               unsigned long       num_syms)"
Fix address violation when disassembling a corrupt binary.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
I have checked in a small patch that adds a check for a NULL buffer pointer and then repsonds appropriately.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".","-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-         if (byte_get (data + ent - pltgot, addr_size)
-             >> (addr_size * 8 - 1) != 0)"
Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.,   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
Fix address violations when atempting to parse fuzzed binaries.,-  if (bfd_get_section_size (sect) < 0x24)
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
Exit early if passed an empty string.,"+  if (*orig == 0)
+    return (bfd_vma) 0;"
PR 21933 * elf.c (elf_read_notes): Check for a note size of -1.,-  if (size <= 0)
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+           if (start + reloc->r_offset + 4 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);
+           else
+             byte_put (start + reloc->r_offset, value, 4);"
Clip index to prevent overflow.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
Fix seg-fault reading malformed archive.,"+      if (amt > (bfd_size_type) bfd_get_size (abfd))
+       goto byebye;"
Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[300];
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
readelf: Fix overlarge memory allocation when reading a binary with an excessive number of program headers.,"+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
Fix seg-fault reading malformed archive.,+         bfd_ardata (abfd)->extended_names_size = 0;
Detect over large section offsets in the DT_SYMTAB entry.,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Pass num_syms to target_specific_reloc_handling.,"+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.",-      if (plt == NULL)
Update check for invalid word offsets in ARM unwind information.,"+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
(alpha_vms_object_p): Check for a truncated record.,+       (alpha_vms_object_p): Check for a truncated record.
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+         if (res == res_base)
+           return FALSE;"
Clip index to prevent overflow.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
Check valid bnd register.,"+      if (reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
The elf_read_notesfunction in bfd/elf.c in GNU Binutils 2.29 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Fix stack buffer overflows when parsing corrupt ihex files.,-      char hdr[8];
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
PR binutils/21591 * versados.c (versados_mkobject): Zero the allocated tdata structure.,"+      tdata_type *tdata = bfd_zalloc (abfd, amt);"
(alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
PR binutils/21157 * stabs.c (parse_stab_enum_type): Check for corrupt NAME:VALUE pairs.,"+      while (*p != ':' && *p != 0)
        ++p;"
Fix a seg-fault triggered by reading a mal-formed archive.,       bfd_ardata (abfd)->extended_names_size = amt;
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347, rloc + reloc_size will cause integer overflow in line 13348.",-	  if ((rloc + reloc_size) > end || (rloc < start))
Fix out of bounds memory access when trying to allocate space for a note of size -1.,-  if (size <= 0)
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"Date: Wed, 29 Aug 2012 20:11:50 +0200 From: Florian Weimer <fw@...eb.enyo.de> To: oss-security@...ts.openwall.com Subject: CVE-2012-3509: objalloc_alloc integer overflows in libiberty Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.","+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
"GNU Binutils 2017-04-03 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash), related to the process_mips_specific function in readelf.c, via a crafted ELF file that triggers a large memory-allocation attempt.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
Pass num_syms to target_specific_reloc_handling.,"+  if (reloc)
+    {
+      reloc_type = get_reloc_type (reloc->r_info);
+      sym_index = get_reloc_symindex (reloc->r_info);
+    }"
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt_entry_size
+                           + lazy_plt->plt_entry_size)))"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-                 char datum = * ((char *) eopt + offset + len);
"Error in ""OP_G"": global-buffer-overflow",       oappend (names64[modrm.reg + add]);
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+      if (modrm.reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
Check for the source pointer exceeding the end pointer before the first byte is read.,"+  if (src >= endp)
+    return FALSE;"
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,-                 char datum = * ((char *) eopt + offset + len);
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
Check for symbol table overflow before accessing symbol value.,"+           if (sym_index >= num_syms)
+             error (_(""MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             saved_sym = symtab + sym_index;
            return TRUE;"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix handling of corrupt STABS enum type strings.,"       name = savestring (*pp, p - *pp);"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
ld * testsuite/ld-nds32/diff.d: Adjust expected output.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, non_lazy_plt->plt_entry,"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
But it does not forbid directory traversal in the paths.,+         bfd_ardata (abfd)->extended_names = NULL;
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+         if (res == res_base)
+           return FALSE;"
Check for buffer overrun when printing out rae insns.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
"Fix read-after-free error in readelf when processing multiple, relocated sections in an MSP430 binary.","-         if (target_specific_reloc_handling (rp, start, end, symtab))"
(rl78_decode_opcode): Use OP_BUF_LEN as the length of the op_buf array.,+  unsigned char op_buf[OP_BUF_LEN] = {0};
Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[512];
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plt == NULL || plt->size == 0)
        continue;"
"readelf.c in GNU Binutils 2017-04-12 has a ""shift exponent too large for type unsigned long"" issue, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted ELF file.",-       unsigned long  val = 0;
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+         if (srcp + esdids + offsetlen >= endp)
+           return;"
"fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.",-  if (saved_file == NULL || file != saved_file)
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (memory consumption) via a crafted ELF file with many program headers, related to the get_program_headers function in readelf.c.","+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
"readelf: fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  if (size < 0x24)
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-                 char datum = * ((char *) eopt + offset + len);
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-         char hdr[8];
"Unavailable data is handled gracefully in MIPS GOT processing done by `print_mips_got_entry', so all that is needed in special GOT[1] handling is to verify whether data can be retrieved for the purpose of the GNU marker check done with `byte_get'.","+      if (data
+         && data + ent - pltgot + addr_size <= data_end
+         && (byte_get (data + ent - pltgot, addr_size)
+             >> (addr_size * 8 - 1)) != 0)"
Use to check for corrupt pair relocs.,"+         if (res == res_base)
+           return FALSE;"
PR other/54411: integer overflow in objalloc_alloc 2012-09-18 Florian Weimer <fweimer@redhat.com> PR other/54411 * objalloc.h (objalloc_alloc): Do not use fast path on wraparound.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-      char hdr[8];
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,"   inote.namesz = H_GET_32 (abfd, enote->namesz);"
PR binutils/21157 * stabs.c (parse_stab_enum_type): Check for corrupt NAME:VALUE pairs.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
Prevent address violation problem when disassembling corrupt aarch64 binary.,"+  if (value >= ARRAY_SIZE (data))
+    return 0;"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"Multiple integer overflows in the (1) _objalloc_alloc function in objalloc.c and (2) objalloc_alloc macro in include/objalloc.h in GNU libiberty, as used by binutils 2.22, allow remote attackers to cause a denial of service (crash) via vectors related to the ""addition of CHUNK_HEADER_SIZE to the length,"" which triggers a heap-based buffer overflow.",   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
PR binutils/20892 * aoutx.h (find_nearest_line): Handle the case where the function name is empty.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"opcodes/rl78-decode.opc in GNU Binutils 2.28 has an unbounded GETBYTE macro, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-#define GETBYTE() (ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr))
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",       oappend (names_bnd[modrm.reg]);
"Error in ""OP_G"": global-buffer-overflow",       oappend (names_bnd[modrm.reg]);
"The ieee_object_p function in bfd/ieee.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, might allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  unsigned char buffer[300];
Check for the index exceeding OP_BUF_LEN.,+#define GETBYTE() (ld->rl78->n_bytes < (OP_BUF_LEN - 1) ? ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr): 0)
"GNU assembler in GNU Binutils 2.28 is vulnerable to a global buffer overflow (of size 1) while attempting to unget an EOF character from the input stream, potentially leading to a program crash.","+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
"The _bfd_vms_slurp_etir function in bfd/vms-alpha.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",+      if (cmd_length < 4 || (ptr + cmd_length > maxptr + 4))
Clip index to prevent overflow.,"+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
"The ieee_archive_p function in bfd/ieee.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, might allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  unsigned char buffer[512];
"Remove the extra error reporting code then, introduced with commit 75ec1fdbb797 (""Fix runtime seg-fault in readelf when parsing a corrupt MIPS binary."")",-         if (data + ent - pltgot > data_end - addr_size)
PR gas/20898 * app.c (do_scrub_chars): Do not attempt to unget EOF.,"+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,+  size = bfd_get_section_size (sect);
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,-                 char datum = * ((char *) eopt + offset + len);
readelf: Update check for invalid word offsets in ARM unwind information.,"+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","-                 && (memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"Error in ""sh_elf_set_mach_from_flags"": global-buffer-overflow",-  if (flags >= sizeof(sh_ef_bfd_table))
PR binutils/21379 * readelf.c (process_dynamic_section): Detect over large section offsets in the DT_SYMTAB entry.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
PR 21957 * elf.c (setup_group): Check for an empty or very small group section.,"+         if (idx == NULL || shdr->sh_size < 4)
+           {
+             _bfd_error_handler (_(""%B: group section '%A' has no contents""),
+                                 abfd, shdr->bfd_section);
+             elf_tdata (abfd)->group_sect_ptr[i] = NULL;
+             bfd_set_error (bfd_error_bad_value);
+             return FALSE;
+           }"
Fix a seg-fault disassembling a corrupt binary.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-             error (_(""Invalid got entry - %#lx - overflows GOT table\n""),
-                    (long) ent);"
Pass num_syms to target_specific_reloc_handling.,"+                   if (start + reloc->r_offset + reloc_size >= end)
+                     error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                            start + reloc->r_offset + reloc_size, end);"
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,+  size = bfd_get_section_size (sect);
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MN10300 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
Fix shift overflow when parsing an overlarge note value.,"+       if (bytes > sizeof (val))
+         {
+           error (_(""corrupt name field: namesz of %lu is too large for a numeric value\n""),
+                  pnote->namesz);
+           return FALSE;
+         }"
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  size = bfd_get_section_size (sect);
"The setup_group function in elf.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a group section that is too small.","+         if (idx == NULL || shdr->sh_size < 4)
+           {
+             _bfd_error_handler (_(""%B: group section '%A' has no contents""),
+                                 abfd, shdr->bfd_section);
+             elf_tdata (abfd)->group_sect_ptr[i] = NULL;
+             bfd_set_error (bfd_error_bad_value);
+             return FALSE;
+           }"
(alpha_vms_object_p): Check for a truncated record.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
"Error in ""rl78_decode_opcode"": stack-buffer-overflow",-#define GETBYTE() (ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr))
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
"The getsym function in tekhex.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (stack-based buffer over-read and application crash) via a malformed tekhex binary.",   *srcp = src + i;
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt_entry_size
+                           + lazy_plt->plt_entry_size)))"
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  size = bfd_get_section_size (sect);
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
"Multiple integer overflows in the (1) _objalloc_alloc function in objalloc.c and (2) objalloc_alloc macro in include/objalloc.h in GNU libiberty, as used by binutils 2.22, allow remote attackers to cause a denial of service (crash) via vectors related to the ""addition of CHUNK_HEADER_SIZE to the length,"" which triggers a heap-based buffer overflow.","+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
bfd * mach-o.c (bfd_mach_o_canonicalize_relocs): Pass the base address of the relocs to the canonicalize_one_reloc routine.,"+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
* readelf.c (process_mips_specific): Fix incorrect escape sequence handling.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
Check for an invalid offset in the otr structure.,"+         if (srcp + esdids + offsetlen >= endp)
+           return;"
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,+                 if (j + bpc <= stop_offset * opb)
PR binutils/21582 * ieee.c (ieee_object_p): Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[300];
Subject: CVE-2012-3509: objalloc_alloc integer overflows in libiberty.,   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-         char hdr[8];
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix null pointer dereference when parsing a corrupt ELF binary.,"          if (shdr == NULL)
            continue;"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym1 = saved_sym2 = 0;
+           return TRUE;
+         }"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents,
                      non_lazy_ibt_plt->plt_entry,"
Check for an out of range value.,"+  if (value >= ARRAY_SIZE (data))
+    return 0;"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
readelf: Fix overlarge memory allocation when reading a binary with an excessive number of program headers.,"+  if (elf_header.e_phnum
+      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
+      >= current_file_size)
+    {
+      error (_(""Too many program headers - %#x - the file is not that big\n""),
+            elf_header.e_phnum);
+      return FALSE;
+    }"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+         if (res == res_base)
+           return FALSE;"
Add num_syms parameter.," static bfd_boolean
 target_specific_reloc_handling (Elf_Internal_Rela * reloc,
                                unsigned char *     start,
                                unsigned char *     end,
+                               Elf_Internal_Sym *  symtab,
+                               unsigned long       num_syms)"
Check for buffer overflow before writing relocated values.,"+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  if (section_headers != NULL
+      && (saved_file == NULL || file != saved_file))"
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
"When ""uvalue"" is a specific value,  ""block_start + uvalue"" will cause integer overflow.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.",-             goto got_print_fail;
binutils/ * readelf.c (process_mips_specific): Remove error reporting from GOT[1] processing.,-         if (data + ent - pltgot > data_end - addr_size)
Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
Check for buffer overrun when printing out rae insns.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
"Error in ""print_insn_score16"": global-buffer-overflow","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
Pass num_syms to target_specific_reloc_handling.,"+         if (target_specific_reloc_handling (rp, start, end, symtab, num_syms))
            continue;"
Fix a seg-fault triggered by reading a mal-formed archive.,"       bfd_ardata (abfd)->extended_names = (char *) bfd_zalloc (abfd, amt + 1);"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
"readelf.c in GNU Binutils 2017-04-12 has a ""cannot be represented in type long"" issue, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted ELF file.","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
PR 24829 * readelf.c (apply_relocations): Catch potential integer overflow whilst checking reloc location against section size.,+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",+         unsigned int offsetlen = flag & 0x7;
Pass num_syms to target_specific_reloc_handling.,"+           if (sym_index >= num_syms)
+             error (_(""RL78_SYM reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             {
+               saved_sym2 = symtab[sym_index].st_value;
+               saved_sym2 += reloc->r_addend;
+             }
            return TRUE;"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,+  if (size < 0x24)
(alpha_vms_object_p): Check for a truncated record.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,+       (alpha_vms_object_p): Check for a truncated record.
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,+  if (size < 0x24)
"The disassemble_bytes function in objdump.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of rae insns printing for this file during ""objdump -D"" execution.","-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
Fix incorrect escape sequence on platform with signed char.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+           if (start + reloc->r_offset + 2 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-                 char datum = * ((char *) eopt + offset + len);
The elf_read_notesfunction in bfd/elf.c in GNU Binutils 2.29 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file.,-  if (size <= 0)
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
Fix seg-fault when trying to disassemble a corrupt score binary.,"static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
PR binutils/21578 * elf32-sh.c (sh_elf_set_mach_from_flags): Fix check for invalid flag value.,"+  if (flags >= ARRAY_SIZE (sh_ef_bfd_table))
     return FALSE;"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+  if (section_headers != NULL
+      && (saved_file == NULL || file != saved_file))"
PR binutils/21345 * readelf.c (process_mips_specific): Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
"When ""uvalue"" is a specific value, ""block_start + uvalue"" will cause integer overflow.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names = NULL;
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+         if (res == res_base)
+           return FALSE;"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to the byte_get_little_endian function in elfcomm.c, the get_unwind_section_word function in readelf.c, and ARM unwind information that contains invalid word offsets.","+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
"Maybe it can fix like this:
   if ((rloc + reloc_size) > end || (rloc < start) || (rloc + reloc_size) < start)



Triggering the bug requires accurate input. I'm not sure the poc file can trigger a crash in your environment.",+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
Check for buffer overflow before writing relocated values.,"+           if (start + reloc->r_offset + 2 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);"
"The get_build_id function in opncls.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted file in which a certain size field is larger than a corresponding data field, as demonstrated by mishandling within the objdump program.",       oappend (names64[modrm.reg + add]);
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,-         char hdr[8];
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-      char hdr[8];
"The aarch64_ext_ldst_reglist function in opcodes/aarch64-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",   info->reglist.num_regs = data[value].num_regs;
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, non_lazy_plt->plt_entry,"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
"Which in turn will reset uvalue to a sane number, and so allow the rest of the code to continue.",+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  if (size < 0x24)
Fix out of bounds memory access when trying to allocate space for a note of size -1.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Pass num_syms to target_specific_reloc_handling.,"+               if (sym_index >= num_syms)
+                 error (_(""MN10300 reloc contains invalid symbol index %lu\n""),
+                        sym_index);"
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
PR gas/20898 * app.c (do_scrub_chars): Do not attempt to unget EOF.,"+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plt == NULL || plt->size == 0)
        continue;"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  if (size < 0x24)
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
PR 21933 * elf.c (elf_read_notes): Check for a note size of -1.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Check for symbol table overflow before accessing symbol value.,"+           if (sym_index >= num_syms)
+             error (_(""MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             saved_sym = symtab + sym_index;
            return TRUE;"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
Fix buffer overrun when parsing a corrupt tekhex binary.,   *srcp = src + i;
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
2012-09-18 Florian Weimer <fweimer@redhat.com> PR other/54411 * objalloc.h (objalloc_alloc): Do not use fast path on wraparound.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
Check for buffer overflow before writing relocated values.,"+         if (target_specific_reloc_handling (rp, start, end, symtab))
            continue;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.",-      if (plts[j].type == plt_unknown)
(rl78_decode_opcode): Use OP_BUF_LEN as the length of the op_buf array.,+  unsigned char op_buf[OP_BUF_LEN] = {0};
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,"   inote.type = H_GET_32 (abfd, enote->type);"
PR binutils/21378 * readelf.c (print_gnu_build_attribute_name): Check for an overlarge name field.,"+       if (bytes > sizeof (val))
+         {
+           error (_(""corrupt name field: namesz of %lu is too large for a numeric value\n""),
+                  pnote->namesz);
+           return FALSE;
+         }"
"The score_opcodes function in opcodes/score7-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",       oappend (names64[modrm.reg + add]);
"Error in ""bfd_get_string"": stack-buffer-overflow.",-  unsigned char buffer[512];
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,-      char hdr[8];
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Check valid bnd register.,"+      if (modrm.reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  size = bfd_get_section_size (sect);
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347,  rloc + reloc_size will cause integer overflow in line 13348. ",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
PR binutils/21591 * versados.c (versados_mkobject): Zero the allocated tdata structure.,+         unsigned int offsetlen = flag & 0x7;
Use to check for corrupt pair relocs.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-      char hdr[8];
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,-         char hdr[8];
PR binutils/17533 * archive.c (_bfd_slurp_extended_name_table): Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names_size = 0;
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
Check for buffer overflow before writing relocated values.,"+           if (start + reloc->r_offset + 4 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);
+           else
+             byte_put (start + reloc->r_offset, value, 4);"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
"fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
asan: arm-darwin: buffer overflow.,"+         if (res == res_base)
+           return FALSE;"
"The sh_elf_set_mach_from_flags function in bfd/elf32-sh.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  if (flags >= sizeof(sh_ef_bfd_table))
Avoid a possible compiler bug by using a static buffer instead of a stack local buffer.,+  static unsigned char buffer[300];
Detect over large section offsets in the DT_SYMTAB entry. ,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Clip index to prevent overflow.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
Pass num_syms to target_specific_reloc_handling.,"+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
Pass end to target_specific_reloc_handling.,"+         if (target_specific_reloc_handling (rp, start, end, symtab))
            continue;"
"The versados_mkobject function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not initialize a certain data structure, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","-      tdata_type *tdata = bfd_alloc (abfd, amt);"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  if (elf_header.e_phnum
+      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
+      >= current_file_size)
+    {
+      error (_(""Too many program headers - %#x - the file is not that big\n""),
+            elf_header.e_phnum);
+      return FALSE;
+    }"
"When integer overflow, these two statements have different judgment results.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/17533 * archive.c (_bfd_slurp_extended_name_table): Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names = NULL;
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
Fix check for source pointer walking off the end of the input buffer.,"+  for (i = 0; i < len && (src + i) < endp; i++)
     dstp[i] = src[i];"
Pass num_syms to target_specific_reloc_handling.,"+               if (sym_index >= num_syms)
+                 error (_(""MSP430 reloc contains invalid symbol index %lu\n""),
+                        sym_index);"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, lazy_plt->plt0_entry,"
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,   enote = (Elf_External_Note *) contents;
Pass num_syms to target_specific_reloc_handling.,+  unsigned long sym_index = 0;
avformat/rtmppkt: Check for packet size mismatches.,+                prev_pkt[channel_id].size);
"The decode_uncompressed function in libavcodec/faxcompr.c in FFmpeg before 2.8.2 does not validate uncompressed runs, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted CCITT FAX data.","+        if (*runs >= runend) {
+            av_log(avctx, AV_LOG_ERROR, ""uncompressed run overrun\n"");
+            return AVERROR_INVALIDDATA;
+        }"
avcodec/mjpegdec: Fix small picture upscale.,+                        line[w - 1] = line[(w - 1) / 3];
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckedNumeric<size_t>(bytes_per_entry);"
Fixes: use after free(),"         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
-                                        size2, mime);
+                                        size2, NULL);"
"Heap-based buffer overflow in libavformat/rtmppkt.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check for RTMP packet size mismatches.",     if (!prev_pkt[channel_id].read) {
The filter_slice function in libavfilter/vf_transpose.c in FFmpeg through 3.4.1 allows remote attackers to cause a denial of service (out-of-array access) via a crafted MP4 file.,-    for (plane = 0; out->data[plane]; plane++) {
avcodec/utvideodec: Add several out of array read related checks.,"+                if (c->control_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.,         size_t raw_bpp = s->bpp - byte_depth;
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",+            s->avctx->level   = level;
Fixes denial of service due to use of sscanf in inner loop for tag scaning. ,"-           if (sscanf(in+tag_close+1, ""%127[^<>]>%n"", buffer, &len) >= 1 && len > 0) {"
Fixes: out of array read. ,"                 if (slice_end < 0 || slice_end < slice_start ||
-                    bytestream2_get_bytes_left(&gb) < slice_end) {
+                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL)"
Fixes: out of array read. ,-                return AVERROR_INVALIDDATA;
swscale/utils: Clear pix buffers.,"+    FF_ALLOCZ_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg 3.0 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.,"         av_log(ctx->avctx, AV_LOG_ERROR,"
"The ff_mpv_common_init function in libavcodec/mpegvideo.c in FFmpeg before 2.7.2 does not properly maintain the encoding context, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted MPEG data.","-    memset(&s->last_picture, 0, sizeof(s->last_picture));"
avformat/movenc: Do not pass AVCodecParameters in avpriv_request_sample.,"-                avpriv_request_sample(track->par, ""Multiple independent substreams"");"
"As a result, the variable ""item_num"" turns negative, bypassing the check for a large value.",+    if (item_num > 65536 || item_num < 0) {
avformat/rtpdec_h264: Fix heap-buffer-overflow.,"+        if (*value == 0 || value[strlen(value) - 1] == ',') {
            av_log(s, AV_LOG_WARNING, ""Missing PPS in sprop-parameter-sets, ignoring\n"");
            return 0;
        }"
FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.,         for (y = 0; y < s->height; ++y) {
avcodec/utvideodec: Add several out of array read related checks.,"+                    if ((bits + 1) * 8 > get_bits_left(&pbit))
+                        return AVERROR_INVALIDDATA;"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
Multiple integer underflows in the ff_mjpeg_decode_frame function in libavcodec/mjpegdec.c in FFmpeg before 2.7.2 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.,-                        ((uint16_t*)line)[w - 1] =
rawenc: Only accept the appropriate stream type for raw muxers.,"+    if (   s->oformat->audio_codec != AV_CODEC_ID_NONE
+        && s->streams[0]->codecpar->codec_type != AVMEDIA_TYPE_AUDIO) {
+        av_log(s, AV_LOG_ERROR, ""%s files have exactly one audio stream\n"",
+               s->oformat->name);
+        return AVERROR(EINVAL);
+    }"
Its easier to just avoid it and use only studio_profile.,"     if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
        !s->cur_pic.f                                                  ||
-       s->cur_pic.field_picture                                       ||
-       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO
+       s->cur_pic.field_picture
     )"
Fixes out of array access,"-    tile->coord[1][1] = FFMIN((tiley + 1) * s->tile_height + s->tile_offset_y, s->height);"
Fixes: out of array access.,ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));
Check ymin vs. h.,"+        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {"
Do not trust the counts.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme SGPD count exceeds implementation limit."");"
Fixes: out of array read.,"             get_bits(gb, 8);"
This ensures that no stale pointers leak through on any path. ,"-    memset(&s->next_picture, 0, sizeof(s->next_picture));"
"When a crafted RL2 file, which claims a large ""frame_count"" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
The export function in libavfilter/vf_signature.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a long filename.,"-        strcpy(filename, sic->filename);"
avcodec/dnxhddec: Move mb height check out of non hr branch.,"+        if (ctx->mb_height > 68 ||
+            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
             av_log(ctx->avctx, AV_LOG_ERROR,
                    ""mb height too big: %d\n"", ctx->mb_height);
             return AVERROR_INVALIDDATA;
         }"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
Fixes: out of array read. ,"-                if (!mms->streams)
-                    return AVERROR(ENOMEM);"
There is a heap-buffer-overflow at libavfilter/vf_colorconstancy.c:282 in slice_get_derivative.,-    if (tags == 16 && i == 8) {
Fixes: out of array read. ,-            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
avcodec/mpeg4videodec: Check read profile before setting it.,"+    *profile = get_bits(gb, 4);"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
avcodec/jpeg2000dwt: Check ndeclevels before calling dwt_decode*().,"+    if (s->ndeclevels == 0)
+        return 0;"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.","+        av_log(NULL, AV_LOG_ERROR, ""RTMP packet size mismatch %d != %d\n"","
Fixes: Infinite loop.,             pes_header_data_length = avio_r8(pb);
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
avcodec/webp: Always set pix_fmt.,+    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
"The jpeg2000_read_main_headers function in libavcodec/jpeg2000dec.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 does not enforce uniqueness of the SIZ marker in a JPEG 2000 image, which allows remote attackers to cause a denial of service (out-of-bounds heap-memory access) or possibly have unspecified other impact via a crafted image with two or more of these markers.","+            if (s->ncomponents) {
+                av_log(s->avctx, AV_LOG_ERROR, ""Duplicate SIZ\n"");
+                return AVERROR_INVALIDDATA;
+            }"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init(). ,"-    memset(&s->current_picture, 0, sizeof(s->current_picture));"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.",-  int sample_count = reader->box_size() - reader->pos();
"The update_dimensions function in libavcodec/vp8.c in FFmpeg through 2.8.1, as used in Google Chrome before 46.0.2490.71 and other products, relies on a coefficient-partition count during multi-threaded operation, which allows remote attackers to cause a denial of service (race condition and memory corruption) or possibly have unspecified other impact via a crafted WebM file.",s->macroblocks_base       = av_mallocz((s->mb_width + s->mb_height * 2 + 1) *sizeof(*s->macroblocks));
Subject: [CVE-2017-15672]: ffmpeg: read out of bounds of buffer when it parsing an craft mp4 file.,-             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
"The allocate_buffers function in libavcodec/alac.c in FFmpeg before 2.7.2 does not initialize certain context data, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted Apple Lossless Audio Codec (ALAC) data.","+    for (ch = 0; ch < 2; ch++) {
+        alac->predict_error_buffer[ch]  = NULL;
+        alac->output_samples_buffer[ch] = NULL;
+        alac->extra_bits_buffer[ch]     = NULL;
+    }"
"Validates the set channel layout as well as verifies that the received layout to the function matches the reference layout, so that it matches the implemented re-ordering logic.",+    if (layout == AV_CH_LAYOUT_22POINT2) {
MSE: Fix moar mp4 parsing security bugs.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
avformat/mov: Check sample size.,"+                    if (sample_size > 0x3FFFFFFF) {
+                        av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\n"", sample_size);
+                        return;
+                    }"
avcodec/dnxhd_parser: Do not return invalid value from dnxhd_find_frame_end() on error.,"+                if (remaining <= 0) {
+                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
+                    if (remaining <= 0)
+                        continue;
                 }"
avcodec/msrledec: avcodec/msrledec: restructure msrle_decode_pal4() based on the line number instead of the pixel pointer.,+                    pic->data[0][line * pic->linesize[0] + pixel_ptr] = stream_byte & 0x0F;
avcodec/msrledec: avcodec/msrledec: restructure msrle_decode_pal4() based on the line number instead of the pixel pointer.,+                    pic->data[0][line * pic->linesize[0] + pixel_ptr] = stream_byte >> 4;
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->deblock_coefs    = NULL;
avformat/mvdec: Fix DoS due to lack of eof check.,"+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(count <= entries.max_size());
Fixes: out of array read. ,"-            if (mms->stream_num < MMS_MAX_STREAMS &&
-                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {"
Clear pointers in ff_rv34_decode_init_thread_copy().,+        r->cbp_chroma       = NULL;
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init().,"-    memset(&s->current_picture, 0, sizeof(s->current_picture));"
The read_gab2_sub function in libavformat/avidec.c in FFmpeg before 3.1.4 allows remote attackers to cause a denial of service (NULL pointer used) via a crafted AVI file.,"+            if (ast->sub_ctx->nb_streams != 1)
+                goto error;"
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.","-        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");"
avformat/cinedec: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
"The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.",+    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {
"Validates the set channel layout as well as verifies that the received layout to the function matches the reference layout, so that it matches the implemented re-ordering logic.","+    if (layout == PREFIX_FOR_22POINT2 && tags == 16 && i == 8) {
+        const uint8_t (*reference_layout_map)[3] = aac_channel_layout_map[12];
+        for (int j = 0; j < tags; j++) {
+            if (layout_map[j][0] != reference_layout_map[j][0] ||
+                layout_map[j][2] != reference_layout_map[j][2])
+                goto end_of_layout_definition;
+        }"
Fixes: out of array access.,"-    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+            int profile, level;"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->cbp_chroma       = NULL;
"In FFmpeg 2.4 and 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop).","+        if (reload_count > c->max_reload)
+            return AVERROR_EOF;"
Fixes out of array read.,-    if (s->cdef[0] < 0) {
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.","-  RCHECK(reader->Read4(&count) &&
-         reader->HasBytes(count * (reader->version() == 1 ? 8 : 4)));"
avcodec/jpeg2000dec: Clip all tile coordinates.,"+    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
Fixes: out of array read. ,"             v = get_bits(gb, 8);"
check segment duration value of EXTINF.,"+                if (duration < 0.001 * AV_TIME_BASE) {
+                    av_log(c->ctx, AV_LOG_WARNING, ""Cannot get correct #EXTINF value of segment %s,""
+                                    "" set to default value to 1ms.\n"", seg->url);
+                    duration = 0.001 * AV_TIME_BASE;
+                }"
The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.6 allows remote attackers to cause a denial of service (out-of-bounds array read access) via crafted JPEG 2000 data.,"-        for (x = 0; x < s->ncomponents; x++)
-            s->cdef[x] = x + 1;"
avcodec/hevc_ps: Check chroma_format_idc.,"+    if (sps->chroma_format_idc > 3U) {
+        av_log(avctx, AV_LOG_ERROR, ""chroma_format_idc %d is invalid\n"", sps->chroma_format_idc);
+        return AVERROR_INVALIDDATA;
+    }"
avcodec/dnxhddec: Move mb height check out of non hr branch.,         ctx->data_offset = 0x280;
swscale/utils: Clear pix buffers.,"-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
Fixes: division by 0.,+        if (track->timescale > UINT16_MAX || !track->par->channels) {
Do not trust the counts.,+  const size_t bytes_per_edit = reader->version() == 1 ? 20 : 12;
The svg_probe function in libavformat/img2dec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (Infinite Loop) via a crafted XML file.,-        b += ff_subtitles_next_line(b);
"These 2 fields are not always the same, it is simpler to always use the same field for detecting studio profile.","+            if (c->mpeg4_studio_profile)
                 c->idct_put              = ff_simple_idct_put_int32_10bit;"
"In line libavcodec/h264dec.c:500 in libav(v13_dev0), ffmpeg(n3.4), chromium(56 prior Feb 13, 2017), the return value of init_get_bits is ignored and get_ue_golomb(&gb) is called on an uninitialized get_bits context, which causes a NULL deref exception. ","-            ret = init_get_bits8(&gb, nal->data + 1, (nal->size - 1));"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    *profile = get_bits(gb, 4);"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.",+    s->buf = av_malloc(s->buf_size);
cbs_jpeg_split_fragment in libavcodec/cbs_jpeg.c in FFmpeg 4.1 and 4.2.2 has a heap-based buffer overflow during JPEG_MARKER_SOS handling because of a missing length check.,"+            if (length > end - start)
+                return AVERROR_INVALIDDATA;"
avcodec/utvideodec: Add several out of array read related checks.,"+                if (c->packed_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
"FFmpeg through 4.2 has a ""Conditional jump or move depends on uninitialised value"" issue in h2645_parse because alloc_rbsp_buffer in libavcodec/h2645_parse.c mishandles rbsp_buffer.","     if (rbsp->rbsp_buffer_alloc_size >= size &&
-        (!rbsp->rbsp_buffer_ref || av_buffer_is_writable(rbsp->rbsp_buffer_ref)))
+        (!rbsp->rbsp_buffer_ref || av_buffer_is_writable(rbsp->rbsp_buffer_ref))) {
+        av_assert0(rbsp->rbsp_buffer);
+        memset(rbsp->rbsp_buffer + min_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
         return;
+    }"
Fixes out of array access,"-    tile->coord[0][0] = FFMAX(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x);"
Fix overheads in gauss array.,"                         dst[INDX2D(r, c, width)] += GAUSS(src, r,                        c + GINDX(filtersize, g),
-                                                          in_linesize, height, width, gauss[GINDX(filtersize, g)]);
+                                                          in_linesize, height, width, gauss[g]);"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init(). ,"-    memset(&s->next_picture, 0, sizeof(s->next_picture));"
avcodec/dnxhddec: Move mb height check out of non hr branch.,"+        if (ctx->mb_height > 68 ||
+            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
             av_log(ctx->avctx, AV_LOG_ERROR,
                    ""mb height too big: %d\n"", ctx->mb_height);
             return AVERROR_INVALIDDATA;
         }"
"Incorrect check results in an integer underflow, which results in MOVAtoms of arbitrary sizes.",-            if (a.size == 1) {
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b2 + b6) >> 7)];
"FFmpeg 2.8 and 4.2.3 has a use-after-free via a crafted EXTINF duration in an m3u8 file because parse_playlist in libavformat/hls.c frees a pointer, and later that pointer is accessed in av_probe_input_format3 in libavformat/format.c.",-                seg->key_type = key_type;
avcodec/hevcdec: Avoid only partly skiping duplicate first slices.,"+            if (s->ref) {
+                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
+                goto fail;
+            }"
avcodec/jpeg2000dec: Clip all tile coordinates.,"+    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
avcodec/mpeg4videodec: Check idx in mpeg4_decode_studio_block().,"+            if (idx > 63)
+                return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Check idx in mpeg4_decode_studio_block().,"+            if (idx > 63)
+                return AVERROR_INVALIDDATA;"
Fixes: out of array read. ,         c->slices      = avctx->extradata[9] + 1;
But such solutions are fragile and tricky to implement portably and would not stop every possible attack nor would they work with all valid hls files.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
MSE: Fix moar mp4 parsing security bugs.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme SGPD count exceeds implementation limit."");"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(sample_count <= sample_depends_on_.max_size());
"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",-        return 1;
Write version 2 of audio atom if channels is not known. ,+        if (track->timescale > UINT16_MAX || !track->par->channels) {
"The ff_mpv_common_init function in libavcodec/mpegvideo.c in FFmpeg before 2.7.2 does not properly maintain the encoding context, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted MPEG data.","-    memset(&s->new_picture, 0, sizeof(s->new_picture));"
avcodec/ivi: Check image dimensions.,"+    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||
         cfg->luma_bands < 1 || cfg->chroma_bands < 1)"
This reduces the attack surface of local file-system information leaking.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+            } else if (s->studio_profile) {
+                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
+                return AVERROR_PATCHWELCOME;
             }"
"In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    err = init_get_bits8(&gb, buf, size);"
There's a division by zero at libavcodec/aaccoder.c:554 and 556.,"+            s->lambda = av_clipf(s->lambda * ratio, FLT_MIN, 65536.f);"
avformat/nsvdec: Fix DoS due to lack of eof check in nsvs_file_offset loop.,"+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
"The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.",-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
+                (level > 0 && level < 9)) {"
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 7*stride] = av_clip_uint8( dst[i + 7*stride] + ((b0 - b4) >> 7));
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->mb_type          = NULL;
Fixes: out of array access. ,             dst[y * linesize + x] = clr;
Clear pointers in ff_rv34_decode_init_thread_copy().,+        r->deblock_coefs    = NULL;
Fixes out of array access. ,"+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);"
"Since non-Haar wavelets need to look into pixels outside the frame, we need to pad the buffer.","+    s->buffer = av_calloc((p_stride + slice_w)*(p_height + slice_h), sizeof(dwtcoef));"
Do not trust the counts.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme ELST count exceeds implementation limit."");"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
"In FFmpeg 3.2 and 4.0.1, an improper argument (AVCodecParameters) passed to the avpriv_request_sample function in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array read while converting a crafted AVI file to MPEG4, leading to a denial of service and possibly an information disclosure.","-                avpriv_request_sample(track->par, ""Multiple independent substreams"");"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.",+        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);
avcodec/jpeg2000dec: More completely check cdef.,+        if (s->cdef[x] < 0) {
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.",-    if (s->ref && sh->first_slice_in_pic_flag) {
Do not trust the counts.,+  RCHECK(count <= edits.max_size());
mov: Fix negative size calculation in mov_read_default().,+            if (a.size == 1 && total_size + 8 <= atom.size) {
Fixes: out of array accesses.,"-                if (delta > data_len[j]) {
-                    return AVERROR_INVALIDDATA;
-                }"
avcodec/mpeg4videodec: Check read profile before setting it.,"+            } else if (s->studio_profile) {
+                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
+                return AVERROR_PATCHWELCOME;
             }"
FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.,+        zstream.avail_out = buf_size - 1;
Fixes out of array access,"-    tile->coord[0][1] = FFMIN((tilex + 1) * s->tile_width  + s->tile_offset_x, s->width);"
avcodec/mpeg4videodec: Check read profile before setting it.,"+            int profile, level;"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.",+                prev_pkt[channel_id].size);
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(count <= edits.max_size());
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b3 - b7) >> 7)];
Fixes out of array access. ,-        if (s->codec_id == AV_CODEC_ID_JV) {
avcodec/mpeg4videodec: Check read profile before setting it.,"+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)"
"The smka_decode_frame function in libavcodec/smacker.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 does not verify that the data size is consistent with the number of channels, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Smacker data.",+    if (unp_size % (avctx->channels * (bits + 1))) {
avformat/avidec: Fix infinite loop in avi_read_nikon().,+    while (avio_tell(s->pb) < end && !avio_feof(s->pb)) {
Fixes: out of array read. ,-            } else {
Crash Type: Stack-buffer-overflow WRITE 1.,"+        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }"
Fixes: out of array read. ,"             v = get_bits(gb, 8);"
Crash Type: Heap-buffer-overflow WRITE {*}.,+    if (s->width != avctx->width || s->height != avctx->height) {
avcodec/mpeg4videoenc: Use 64 bit for times in mpeg4_encode_gop_header().,"+    int64_t hours, minutes, seconds;"
Integer overflow in the asf_write_packet function in libavformat/asfenc.c in FFmpeg before 2.8.5 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PTS (aka presentation timestamp) value in a .mov file.,     pts *= 10000;
avcodec/h264: Clear delayed_pic on deallocation.,"+        memset(h->delayed_pic, 0, sizeof(h->delayed_pic));"
"libavcodec/webp.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not ensure that pix_fmt is set, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file, related to the vp8_decode_mb_row_no_filter and pred8x8_128_dc_8_c functions.",+    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  size_t sample_count = reader->box_size() - reader->pos();
There is a heap-buffer-overflow at libavfilter/vf_colorconstancy.c:282 in slice_get_derivative.,"+    if (layout == PREFIX_FOR_22POINT2 && tags == 16 && i == 8) {
+        const uint8_t (*reference_layout_map)[3] = aac_channel_layout_map[12];
+        for (int j = 0; j < tags; j++) {
+            if (layout_map[j][0] != reference_layout_map[j][0] ||
+                layout_map[j][2] != reference_layout_map[j][2])
+                goto end_of_layout_definition;
+        }"
The decode_init function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via an AVI file.,"         av_log(avctx, AV_LOG_DEBUG, ""Encoder version %d.%d.%d.%d\n"",
                avctx->extradata[3], avctx->extradata[2],
                avctx->extradata[1], avctx->extradata[0]);"
avformat/rtmppkt: Check for packet size mismatches.,+    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {
Fixes: use of uninitialized variables. ,"-            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,"
"The sdp_parse_fmtp_config_h264 function in libavformat/rtpdec_h264.c in FFmpeg before 3.3.4 mishandles empty sprop-parameter-sets values, which allows remote attackers to cause a denial of service (heap buffer overflow) or possibly have unspecified other impact via a crafted sdp file.","+        if (*value == 0 || value[strlen(value) - 1] == ',') {
            av_log(s, AV_LOG_WARNING, ""Missing PPS in sprop-parameter-sets, ignoring\n"");
            return 0;
        }"
Check for bitstream end in read_quant_matrix_ext(). ,"+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;"
Revert to zero-initializing buffers for FFmpegVideoDecoder.,+    const size_t num_planes = VideoFrame::NumPlanes(frame->format());
Fixes: assertion failure.,"+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
+        s->avctx->bits_per_raw_sample = 0;"
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,             pes_header_data_length = avio_r8(pb);
avcodec/utvideodec: Check subsample factors.,"+    if ((avctx->width  & ((1<<h_shift)-1)) ||
+        (avctx->height & ((1<<v_shift)-1))) {
+        avpriv_request_sample(avctx, ""Odd dimensions"");
+        return AVERROR_PATCHWELCOME;
+    }"
"When a crafted CINE file, which claims a large ""duration"" field in the header but does not contain sufficient backing data, is provided, the image-offset parsing loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Remove use of FF_PROFILE_MPEG4_SIMPLE_STUDIO as indicator of studio profile.,"     if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
        !s->cur_pic.f                                                  ||
-       s->cur_pic.field_picture                                       ||
-       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO
+       s->cur_pic.field_picture
     )"
Crash Type: Stack-buffer-overflow WRITE 1.,"+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);"
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 3*stride] = av_clip_uint8( dst[i + 3*stride] + ((b3 + b7) >> 7));
"Due to incorrect use of strtoll function > and integer sizes (chunk_size in int64_t)[2], it was possible to pass > negative chunk_size in chunk encoding, so after computing final size > using FFMIN function later on it would be passed as argument to > avio_read function.",+            av_assert0(len <= c->chunk_size);
FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.,"+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);"
libavformat/movenc.c in FFmpeg 3.2 and 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format.,-        if (track->timescale > UINT16_MAX) {
"In libavformat/nsvdec.c in FFmpeg 2.4 and 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large ""table_entries_used"" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.","+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
"The ff_hevc_parse_sps function in libavcodec/hevc_ps.c in FFmpeg before 2.8.2 does not validate the Chroma Format Indicator, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted High Efficiency Video Coding (HEVC) data.","+    if (sps->chroma_format_idc > 3U) {
+        av_log(avctx, AV_LOG_ERROR, ""chroma_format_idc %d is invalid\n"", sps->chroma_format_idc);
+        return AVERROR_INVALIDDATA;
+    }"
avcodec/utvideodec: Add several out of array read related checks.,"+            if (3 * ((dst + send * stride - dest + 7)/8) > get_bits_left(&cbit))
+                return AVERROR_INVALIDDATA;"
SUMMARY: AddressSanitizer: stack-buffer-overflow.,"     int i, n, total_non_cc_elements;"
zero initialize the rbsp buffer. ,+    int min_size = size;
avcodec/utvideodec: Add several out of array read related checks.,"+                    if ((bits + 1) * 8 > get_bits_left(&pbit))
+                        return AVERROR_INVALIDDATA;"
avcodec/exr: Check tile positions.,"+        if (s->xmin || s->ymin) {
+            avpriv_report_missing_feature(s->avctx, ""Tiles with xmin/ymin"");
+            return AVERROR_PATCHWELCOME;
+        }"
avcodec/exr: Check tile positions.,"+        if (line < s->ymin || line > s->ymax ||
+            col  < s->xmin || col  > s->xmax)
+            return AVERROR_INVALIDDATA;"
Fixes out of array access.,         sbr->kx[0] = sbr->kx[1];
avformat/mxfdec: Fix av_log context.,"+                    av_log(mxf, AV_LOG_TRACE, ""could not resolve essence container data strong ref\n"");"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"When a crafted RL2 file, which claims a large ""frame_count"" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
Fixes: Out of array access. ,             j = scantable[idx++];
"he flv_write_packet function in libavformat/flvenc.c in FFmpeg through 2.8 does not check for an empty audio packet, leading to an assertion failure.","+    if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {
+        av_log(s, AV_LOG_WARNING, ""Empty audio Packet\n"");
+        return AVERROR(EINVAL);
+    }"
The decode_plane function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,"+            if (3 * ((dst + send * stride - dest + 7)/8) > get_bits_left(&cbit))
+                return AVERROR_INVALIDDATA;"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init().,"-    memset(&s->new_picture, 0, sizeof(s->new_picture));"
Its easier to just avoid it and use only studio_profile.,"     if (avctx->bits_per_raw_sample > 8) {
-        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
+        av_assert1(s->studio_profile);
         return avctx->pix_fmt;
     }"
"But when using this structure in read_header() of libavcodec/ffv1dec.c, It will minus a bigger trailer than buf_size to read size through AV_RB24().",             int size = AV_RB24(p-trailer);
"In FFmpeg 2.4 and 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop).","+        if (reload_count > c->max_reload)
+            return AVERROR_EOF;"
avformat/rl2: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
Fixes: NULL pointer dereference and out of array access.,-    if (s->ref && sh->first_slice_in_pic_flag) {
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",if (!copy->internal) {
avcodec/xwddec: Check bpp more completely.,"+        if (bpp == 1 && pixdepth == 1) {
             avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;"
avcodec/ac3_parser: Check init_get_bits8() for failure.,"+    if (err < 0)
+        return AVERROR_INVALIDDATA;"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
"These 2 fields are not always the same, it is simpler to always use the same field for detecting studio profile.","+    if (s->codec_id == AV_CODEC_ID_MPEG4)
+        s->idsp.mpeg4_studio_profile = s->studio_profile;"
avformat/avidec: Fix memleak with dv in avi.,"+                if (s->streams[0]->internal)
+                    av_freep(&s->streams[0]->internal->avctx);"
avformat/asfenc: Check pts.,"+    if (   pts < - PREROLL_TIME
+        || pts > (INT_MAX-3)/10000LL * ASF_INDEXED_INTERVAL - PREROLL_TIME) {
+        av_log(s, AV_LOG_ERROR, ""input pts %""PRId64"" is invalid\n"", pts);
+        return AVERROR(EINVAL);
+    }"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.",+    s->buf = av_malloc(s->buf_size);
rawenc: Only accept the appropriate stream type for raw muxers.,"+    if (   s->oformat->video_codec != AV_CODEC_ID_NONE
+        && s->streams[0]->codecpar->codec_type != AVMEDIA_TYPE_VIDEO) {
+        av_log(s, AV_LOG_ERROR, ""%s files have exactly one video stream\n"",
+               s->oformat->name);
+        return AVERROR(EINVAL);
+    }"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    *level   = get_bits(gb, 4);"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.",+    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
"When a crafted RL2 file, which claims a large ""frame_count"" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
Fix overheads in gauss array.,"                         dst[INDX2D(r, c, width)] += GAUSS(src, r + GINDX(filtersize, g), c,
-                                                          width, height, width, gauss[GINDX(filtersize, g)]);
+                                                          width, height, width, gauss[g]);"
avcodec/alac: Clear pointers in allocate_buffers().,"+    for (ch = 0; ch < 2; ch++) {
+        alac->predict_error_buffer[ch]  = NULL;
+        alac->output_samples_buffer[ch] = NULL;
+        alac->extra_bits_buffer[ch]     = NULL;
+    }"
Heap-based buffer overflow in the decode_block function in libavcodec/exr.c in FFmpeg before 3.1.3 allows remote attackers to cause a denial of service (application crash) via vectors involving tile positions.,"+        if (line < s->ymin || line > s->ymax ||
+            col  < s->xmin || col  > s->xmax)
+            return AVERROR_INVALIDDATA;"
Do not trust the counts.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckedNumeric<size_t>(bytes_per_entry);"
avcodec/mpeg4videodec: Check read profile before setting it.,"+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
+                (level > 0 && level < 9)) {"
swscale/utils: Clear pix buffers.,"-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b3 + b7) >> 7)];
Check for bitstream end in read_quant_matrix_ext(). ,"+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;"
It does not stop leaks via remote addresses in the LAN.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.",+    s->buf_size = avctx->width*avctx->height*2 + 1000;
"FFmpeg 2.8 and 4.2.3 has a use-after-free via a crafted EXTINF duration in an m3u8 file because parse_playlist in libavformat/hls.c frees a pointer, and later that pointer is accessed in av_probe_input_format3 in libavformat/format.c.",-                seg->duration = duration;
"The gmc_mmx function in libavcodec/x86/mpegvideodsp.c in FFmpeg 2.3 and 3.4 does not properly validate widths and heights, which allows remote attackers to cause a denial of service (integer signedness error and out-of-array read) via a crafted MPEG file.","+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
+                     (unsigned) iy >= height - h || height< h
+                     ;"
Fixes integer overflow. ,-    if (cfg->pic_width < 1 || cfg->pic_height < 1 ||
Fixes: out of array read. ,"-                av_log(NULL, AV_LOG_ERROR,
-                       ""Corrupt stream (too many A/V streams)\n"");"
There is a heap-buffer-overflow at libavfilter/vf_colorconstancy.c:282 in slice_get_derivative.,"                         dst[INDX2D(r, c, width)] += GAUSS(src, r,                        c + GINDX(filtersize, g),
-                                                          in_linesize, height, width, gauss[GINDX(filtersize, g)]);
+                                                          in_linesize, height, width, gauss[g]);"
avcodec/smacker: Check that the data size is a multiple of a sample vector.,+    if (unp_size % (avctx->channels * (bits + 1))) {
avformat/mxfdec: Fix Sign error in mxf_read_primer_pack().,+    if (item_num > 65536 || item_num < 0) {
"In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    if (err < 0)
+        return AVERROR_INVALIDDATA;"
Fixes out of array access. ,"+    if (sps->chroma_format_idc > 3U) {
+        av_log(avctx, AV_LOG_ERROR, ""chroma_format_idc %d is invalid\n"", sps->chroma_format_idc);
+        return AVERROR_INVALIDDATA;
+    }"
Fixes: out of array access.,if (buf_size < ctx->data_offset) {
Fixes out of array access.,"                    !memcmp(c->buffer_ptr - 1, ""\r\n"", 2)) {"
Fixes out of array access.,"         if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,
                                          size)) < 0)"
"The decode_uncompressed function in libavcodec/faxcompr.c in FFmpeg before 2.8.2 does not validate uncompressed runs, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted CCITT FAX data.","+        if (*runs >= runend) {
+            av_log(avctx, AV_LOG_ERROR, ""uncompressed run overrun\n"");
+            return AVERROR_INVALIDDATA;
+        }"
Previously we would accept malformed vp8 video files that had alpha and image planes with different dimensions.,"-             vpx_image->d_h,"
avcodec/msrledec: avcodec/msrledec: restructure msrle_decode_pal4() based on the line number instead of the pixel pointer.,"+    while (line >= 0 && pixel_ptr <= avctx->width) {
         if (bytestream2_get_bytes_left(gb) <= 0) {
             av_log(avctx, AV_LOG_ERROR,
-                   ""MS RLE: bytestream overrun, %d rows left\n"",
-                   row_ptr);
+                   ""MS RLE: bytestream overrun, %dx%d left\n"",
+                   avctx->width - pixel_ptr, line);
             return AVERROR_INVALIDDATA;
         }"
"The ff_mpv_common_init function in libavcodec/mpegvideo.c in FFmpeg before 2.7.2 does not properly maintain the encoding context, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted MPEG data.","-    memset(&s->current_picture, 0, sizeof(s->current_picture));"
The old factor of two seemed to be a workaround that fact and only padded to the left and bottom.,-    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));
avformat/rl2: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
swscale/utils: Clear pix buffers.,"-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"The decode_ihdr_chunk function in libavcodec/pngdec.c in FFmpeg before 2.7.2 does not enforce uniqueness of the IHDR (aka image header) chunk in a PNG image, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted image with two or more of these chunks.","+    if (s->state & PNG_IHDR) {
+        av_log(avctx, AV_LOG_ERROR, ""Multiple IHDR\n"");
+        return AVERROR_INVALIDDATA;
+    }"
block_cmp() in libavcodec/zmbvenc.c in FFmpeg 4.1.3 has a heap-based buffer over-read.,"-    prev_offset = FFALIGN(c->lrange, 16) + c->pstride * c->lrange;"
Fixes out of array access. ,-    for (plane = 0; out->data[plane]; plane++) {
Failure to verify causes total_size > atom.size which will result in negative size calculations later on.,-            if (a.size == 1) {
"The ff_get_buffer function in libavcodec/utils.c in FFmpeg before 2.8.4 preserves width and height values after a failure, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .mov file.",-    if (ret < 0)
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",+            copy->priv_data = NULL;
avformat/pva: Check for EOF before retrying in read_part_of_packet().,"+            if (avio_feof(pb)) {
+                return AVERROR_EOF;
+            }"
avcodec/utvideodec: Add several out of array read related checks.,"+                if (c->control_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Check read profile before setting it.,+            s->avctx->level   = level;
Fixes: division by 0.,-        if (track->timescale > UINT16_MAX) {
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)"
Fixes: out of array read.,"             v = get_bits(gb, 8);"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_edit, static_cast<size_t>(count));"
"So it reads the front memory of bytestream, and get an error size.",             int size = AV_RB24(p-trailer);
avcodec/pngdec: Fix off by 1 size in decode_zbuf().,+        zstream.avail_out = buf_size - 1;
"libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.","+            if (y >= avctx->height)
+                return AVERROR_INVALIDDATA;"
avcodec/mjpegdec: Fix small picture upscale.,"+                        if (w > 1)
+                            ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[w - 1];"
Failure to verify causes total_size > atom.size which will result in negative size calculations later on.,-            if (a.size == 1) {
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  const size_t bytes_per_edit = reader->version() == 1 ? 20 : 12;
"Also use the alpha image stride when copying the alpha plane, because it technically doesn't have to be the same as the image stride.","+             vpx_image_alpha->stride[VPX_PLANE_Y],"
1. avcodec/ansi: Check dimensions.,"+    } else if (avctx->width % FONT_WIDTH || avctx->height % s->font_height) {
+        av_log(avctx, AV_LOG_ERROR, ""Invalid dimensions %d %d\n"", avctx->width, avctx->height);
+        return AVERROR(EINVAL);
     }"
Do not trust the counts.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,             j = scantable[idx++];
Fixes use of freed memory. ,         av_freep(&h->DPB);
Fixes out of array access.,-                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;
avformat/asfdec: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
"In FFmpeg 3.2 and 4.0.1, an improper argument (AVCodecParameters) passed to the avpriv_request_sample function in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array read while converting a crafted AVI file to MPEG4, leading to a denial of service and possibly an information disclosure.","+                avpriv_request_sample(mov->fc, ""Multiple independent substreams"");"
FFmpeg before commit bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 contains an out of array access vulnerability in MXF format demuxer that can result in DoS.,"                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {"
Fixes: NULL pointer dereference and out of array access.,         if (s->sh.first_slice_in_pic_flag) {
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(sample_count <= sample_depends_on_.max_size());
Fixes: null pointer dereference. ,"-    if (s->avctx->profile == 0 && s->avctx->level == 8) {
-        s->avctx->level = 0;"
"In FFmpeg 4.0.1, due to a missing check for negative values of the mquant variable, the vc1_put_blocks_clamped function in libavcodec/vc1_block.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to an information disclosure or a denial of service.",-        if (!mquant || mquant > 31) {                          \
Fixes out of array access. ,                         ptr = s->picture_ptr->data[c] + (linesize * (v * mb_y + y)) + (h * mb_x + x);
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b2 - b6) >> 7)];
"The ff_dwt_decode function in libavcodec/jpeg2000dwt.c in FFmpeg before 2.8.4 does not validate the number of decomposition levels before proceeding with Discrete Wavelet Transform decoding, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    if (s->ndeclevels == 0)
+        return 0;"
aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.,"-            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,"
"The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.","         if (c->palette_size != (1 << (c->bpp - 1)))
             return AVERROR_INVALIDDATA;"
Fixes: null pointer dereference. ,     hdr = *phdr;
Clear pointers in ff_rv34_decode_init_thread_copy().,+        r->cbp_luma         = NULL;
avformat/hls: Fix DoS due to infinite loop.,"+        if (reload_count > c->max_reload)
+            return AVERROR_EOF;"
"When a crafted MV file, which claims a large ""nb_frames"" field in the header but does not contain sufficient backing data, is provided, the loop over the frames would consume huge CPU and memory resources, since there is no EOF check inside the loop.","+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
"The h264_slice_header_init function in libavcodec/h264_slice.c in FFmpeg before 2.8.3 does not validate the relationship between the number of threads and the number of slices, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted H.264 data.","+    h->max_contexts = FFMIN(h->max_contexts, nb_slices);"
h264dec: handle zero-sized NAL units in get_last_needed_nal().,"+            if (ret < 0) {
+                av_log(h->avctx, AV_LOG_ERROR, ""Invalid zero-sized VCL NAL unit\n"");
+                if (h->avctx->err_recognition & AV_EF_EXPLODE)
+                    return ret;
+
+                break;
+            }"
avformat/movenc: Check input sample count.,"+    if (samples_in_chunk < 1) {
+        av_log(s, AV_LOG_ERROR, ""fatal error, input packet contains no samples\n"");
+        return AVERROR_PATCHWELCOME;
+    }"
MSE: Fix moar mp4 parsing security bugs.,+  for (size_t i = 0; i < sample_count; ++i) {
avcodec/htmlsubtitles: Fixes denial of service due to use of sscanf in inner loop for handling braces.,"-            an += sscanf(in, ""{\\an%*1u}%n"", &len) >= 0 && len > 0;"
Issue 449958: Heap-buffer-overflow in media::CopyPlane. ,"-             vpx_image->stride[VPX_PLANE_Y],"
Multiple integer underflows in the ff_mjpeg_decode_frame function in libavcodec/mjpegdec.c in FFmpeg before 2.7.2 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.,-                        ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[(w - 1) / 3];
Fixes: out of array access. ,"                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {"
Fixes: out of array read. ,-                mms->stream_num++;
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 6*stride] = av_clip_uint8( dst[i + 6*stride] + ((b1 - b5) >> 7));
Fixes out of array access.,     if (!prev_pkt[channel_id].read) {
"libavcodec/webp.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not ensure that pix_fmt is set, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file, related to the vp8_decode_mb_row_no_filter and pred8x8_128_dc_8_c functions.",+    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme ELST count exceeds implementation limit."");"
The decode_frame function in libavcodec/utvideodec.c in FFmpeg through 3.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,"                 if (slice_end < 0 || slice_end < slice_start ||
-                    bytestream2_get_bytes_left(&gb) < slice_end) {
+                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL)"
Fixes: Null pointer dereference. ,-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
"The h264_slice_header_init function in libavcodec/h264_slice.c in FFmpeg before 2.8.3 does not validate the relationship between the number of threads and the number of slices, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted H.264 data.","+    h->max_contexts = FFMIN(h->max_contexts, nb_slices);"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->mb_type          = NULL;
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b3 - b7) >> 7)];
Fixes: Null pointer dereference.,"-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->intra_types_hist = NULL;
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.","+                size,"
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",copy->internal = av_malloc(sizeof(AVCodecInternal));
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.","-            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,"
ffserver: Check chunk size.,"+            if (c->chunk_size <= 0) { // end of stream or invalid chunk size
+                c->chunk_size = 0;
                 goto fail;
+            }"
check that the element type matches before applying SBR: ,"+    if (id_aac != sbr->id_aac) {
+        av_log(ac->avctx, AV_LOG_ERROR,
+            ""element type mismatch %d != %d\n"", id_aac, sbr->id_aac);
+        sbr_turnoff(sbr);
+    }"
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 5*stride] = av_clip_uint8( dst[i + 5*stride] + ((b2 - b6) >> 7));
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",-    if (s->ref && sh->first_slice_in_pic_flag) {
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme SGPD count exceeds implementation limit."");"
Fixes out of array access. ,"+        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
+            w_align = 8;
+            h_align = 8;
+        }"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b4) >> 7)];
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions. ",+    s->buf = av_malloc(s->buf_size);
Fixes out of array access. ,"+    if (s->state & PNG_IDAT) {
+        av_log(avctx, AV_LOG_ERROR, ""trns after IDAT\n"");
+        return AVERROR_INVALIDDATA;
+    }"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init(). ,"-    memset(&s->new_picture, 0, sizeof(s->new_picture));"
Fixes: Null pointer dereference.,-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
Reject vp8 video having alpha and image planes of different sizes.,"+      if (vpx_image_alpha->d_h != vpx_image->d_h ||
+          vpx_image_alpha->d_w != vpx_image->d_w) {
+        LOG(ERROR) << ""The alpha plane dimensions are not the same as the ""
+                      ""image dimensions."";
+        return false;
+      }"
"Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size.",-            if (c->chunk_size == 0)
avformat/mov: Check sample size.,"+                if (size > 0x3FFFFFFF) {
+                    av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\n"", size);
+                    return;
+                }"
It prevents the existing exploit leading to an information leak.,"static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
avcodec/mpeg4videodec: Remove use of FF_PROFILE_MPEG4_SIMPLE_STUDIO as indicator of studio profile.,"     if (avctx->bits_per_raw_sample > 8) {
-        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
+        av_assert1(s->studio_profile);
         return avctx->pix_fmt;
     }"
Fixes: out of array read. ,-            stream_id = flags & 0x7F;
Fixes: out of array read. ,"-    int need_emu  =  (unsigned) ix >= width  - w ||
-                     (unsigned) iy >= height - h;"
Issue 449958: Heap-buffer-overflow in media::CopyPlane.,"-             vpx_image->d_h,"
swscale/utils: Clear pix buffers.,"+    FF_ALLOCZ_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
avformat/rtmppkt: Check for packet size mismatches.,+        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b2 + b6) >> 7)];
avcodec/apedec: Fix integer overflow.,         blockstodecode = s->samples;
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","-    s->avctx->profile = get_bits(gb, 4);"
avcodec/scpr: Check y in first line loop in decompress_i().,"+            if (y >= avctx->height)
+                return AVERROR_INVALIDDATA;"
"An inconsistent bits-per-sample value in the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c in FFmpeg 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
+        s->avctx->bits_per_raw_sample = 0;"
avcodec/ac3_parser: Check init_get_bits8() for failure.,"+    err = init_get_bits8(&gb, buf, size);"
Avoids leaving stale pointers. ,+        r->deblock_coefs    = NULL;
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 4*stride] = av_clip_uint8( dst[i + 4*stride] + ((b3 - b7) >> 7));
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
Crash Type: Use-of-uninitialized-value.,-    frame = VideoFrame::CreateFrame(
This avoids mixing 8bit variants with pro and 10bit with non pro mode.,+    } else if (!c->pro && avctx->extradata_size >= 16) {
"The flv_write_packet function in libavformat/flvenc.c in FFmpeg through 2.8 does not check for an empty audio packet, leading to an assertion failure.","     if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||
         par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)
         flags_size = 2;"
Check ymin vs. h.,             ptr += picture->linesize[i];
Fixes: integer overflow and out of array access.,"         if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size + 
		 AV_INPUT_BUFFER_PADDING_SIZE))) {"
"Also use the alpha image stride when copying the alpha plane, because it technically doesn't have to be the same as the image stride.","+             vpx_image_alpha->d_h,"
swscale/swscale_unscaled: Fix odd height inputs for bayer_to_yv12_wrapper().,"+    if (i + 1 == srcSliceH) {
+        copy(srcPtr, -srcStride[0], dstY, dstU, dstV, -dstStride[0], c->srcW, c->input_rgb2yuv_table);
+    }"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.","+                        if (   h * mb_x + x >= s->width
+                            || v * mb_y + y >= s->height) {
+                        } else if (bits<=8) {"
Avoids leaving stale pointers. ,+        r->mb_type          = NULL;
avcodec/vc1_block: Fix mqaunt check for negative values,+        if (!mquant || mquant > 31 || mquant < -31) {                          \
Do not trust the counts.,+  RCHECK(sample_count <= sample_depends_on_.max_size());
fix ticket: 8673. set the default EXTINF duration to 1ms if duration is smaller than 1ms.,"+                if (duration < 0.001 * AV_TIME_BASE) {
+                    av_log(c->ctx, AV_LOG_WARNING, ""Cannot get correct #EXTINF value of segment %s,""
+                                    "" set to default value to 1ms.\n"", seg->url);
+                    duration = 0.001 * AV_TIME_BASE;
+                }"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b4) >> 7)];
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 0*stride] = av_clip_uint8( dst[i + 0*stride] + ((b0 + b4) >> 7));
"Heap-based buffer overflow in libavformat/rtmppkt.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check for RTMP packet size mismatches.","         if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,
                                          size)) < 0)"
The decode_plane function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,"+                if (c->control_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
"The VC-2 Video Compression encoder in FFmpeg 3.0 and 3.4 allows remote attackers to cause a denial of service (out-of-bounds read) because of incorrect buffer padding for non-Haar wavelets, related to libavcodec/vc2enc.c and libavcodec/vc2en.",-    av_freep(&s->buffer);
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->deblock_coefs    = NULL;
"The VideoFramePool::PoolImpl::CreateFrame function in media/base/video_frame_pool.cc in Google Chrome before 47.0.2526.73 does not initialize memory for a video-frame data structure, which might allow remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact by leveraging improper interaction with the vp3_h_loop_filter_c function in libavcodec/vp3dsp.c in FFmpeg.",+    const size_t num_planes = VideoFrame::NumPlanes(frame->format());
Fixes: Infinite loop. ,             pes_flags              = avio_rb16(pb);
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 1*stride] = av_clip_uint8( dst[i + 1*stride] + ((b1 + b5) >> 7));
avcodec/pngdec: Fix off by 1 size in decode_zbuf().,"+        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }"
avcodec/cbs_jpeg: Check length for SOS.,"+            if (length > end - start)
+                return AVERROR_INVALIDDATA;"
"libavcodec/tiff.c in FFmpeg before 2.8.6 does not properly validate RowsPerStrip values and YCbCr chrominance subsampling factors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted TIFF file, related to the tiff_decode_tag and decode_frame functions.","+            if (s->subsampling[i] <= 0) {
+                av_log(s->avctx, AV_LOG_ERROR, ""subsampling %d is invalid\n"", s->subsampling[i]);
+                return AVERROR_INVALIDDATA;
+            }"
avcodec/utvideodec: Fix bytes left check in decode_frame().,"                 if (slice_end < 0 || slice_end < slice_start ||
-                    bytestream2_get_bytes_left(&gb) < slice_end) {
+                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL)"
"When a crafted NSV file, which claims a large ""table_entries_used"" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.","+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
"Due to incorrect use of strtoll function > and integer sizes (chunk_size in int64_t)[2], it was possible to pass > negative chunk_size in chunk encoding, so after computing final size > using FFMIN function later on it would be passed as argument to > avio_read function.","+            if (c->chunk_size <= 0) { // end of stream or invalid chunk size
+                c->chunk_size = 0;
                 goto fail;
+            }"
Fixes: null pointer dereference. ,"-    s->avctx->level   = get_bits(gb, 4);"
Revert to zero-initializing buffers for FFmpegVideoDecoder. ,+    const size_t num_planes = VideoFrame::NumPlanes(frame->format());
avformat/avidec: Fix infinite loop in avi_read_nikon().,+            while (avio_tell(s->pb) < tag_end && !avio_feof(s->pb)) {
"We must check for size_t overflow when multiplying count by ""bytes_per_offset"".",+  RCHECK(reader->Read4(&count));
This ensures that no stale pointers leak through on any path. ,"-    memset(&s->last_picture, 0, sizeof(s->last_picture));"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.","+    ff_lzw_encode_init(s->lzw, s->buf, s->buf_size,"
Do not trust the counts.,+  size_t sample_count = reader->box_size() - reader->pos();
Revert to zero-initializing buffers for FFmpegVideoDecoder. ,"+    for (size_t i = 0; i < num_planes; ++i) {
+      memset(frame->data(i),
+             0,
+             VideoFrame::PlaneSize(frame->format(),
+                                   i,
+                                   frame->coded_size()).GetArea());
+    }"
Fixes out of array access.,-                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;
Check for bitstream end in read_quant_matrix_ext(). ,"+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Check read profile before setting it.,"+            mpeg4_decode_profile_level(s, gb, &profile, &level);"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",+            s->avctx->profile = profile;
It prevents the existing exploit leading to an information leak.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
Fixes use of uninitialized memory.,"-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size.",+            av_assert0(len <= c->chunk_size);
"When a crafted MXF file, which claims a large ""nb_index_entries"" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU resources, since there is no EOF check inside the loop.","+        if(avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
MSE: Fix moar mp4 parsing security bugs.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_entry, static_cast<size_t>(count));"
Fixes out of array access. ,     samples  = (int16_t *)frame->data[0];
avformat/hls: Check local file extensions.,"static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
Avoids leaving stale pointers. ,+        r->intra_types_hist = NULL;
Fixes: integer overflow and out of array access.,         st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;
avcodec/tiff: Check subsample & rps values more completely,"+            if (s->subsampling[i] <= 0) {
+                av_log(s->avctx, AV_LOG_ERROR, ""subsampling %d is invalid\n"", s->subsampling[i]);
+                return AVERROR_INVALIDDATA;
+            }"
Fixes use of uninitialized memory.,"-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
Fixes: assertion failure. ,"+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
+        s->avctx->bits_per_raw_sample = 0;"
Crash Type: Heap-buffer-overflow WRITE 1.,             uint8_t *row = &s->image_buf[s->image_linesize * y];
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(count <= entries.max_size());
Fixes: out of array read. ,"             get_bits(gb, 8);"
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.",   entries.resize(count);
Fixes: out of array read.,"             get_bits(gb, 8);"
FFmpeg before 2017-02-07 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame function in libavcodec/pictordec.c.,+    if (s->width != avctx->width || s->height != avctx->height) {
"The ff_sbr_apply function in libavcodec/aacsbr.c in FFmpeg before 2.7.2 does not check for a matching AAC frame syntax element before proceeding with Spectral Band Replication calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted AAC data.",     if (id_aac == TYPE_SCE || id_aac == TYPE_CCE) {
Fixes: out of array access.,    s->width = AV_RL16(&s->avctx->extradata[6]);
Fixes: out of array access.,"     if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {
         ctx->data_offset = 0x170 + (ctx->mb_height << 2);
     }"
This avoids mixing 8bit variants with pro and 10bit with non pro mode.,+    } else if (c->pro && avctx->extradata_size == 8) {
Crash Type: Use-of-uninitialized-value.,"-        format, coded_size, visible_rect, natural_size, timestamp);"
"In line libavcodec/h264dec.c:500 in libav(v13_dev0), ffmpeg(n3.4), chromium(56 prior Feb 13, 2017), the return value of init_get_bits is ignored and get_ue_golomb(&gb) is called on an uninitialized get_bits context, which causes a NULL deref exception.","-            ret = init_get_bits8(&gb, nal->data + 1, (nal->size - 1));"
avformat/rtmppkt: Check for packet size mismatches.,+        prev_pkt[channel_id].read = 0;
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
The decode_init function in libavcodec/utvideodec.c in FFmpeg 2.8 through 3.4.2 allows remote attackers to cause a denial of service (Out of array read) via an AVI file with crafted dimensions within chroma subsampling data.,"+    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &h_shift, &v_shift);"
Fixes use of freed memory. ,"for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
             ff_h264_unref_picture(h, &h->DPB[i]);"
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(count <= edits.max_size());
Fixes out of array access. ,+        zstream.avail_out = buf_size - 1;
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,             pes_flags              = avio_rb16(pb);
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",             err = AVERROR(ENOMEM);
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,             pes_flags              = avio_rb16(pb);
avformat/vividas: improve extradata packing checks in track_header().,"+            ret = ff_alloc_extradata(st->codecpar, xd_size);"
But such solutions are fragile and tricky to implement portably and would not stop every possible attack nor would they work with all valid hls files.,"static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
avcodec/mpeg4videodec: Check read profile before setting it.,+            s->avctx->profile = profile;
Fixes use of freed memory.,         av_freep(&h->DPB);
Fixes out of array access. ,         sbr->m[0] = sbr->m[1];
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  const size_t bytes_per_edit = reader->version() == 1 ? 20 : 12;
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.",-        return 1;
This reduces the attack surface of local file-system information leaking.,"-    if (!av_strstart(proto_name, ""http"", NULL) && !av_strstart(proto_name, ""file"", NULL))"
The avi_read_nikon function in libavformat/avidec.c in FFmpeg before 3.1.4 is vulnerable to infinite loop when it decodes an AVI file that has a crafted 'nctg' structure.,-    while (avio_tell(s->pb) < end) {
avcodec/htmlsubtitles: Fixes denial of service due to use of sscanf in inner loop for handling braces.,"+static int scanbraces(const char* in) {
+    if (strncmp(in, ""{\\an"", 4) != 0) {
+        return 0;
+    }
+    if (!isdigit(in[4])) {
+        return 0;
+    }
+    if (in[5] != '}') {
+        return 0;
+    }
+    return 1;
+}"
Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg 2.4 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file.,"-    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);"
SUMMARY: AddressSanitizer: stack-buffer-overflow.,-    if (tags == 16 && total_non_cc_elements == 16) {
avcodec/utvideodec: Add several out of array read related checks.,"+                if (c->packed_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
Fixes: null pointer dereference. ,"-    s->avctx->profile = get_bits(gb, 4);"
avcodec/jpeg2000dec: Clip all tile coordinates.,"+    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
avcodec/pngdec: Check trns more completely.,"+    if (!(s->state & PNG_IHDR)) {
+        av_log(avctx, AV_LOG_ERROR, ""trns before IHDR\n"");
+        return AVERROR_INVALIDDATA;
+    }"
avformat/avidec: Check nb_streams in read_gab2_sub().,"+            if (ast->sub_ctx->nb_streams != 1)
+                goto error;"
"The gmc_mmx function in libavcodec/x86/mpegvideodsp.c in FFmpeg 2.3 and 3.4 does not properly validate widths and heights, which allows remote attackers to cause a denial of service (integer signedness error and out-of-array read) via a crafted MPEG file.","+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
+                     (unsigned) iy >= height - h || height< h
+                     ;"
The new code verfies there's enough data in the atom for this to be done.,+            if (a.size == 1 && total_size + 8 <= atom.size) {
Fixes out of array access. ,"+        if (s->codec_id == AV_CODEC_ID_JV ||
+            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {"
avformat/rl2: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","-    if (s->avctx->profile == 0 && s->avctx->level == 8) {
-        s->avctx->level = 0;"
Fixes: null pointer dereference. ,"     ff_idctdsp_init(&s->idsp, s->avctx);"
Fixes: NULL pointer dereference and out of array access. ,         if (s->sh.first_slice_in_pic_flag) {
"The smka_decode_frame function in libavcodec/smacker.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 does not verify that the data size is consistent with the number of channels, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Smacker data.",+    if (unp_size % (avctx->channels * (bits + 1))) {
avcodec/dfa: Fix off by 1 error.,-            if (frame_end - frame < width + 3)
We should also avoid attempting to resize vectors beyond their max_size() (potential OOB depending on stl library impl).,+  RCHECK(reader->Read4(&count));
Fixes integer overflow.,     pts *= 10000;
Crash Type: Stack-buffer-overflow WRITE 1.,+        zstream.avail_out = buf_size - 1;
Fixes: out of array read. ,"-                mms->streams = av_fast_realloc(mms->streams,
-                                   &mms->nb_streams_allocated,
-                                   (mms->stream_num + 1) * sizeof(MMSStream));"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_entry, static_cast<size_t>(count));"
This ensures that no stale pointers leak through on any path. ,"-    memset(&s->new_picture, 0, sizeof(s->new_picture));"
"The ff_mpv_common_init function in libavcodec/mpegvideo.c in FFmpeg before 2.7.2 does not properly maintain the encoding context, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted MPEG data.","-    memset(&s->next_picture, 0, sizeof(s->next_picture));"
Fixes: out of array read. ,                        hdr->substreamid == 0 && info->substream[0].bsid) {
Do not trust the counts.,+  RCHECK(count <= entries.max_size());
Previously we would accept malformed vp8 video files that had alpha and image planes with different dimensions.,"-             vpx_image->stride[VPX_PLANE_Y],"
Fixes: Infinite loop. ,             pes_header_data_length = avio_r8(pb);
Fixes out of array access. ,"+        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }"
"The VideoFramePool::PoolImpl::CreateFrame function in media/base/video_frame_pool.cc in Google Chrome before 47.0.2526.73 does not initialize memory for a video-frame data structure, which might allow remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact by leveraging improper interaction with the vp3_h_loop_filter_c function in libavcodec/vp3dsp.c in FFmpeg.",+    const size_t num_planes = VideoFrame::NumPlanes(frame->format());
"The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.",-    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {
"clear priv_data, avoid stale pointer in error case",+            copy->priv_data = NULL;
Fixes: out of array access.,"-    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);"
avcodec/pngdec: Only allow one IHDR chunk: Multiple IHDR chunks are forbidden in PNG.,"+    if (s->state & PNG_IHDR) {
+        av_log(avctx, AV_LOG_ERROR, ""Multiple IHDR\n"");
+        return AVERROR_INVALIDDATA;
+    }"
avformat/rmdec: Do not pass mime type in rm_read_multi() to ff_rm_read_mdpr_codecdata().,"         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
-                                        size2, mime);
+                                        size2, NULL);"
Added one additional check for SampleEncryptionEntry (probably overkill).,+  RCHECK(sample_count <= sample_depends_on_.max_size());
avcodec/gif: Fix lzw buffer size.,+    s->buf = av_malloc(s->buf_size);
avcodec/dnxhd_parser: Do not return invalid value from dnxhd_find_frame_end() on error.,"-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;"
Fixes: out of array read. ,-                mms->streams[mms->stream_num].id = stream_id;
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.","+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_edit, static_cast<size_t>(count));"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b1 - b5) >> 7)];
Fixes inconsistency and out of array accesses.,     s->height = bytestream2_get_be32(&s->gb);
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    if (*profile == 0 && *level == 8) {
+        *level = 0;"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->cbp_luma         = NULL;
This ensures that no stale pointers leak through on any path. ,"-    memset(&s->current_picture, 0, sizeof(s->current_picture));"
"In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact.","+        } else {
+            if (hdr->substreamid != 0) {
+                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
+                ret = AVERROR_PATCHWELCOME;
+                goto end;
+            }
         }"
avcodec/apedec: Fix integer overflow.,"     if (!s->decoded_buffer)
         return AVERROR(ENOMEM);"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.","+    ff_lzw_encode_init(s->lzw, s->buf, s->buf_size,"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","+    FF_ALLOCZ_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
The avi_read_nikon function in libavformat/avidec.c in FFmpeg before 3.1.4 is vulnerable to infinite loop when it decodes an AVI file that has a crafted 'nctg' structure.,-            while (avio_tell(s->pb) < tag_end) {
"libswscale/swscale_unscaled.c in FFmpeg before 2.8.6 does not validate certain height values, which allows remote attackers to cause a denial of service (out-of-bounds array read access) or possibly have unspecified other impact via a crafted .cine file, related to the bayer_to_rgb24_wrapper and bayer_to_yv12_wrapper functions.","+    if (i + 1 == srcSliceH) {
+        copy(srcPtr, -srcStride[0], dstY, dstU, dstV, -dstStride[0], c->srcW, c->input_rgb2yuv_table);
+    }"
"In FFmpeg 3.2 and 4.1, a denial of service in the subtitle decoder allows attackers to hog the CPU via a crafted video file in Matroska format, because ff_htmlmarkup_to_ass in libavcodec/htmlsubtitles.c has a complex format argument to sscanf.","-           if (sscanf(in+tag_close+1, ""%127[^<>]>%n"", buffer, &len) >= 1 && len > 0) {"
"The VC-2 Video Compression encoder in FFmpeg 3.0 and 3.4 allows remote attackers to cause a denial of service (out-of-bounds read) because of incorrect buffer padding for non-Haar wavelets, related to libavcodec/vc2enc.c and libavcodec/vc2en.",-    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","+    FF_ALLOCZ_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init().,"-    memset(&s->last_picture, 0, sizeof(s->last_picture));"
avformat/avidec: Fix memleak with dv in avi.,+                av_freep(&s->streams[0]->codec);
avcodec/mjpegdec: Check number of components for JPEG-LS.,+        if (s->nb_components == 3) { s->avctx->pix_fmt = AV_PIX_FMT_RGB24;
The avi_read_seek function in libavformat/avidec.c in FFmpeg before 3.1.4 allows remote attackers to cause a denial of service (assert fault) via a crafted AVI file.,-        av_assert0(fabs(av_q2d(st2->time_base) - ast2->scale / (double)ast2->rate) < av_q2d(st2->time_base) * 0.00000001);
Fixes inconsistency and out of array accesses.,s->width  = bytestream2_get_be32(&s->gb);
"Since non-Haar wavelets need to look into pixels outside the frame, we need to pad the buffer.","+int  ff_vc2enc_init_transforms(VC2TransformContext *t, int p_stride, int p_height,
+                               int slice_w, int slice_h);"
Do not trust the counts.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
avcodec/mjpegdec: Fix small picture upscale.,"+                        if (w > 1)
+                            line[w - 2] = line[w - 1];"
avformat/aadec: Check for scanf() failure.,"+            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);"
avformat/movenc: Check that frame_types other than EAC3_FRAME_TYPE_INDEPENDENT have a supported substream id.,"+        } else {
+            if (hdr->substreamid != 0) {
+                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
+                ret = AVERROR_PATCHWELCOME;
+                goto end;
+            }
         }"
But files with sensitive information like private keys and passwords generally do not use common multimedia filename extensions.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
Integer overflow in the asf_write_packet function in libavformat/asfenc.c in FFmpeg before 2.8.5 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PTS (aka presentation timestamp) value in a .mov file.,"+    if (   pts < - PREROLL_TIME
+        || pts > (INT_MAX-3)/10000LL * ASF_INDEXED_INTERVAL - PREROLL_TIME) {
+        av_log(s, AV_LOG_ERROR, ""input pts %""PRId64"" is invalid\n"", pts);
+        return AVERROR(EINVAL);
+    }"
Fixes out of array read.,"-        if ((s->ncomponents & 1) == 0)
-            s->cdef[s->ncomponents-1] = 0;"
Fixes: out of array access. ,-        for (y = 0; y < s->ymin; y++) {
avcodec/mpeg4videodec: Clear bits_per_raw_sample if it has originated from a previous instance.,"+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
+        s->avctx->bits_per_raw_sample = 0;"
Added one additional check for SampleEncryptionEntry (probably overkill).,+  for (size_t i = 0; i < sample_count; ++i) {
h264dec: handle zero-sized NAL units in get_last_needed_nal().,"+            ret = init_get_bits8(&gb, nal->data + 1, nal->size - 1);"
Fixes: Null pointer dereference. ,"-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;"
Fixes use of uninitialized memory.,"-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b1 + b5) >> 7)];
"The ff_dwt_decode function in libavcodec/jpeg2000dwt.c in FFmpeg before 2.8.4 does not validate the number of decomposition levels before proceeding with Discrete Wavelet Transform decoding, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    if (s->ndeclevels == 0)
+        return 0;"
"Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.","             frame[0] = frame[1] =
             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);"
Fixes out of array access.,         sbr->m[0] = sbr->m[1];
mov: Fix negative size calculation in mov_read_default().,-            if (a.size == 1) {
Fixes: NULL pointer dereference and out of array access. ,-    if (s->ref && sh->first_slice_in_pic_flag) {
"Heap-based buffer overflow in the xwd_decode_frame function in libavcodec/xwddec.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",-        if (pixdepth == 1) {
"The ff_hevc_parse_sps function in libavcodec/hevc_ps.c in FFmpeg before 2.8.2 does not validate the Chroma Format Indicator, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted High Efficiency Video Coding (HEVC) data.","+    if (sps->chroma_format_idc > 3U) {
+        av_log(avctx, AV_LOG_ERROR, ""chroma_format_idc %d is invalid\n"", sps->chroma_format_idc);
+        return AVERROR_INVALIDDATA;
+    }"
MSE: Fix moar mp4 parsing security bugs.,+  RCHECK(count <= entries.max_size());
mov: Fix negative size calculation in mov_read_default().,-            if (a.size == 1) {
Fixes: out of array access.,"         av_log(ctx->avctx, AV_LOG_ERROR,"
Fixes out of array access,"-    tile->coord[1][0] = FFMAX(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y);"
Fixes out of array read.,"-        for (x = 0; x < s->ncomponents; x++)
-            s->cdef[x] = x + 1;"
Issue 449958: Heap-buffer-overflow in media::CopyPlane. ,"-             vpx_image->d_h,"
Check for duplicate SIZ marker.,"+            if (s->ncomponents) {
+                av_log(s->avctx, AV_LOG_ERROR, ""Duplicate SIZ\n"");
+                return AVERROR_INVALIDDATA;
+            }"
zmbvenc allocates a buffer for a picture with padding on all four sides,"+    prev_offset = FFALIGN(c->lrange * c->bypp, 16) + c->pstride * c->lrange;"
Fixes out of array access.,-            if (frame_end - frame < width + 3)
avcodec/vqavideo: Set video size.,"+   if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {"
avcodec/pictordec: Fix logic error.,"         ret = ff_set_dimensions(avctx, s->width, s->height);"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init().,"-    memset(&s->next_picture, 0, sizeof(s->next_picture));"
avformat/asfdec_o: Check size_bmp more fully.,"+    if (size_bmp > BMP_HEADER_SIZE &&
+        size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {"
Fixes: Assertion failure. ,"     if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||
         par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)
         flags_size = 2;"
Fixes out of array access,         sbr->m[0] = sbr->m[1];
avcodec/mpeg4videodec: Check read profile before setting it.,+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
"When a crafted IVR file, which claims a large ""len"" field in the header but does not contain sufficient backing data, is provided, the first type==4 loop would consume huge CPU resources, since there is no EOF check inside the loop.","+            for (j = 0; j < len; j++) {
+                if (avio_feof(pb))
+                    return AVERROR_INVALIDDATA;
                av_log(s, AV_LOG_DEBUG, ""%X"", avio_r8(pb));
+            }"
track_header in libavformat/vividas.c in FFmpeg 4.3.1 has an out-of-bounds write because of incorrect extradata packing.,"-            ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);"
The decode_init function in libavcodec/utvideodec.c in FFmpeg 2.8 through 3.4.2 allows remote attackers to cause a denial of service (Out of array read) via an AVI file with crafted dimensions within chroma subsampling data.,"+    if ((avctx->width  & ((1<<h_shift)-1)) ||
+        (avctx->height & ((1<<v_shift)-1))) {
+        avpriv_request_sample(avctx, ""Odd dimensions"");
+        return AVERROR_PATCHWELCOME;
+    }"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b1 + b5) >> 7)];
Fixes: out of array access. ,"            data     = av_malloc(end - start +
                                 AV_INPUT_BUFFER_PADDING_SIZE);"
Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg 2.4 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file.,-    av_assert0(decoded_buffer_size <= INT_MAX);
avcodec/utils: correct align value for interplay.,"+        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
+            w_align = 8;
+            h_align = 8;
+        }"
"Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",-            if (frame_end - frame < width + 3)
avcodec/dfa: Fix off by 1 error.,"             frame[0] = frame[1] =
             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);"
avcodec/x86/mpegvideodsp: Fix signedness bug in need_emu.,"+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
+                     (unsigned) iy >= height - h || height< h
+                     ;"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b4) >> 7)];
The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg 3.0 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.,ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));
"The allocate_buffers function in libavcodec/alac.c in FFmpeg before 2.7.2 does not initialize certain context data, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted Apple Lossless Audio Codec (ALAC) data.","+    for (ch = 0; ch < 2; ch++) {
+        alac->predict_error_buffer[ch]  = NULL;
+        alac->output_samples_buffer[ch] = NULL;
+        alac->extra_bits_buffer[ch]     = NULL;
+    }"
avformat/avidec: Fix infinite loop in avi_read_nikon().,-    while (avio_tell(s->pb) < end) {
"Heap-based buffer overflow in the xwd_decode_frame function in libavcodec/xwddec.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",-        } else if (pixdepth == 8) {
The only obvious solution is to prevent access to sensitive information.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
avformat/avidec: Remove ancient assert.,-        av_assert0(fabs(av_q2d(st2->time_base) - ast2->scale / (double)ast2->rate) < av_q2d(st2->time_base) * 0.00000001);
avformat/mms: Add missing chunksize check.,"+            if (chunksize > end - p) {
+                av_log(NULL, AV_LOG_ERROR,
+                    ""Corrupt stream (header chunksize %""PRId64"" is invalid)\n"",
+                    chunksize);
+                return AVERROR_INVALIDDATA;
+            }"
Fixes integer overflow.,"+    if (   pts < - PREROLL_TIME
+        || pts > (INT_MAX-3)/10000LL * ASF_INDEXED_INTERVAL - PREROLL_TIME) {
+        av_log(s, AV_LOG_ERROR, ""input pts %""PRId64"" is invalid\n"", pts);
+        return AVERROR(EINVAL);
+    }"
avformat/avidec: Check nb_streams in read_gab2_sub().,"             ff_read_packet(ast->sub_ctx, &ast->sub_pkt);"
avcodec/mpeg4videodec: Check read profile before setting it.,"+    *level   = get_bits(gb, 4);"
MSE: Fix moar mp4 parsing security bugs.,+  size_t sample_count = reader->box_size() - reader->pos();
Fixes out of array access. ,         sbr->kx[0] = sbr->kx[1];
Avoids leaving stale pointers. ,+        r->cbp_luma         = NULL;
The avi_read_seek function in libavformat/avidec.c in FFmpeg before 3.1.4 allows remote attackers to cause a denial of service (assert fault) via a crafted AVI file. ,-        av_assert0(fabs(av_q2d(st2->time_base) - ast2->scale / (double)ast2->rate) < av_q2d(st2->time_base) * 0.00000001);
zero initialize the rbsp buffer. ,+    rbsp->rbsp_buffer = av_mallocz(size);
avcodec/vc1_block: Fix mqaunt check for negative values,"             av_log(v->s.avctx, AV_LOG_ERROR,                   \
                    ""Overriding invalid mquant %d\n"", mquant);  \"
Fixes: Out of array access. ,             j = scantable[idx++];
avcodec/tiff: Check subsample & rps values more completely,+    if (s->rps <= 0 || s->rps % s->subsampling[1]) {
The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,             j = scantable[idx++];
"The VideoFramePool::PoolImpl::CreateFrame function in media/base/video_frame_pool.cc in Google Chrome before 47.0.2526.73 does not initialize memory for a video-frame data structure, which might allow remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact by leveraging improper interaction with the vp3_h_loop_filter_c function in libavcodec/vp3dsp.c in FFmpeg.","+    for (size_t i = 0; i < num_planes; ++i) {
+      memset(frame->data(i),
+             0,
+             VideoFrame::PlaneSize(frame->format(),
+                                   i,
+                                   frame->coded_size()).GetArea());
+    }"
Fixes out of array access.,-                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.6 allows remote attackers to cause a denial of service (out-of-bounds array read access) via crafted JPEG 2000 data.,"-        if ((s->ncomponents & 1) == 0)
-            s->cdef[s->ncomponents-1] = 0;"
avcodec/utvideodec: Check subsample factors.,"+    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &h_shift, &v_shift);"
Do not trust the counts.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_entry, static_cast<size_t>(count));"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions. ","+    ff_lzw_encode_init(s->lzw, s->buf, s->buf_size,"
"Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size.","+            if (c->chunk_size <= 0) { // end of stream or invalid chunk size
+                c->chunk_size = 0;
                 goto fail;
+            }"
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.","         if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size + 
		 AV_INPUT_BUFFER_PADDING_SIZE))) {"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->cbp_chroma       = NULL;
avcodec/utils: Clear dimensions in ff_get_buffer() on failure.,"+    if (ret < 0) {
         av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
+        frame->width = frame->height = 0;
+    }"
avcodec/idctdsp: Transmit studio_profile to init instead of using AVC odecContext profile.,"+    if (s->codec_id == AV_CODEC_ID_MPEG4)
+        s->idsp.mpeg4_studio_profile = s->studio_profile;"
"The jpeg2000_read_main_headers function in libavcodec/jpeg2000dec.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 does not enforce uniqueness of the SIZ marker in a JPEG 2000 image, which allows remote attackers to cause a denial of service (out-of-bounds heap-memory access) or possibly have unspecified other impact via a crafted image with two or more of these markers.","+            if (s->ncomponents) {
+                av_log(s->avctx, AV_LOG_ERROR, ""Duplicate SIZ\n"");
+                return AVERROR_INVALIDDATA;
+            }"
avcodec/h264_slice: Limit max_contexts when slice_context_count is initialized.,"+    h->max_contexts = FFMIN(h->max_contexts, nb_slices);"
"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS.",      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS.",			len = field[n].end - field[n].start;
Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file.,			as->s[as->length] = '\0';
> Undefined behavior / signed integer overflow in TAR parser.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.",        zip->entry_compressed_bytes_read += ENC_HEADER_SIZE;
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
"Using this malformed tar file with ""bsdtar -tf [input]"" will cause a signed integer overflow.","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS.","+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
The _ar_read_header function in archive_read_support_format_ar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds stack read) via a crafted ar file.,"                if (ar->strtab == NULL || number > ar->strtab_size) {
                        archive_set_error(&a->archive, EINVAL,
+                           ""Can't find long filename for GNU/SVR4 archive entry"");
                        archive_entry_copy_pathname(entry, filename);
                        ar_parse_common_header(ar, entry, h);
+                       return (ARCHIVE_FATAL);
                }"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
Issue #767: Buffer overflow printing a filename.,-		if (i > (sizeof(outbuff) - 20)) {
Fix integer overflow when computing location of volume descriptor,		skipsize -= iso9660->current_position;
Fuzzing with CRCs disabled revealed that a call to get_uncompressed_data() would sometimes fail to return at least 'minimum' bytes.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file.",	if (nrd < 0) {
Fuzzing with CRCs disabled revealed that a call to get_uncompressed_data() would sometimes fail to return at least 'minimum' bytes.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"	rab = __archive_read_ahead(a, 1U, &nrd);"
Fix typo in preprocessor macro in archive_read_format_zip_cleanup().,+#if HAVE_LZMA_H && HAVE_LIBLZMA
Resolves possible null-pointer dereference reported by OSS-Fuzz.,"-               else
-                       length = mbsnbytes(_p, n);"
==2650==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x607000000298 at pc 0x5586b16c5082 bp 0x7ffc3d24a950 sp 0x7ffc3d24a940.,			as->s[as->length] = '\0';
"read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",      filename[filename_size++] = '\0';
Heap-based buffer overflow in the zip_read_mac_metadata function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to execute arbitrary code via crafted entry-size values in a ZIP archive.,	metadata = malloc((size_t)rsrc->uncompressed_size);
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+			if ((size_t)bytes_avail > metadata_bytes)
+				bytes_avail = metadata_bytes;"
Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.,"      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size, &g_szalloc))"
A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Avoid a double-free when a window size of 0 is specified.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
Fix a possible heap-buffer-overflow in archive_string_append_from_wcs().,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
"Using this malformed tar file with ""bsdtar -tf [input]"" will cause a signed integer overflow.",        p->remaining = remaining;
7zip: fix crash when parsing certain archives.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
This is a simple NULL dereference leading to a crash.,"    new_window = realloc(rar->lzss.window, new_size);"
"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS.",			st = field[n].start + 1;
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
"When copying data into the allocated buffer, check the copy size against both the compressed entry size and uncompressed entry size.","+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Malformed OS X metadata entry: inconsistent size"");
+			return (ARCHIVE_FATAL);
+		}"
Limit write requests to at most INT_MAX.,"+	if (s > max_write)
+		s = max_write;"
"A RAR file with an invalid zero dictionary size was not being rejected, leading to a zero-sized allocation for the dictionary storage which was then overwritten during the dictionary initialization.","+      if (rar->dictionary_size == 0) {
+	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                          ""Invalid zero dictionary size"");
+	      return (ARCHIVE_FATAL);
+      }"
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Malformed OS X metadata entry: inconsistent size"");
+			return (ARCHIVE_FATAL);
+		}"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,-			numbers[argc++] = (unsigned long)mtree_atol(&p);
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,			outbuff[i] = '\0';
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
"While here, also reject headers with multiple EmptyFile, AntiFile, Name, or Attributes markers.","+			if (zip->entry_names != NULL)
+				return (-1);"
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,"			fprintf(f, ""%s"", outbuff);"
This is a simple NULL dereference leading to a crash.,			st = field[n].start + 1;
Stack out of bounds read in ar parser.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,"-               if (sc != NULL && (sc->flag & SCONV_FROM_UTF16))
-                       length = utf16nbytes(_p, n);"
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
The _ar_read_header function in archive_read_support_format_ar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds stack read) via a crafted ar file.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
This means that in some cases is not enough do few hours of fuzzing and believe that there aren?????t more bugs????? A crafted file causes a stack-buffer overflow write.,"			fprintf(f, ""%s"", outbuff);"
"When sanity-checking the size of an OS X metadata entry, abort this entry if either the compressed or uncompressed size is larger than 4MB.","+	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    ""Mac metadata is too large: %jd > 4M bytes"",
+		    (intmax_t)rsrc->compressed_size);
+		return (ARCHIVE_WARN);
+	}"
Fix a possible heap-buffer-overflow in archive_string_append_from_wcs().,			as->s[as->length] = '\0';
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
Avoid a read off-by-one error for UTF16 names in RAR archives.,-      filename[filename_size++] = '\0';
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
"While pruning trailing text from ar filenames, we did not check for an empty filename.","+       if (p < filename) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+                   ""Found entry with empty filename"");
+               return (ARCHIVE_FATAL);
+       }"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
Stack out of bounds read in ar parser.,"                if (ar->strtab == NULL || number > ar->strtab_size) {
                        archive_set_error(&a->archive, EINVAL,
+                           ""Can't find long filename for GNU/SVR4 archive entry"");
                        archive_entry_copy_pathname(entry, filename);
                        ar_parse_common_header(ar, entry, h);
+                       return (ARCHIVE_FATAL);
                }"
"The safe_fprintf function attempts to ensure clean output for an arbitrary sequence of bytes by doing a trial conversion of the multibyte characters to wide characters -- if the resulting wide character is printable then we pass through the corresponding bytes unaltered, otherwise, we convert them to C-style ASCII escapes.",+		if (i > (sizeof(outbuff) - 128)) {
Resolves possible null-pointer dereference reported by OSS-Fuzz.,"-               if (sc != NULL && (sc->flag & SCONV_FROM_UTF16))
-                       length = utf16nbytes(_p, n);"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,			zip->entry_names = malloc(ll);
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
This is a simple NULL dereference leading to a crash.,			len = field[n].end - field[n].start;
Signed integer overflows are undefined in C.,        p->remaining = remaining;
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.","        p = __archive_read_ahead(a, ENC_HEADER_SIZE, NULL);"
==13144==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000038800 at pc 0x7fb1c808f650 bp 0x7ffdd1b40990 sp 0x7ffdd1b40988,	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,			zip->entry_names = malloc(ll);
\307q\005\bo\002\244\201\350\003\350\003libarchive/archive_read_support_format_tar.c:612:10: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type 'long'.,        p->remaining = remaining;
Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.,"+      if (rar->dictionary_size == 0) {
+	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                          ""Invalid zero dictionary size"");
+	      return (ARCHIVE_FATAL);
+      }"
This means that in some cases is not enough do few hours of fuzzing and believe that there aren?????t more bugs????? A crafted file causes a stack-buffer overflow write.,			outbuff[i] = '\0';
"This means that if you specify an invalid content length, it will just reprint the same data over and over and over again until it hits the desired length.","+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
"Issue #582: reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks.","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
The archive_read_format_cpio_read_header function in archive_read_support_format_cpio.c in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a CPIO archive with a large symlink.,"h = __archive_read_ahead(a,
			(size_t)cpio->entry_bytes_remaining, NULL);"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
array subscript is above array bounds,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
Limit write requests to at most INT_MAX.,+	const size_t max_write = INT_MAX;
==2650==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x607000000298 at pc 0x5586b16c5082 bp 0x7ffc3d24a950 sp 0x7ffc3d24a940.,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    ""Mac metadata is too large: %jd > 4M bytes"",
+		    (intmax_t)rsrc->compressed_size);
+		return (ARCHIVE_WARN);
+	}"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","	rab = __archive_read_ahead(a, 1U, &nrd);"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
array subscript is above array bounds,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
"libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c.",	while (char_cnt-- > 0) {
consume data once read.,"+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,			outbuff[i] = '\0';
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,-		if (i > (sizeof(outbuff) - 20)) {
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.",	if (nrd < 0) {
Crash Type: Heap-buffer-overflow READ {*} Crash Address: 0x6140000009f8 Crash State: read_header archive_read_format_rar_read_header _archive_read_next_header2 Sanitizer: address (ASAN) Recommended Security Severity: Medium Package: libarchive13 Version: 3.2.2-3.1 $ valgrind --quiet -- bsdtar -xf oob.rar ==1880== Invalid read of size 1 ==1880== at 0x4832FF0: memcpy (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B5E0: memcpy (string3.h:53) ==1880== by 0x489B5E0: read_header (archive_read_support_format_rar.c:1577) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== Address 0x6ca726a is 0 bytes after a block of size 98 alloc'd ==1880== at 0x482E1FC: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x4830520: realloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B451: read_header (archive_read_support_format_rar.c:1423) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== bsdtar: Unknown file attributes from RAR file's host OS bsdtar: Error exit delayed from previous errors.,      filename[filename_size++] = '\0';
"When we grow the archive_string buffer, we have to make sure it fits at least one maximum-sized multibyte character in the current locale and the null character.","			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
Avoid a double-free when a window size of 0 is specified.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
7zip: fix crash when parsing certain archives.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"A simple cast suffices to fix this since the base location is always 32 bits for ISO, so multiplying by the sector size will never overflow a 64-bit integer.",+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Fix integer overflow when computing location of volume descriptor.,		skipsize -= iso9660->current_position;
archive_strncat_l(): allocate and do not convert if length == 0.,-       if (length == 0) {
Avoid a read off-by-one error for UTF16 names in RAR archives.,      filename[filename_size++] = '\0';
Crash Type: Heap-buffer-overflow READ {*},      filename[filename_size++] = '\0';
==27792==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010800 at pc 0x6169dd bp 0x7ffff41b2ef0 sp 0x7ffff41b2ee0.,        zip->entry_compressed_bytes_read += ENC_HEADER_SIZE;
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->antiBools != NULL)
+				return (-1);"
> Undefined behavior / signed integer overflow in TAR parser.,        p->remaining = remaining;
Crash Type: Heap-buffer-overflow READ {*} Crash Address: 0x6140000009f8 Crash State: read_header archive_read_format_rar_read_header _archive_read_next_header2 Sanitizer: address (ASAN) Recommended Security Severity: Medium Package: libarchive13 Version: 3.2.2-3.1 $ valgrind --quiet -- bsdtar -xf oob.rar ==1880== Invalid read of size 1 ==1880== at 0x4832FF0: memcpy (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B5E0: memcpy (string3.h:53) ==1880== by 0x489B5E0: read_header (archive_read_support_format_rar.c:1577) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== Address 0x6ca726a is 0 bytes after a block of size 98 alloc'd ==1880== at 0x482E1FC: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x4830520: realloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B451: read_header (archive_read_support_format_rar.c:1423) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== bsdtar: Unknown file attributes from RAR file's host OS bsdtar: Error exit delayed from previous errors.,-      filename[filename_size++] = '\0';
"A simple cast suffices to fix this since the base location is always 32 bits for ISO, so multiplying by the sector size will never overflow a 64-bit integer.",-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,			zip->entry_names = malloc(ll);
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,"-               else
-                       length = mbsnbytes(_p, n);"
Do something sensible for empty strings to make fuzzers happy.,"+	if (char_cnt == 0)
+		return (0);"
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,"			fprintf(f, ""%s"", outbuff);"
Memory leak when decoding LZMA #1165.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
Avoid a double-free when a window size of 0 is specified.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
"libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service). This attack appears to be exploitable via the victim opening a specially crafted 7zip file.",*buff = zip->uncompressed_buffer_pointer;
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->emptyStreamBools != NULL)
+				return (-1);"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
==27792==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010800 at pc 0x6169dd bp 0x7ffff41b2ef0 sp 0x7ffff41b2ee0.,-       zip->entry_bytes_remaining -= ENC_HEADER_SIZE;
Fix libarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds.,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
7zip: fix crash when parsing certain archives.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"Integer overflow in the read_SubStreamsInfo function in archive_read_support_format_7zip.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a 7zip file with a large number of substreams, which triggers a heap-based buffer overflow.","+			if (unpack_streams > SIZE_MAX - UMAX_ENTRY) {
+				return (-1);
+			}"
Signed integer overflows are undefined in C.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.",-       zip->entry_bytes_remaining -= ENC_HEADER_SIZE;
==15753==ERROR: LeakSanitizer: detected memory leaks.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.","	rab = __archive_read_ahead(a, 1U, &nrd);"
Signed integer overflows are undefined in C.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
7zip: fix crash when parsing certain archives.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
This prevents a certain common programming error (passing -1 to write) from leading to other problems deeper in the library.,+	const size_t max_write = INT_MAX;
Stop this by checking that the length is not zero before beginning the switch statement.,"+			if (len == 0) {
+				ret = ARCHIVE_WARN;
+				continue;
+			}"
detected memory leaks,-#if HAVA_LZMA_H && HAVE_LIBLZMA
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,-		if (i > (sizeof(outbuff) - 20)) {
Fail if entry is too small for encryption header.,"+       if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)
+           && zip->entry_bytes_remaining < ENC_HEADER_SIZE) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                   ""Truncated Zip encrypted body: only %jd bytes available"",
+                   (intmax_t)zip->entry_bytes_remaining);
+               return (ARCHIVE_FATAL);
+       }"
==13144==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000038800 at pc 0x7fb1c808f650 bp 0x7ffdd1b40990 sp 0x7ffdd1b40988,	while (char_cnt-- > 0) {
"Crash analysis : In archive_string_append_from_wcs() (archive_string.c), upon execution of the crashing input (crash-file): archive_string_append_from_wcs(){ .... // Allocated heap memory for as->s is 72 bytes in range (0x607000000250,0x607000000298) p = as->s + as->length; ... while (*w != L'\0' && len > 0) { ... #if HAVE_WCRTOMB n = wcrtomb(p, *w++, &shift_state); // p = 0x611000000628 --> 0x00, wcrtomb() returns 3, n = 3 #else n = wctomb(p, *w++); #endif if (n == -1) { if (errno == EILSEQ) { ... } else p += n; // p = 0x611000000628 --> 0x00 len--; } as->length = p - as->s; // as->length = 72. as->s[as->length] = '\0'; // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.","			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
"but only a few hundred bytes of data, causes a quasi-infinite loop.",		*bsz = 0U;
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,-		if (i > (sizeof(outbuff) - 20)) {
This is a simple NULL dereference leading to a crash.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
"libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file.",		*bsz = 0U;
warc: consume data once read.,"+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
Avoid a read off-by-one error for UTF16 names in RAR archives.,+      filename[filename_size] = '\0';
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,-       if (_p != NULL && n > 0) {
"While here, also reject headers with multiple EmptyFile, AntiFile, Name, or Attributes markers.","+			if (h->attrBools != NULL)
+				return (-1);"
"The first (patch 1) is a double-free via a realloc(area, 0).","  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
"read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",-      filename[filename_size++] = '\0';
libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-416: Use After Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c that can result in Crash/DoS - it is unknown if RCE is possible.,"  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
as->s[as->length] = '\0';    // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.,			as->s[as->length] = '\0';
"but only a few hundred bytes of data, causes a quasi-infinite loop.","	rab = __archive_read_ahead(a, 1U, &nrd);"
ibarchive: heap-based buffer overflow in xml_data (archive_read_support_format_xar.c).,	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
Skip 0-length ACL fields.,"+			if (len == 0) {
+				ret = ARCHIVE_WARN;
+				continue;
+			}"
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->emptyFileBools != NULL)
+				return (-1);"
Signed integer overflows are undefined in C.,        p->remaining = remaining;
"Issue #582: reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks.","+       if (remaining < 0 || offset < 0) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, ""Malformed sparse map data"");
+               return (ARCHIVE_FATAL);
+       }"
"That would check the new file name against the old file name, and if they didn't match up it would free the ppmd7 buffer and allocate a new one.","+  else if (rar->filename_must_match)
+  {
+    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+      ""Mismatch of file parts split across multi-volume archive"");
+    return (ARCHIVE_FATAL);
+  }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,			len = field[n].end - field[n].start;
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file.,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"    new_window = realloc(rar->lzss.window, new_size);"
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,			outbuff[i] = '\0';
Reject cpio symlinks that exceed 1MB.,"+		if (cpio->entry_bytes_remaining > 1024 * 1024) {
+			archive_set_error(&a->archive, ENOMEM,
+			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
+			return (ARCHIVE_FATAL);
+		}"
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
"libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service).","-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"While here, change a number of ar format issues from WARN to FATAL.","+       if (p < filename) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+                   ""Found entry with empty filename"");
+               return (ARCHIVE_FATAL);
+       }"
Do something sensible for empty strings to make fuzzers happy.,"+	if (char_cnt == 0)
+		return (0);"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,"			fprintf(f, ""%s"", outbuff);"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,			zip->entry_names = malloc(ll);
Resolves possible null-pointer dereference reported by OSS-Fuzz.,-       if (_p != NULL && n > 0) {
\307q\005\bo\002\244\201\350\003\350\003libarchive/archive_read_support_format_tar.c:612:10: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type 'long'.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,+			numbers[argc++] = (unsigned long)mtree_atol(&p);
bsdtar in libarchive before 3.2.0 allows remote attackers to cause a denial of service (infinite loop) via an ISO with a directory that is a member of itself.,-	file->offset = iso9660->logical_block_size * (uint64_t)location;
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,			st = field[n].start + 1;
Issue 403: Buffer underflow parsing 'ar' header.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.",		*bsz = 0U;
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.",	if (nrd < 0) {
Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.,		skipsize -= iso9660->current_position;
"bsdtar: An error in archive_string_append_from_wcs() (archive_string.c) triggers an out-of-bounds write in heap memory that results into a crash, via a specially crafted archive file.",			as->s[as->length] = '\0';
"reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","    new_window = realloc(rar->lzss.window, new_size);"
as->s[as->length] = '\0'; // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.,"			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,-       if (length == 0) {
This prevents a certain common programming error (passing -1 to write) from leading to other problems deeper in the library.,"+	if (s > max_write)
+		s = max_write;"
Integer overflow in the archive_read_format_tar_skip function in archive_read_support_format_tar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (crash) via a crafted tar file.,        p->remaining = remaining;
Fixes a heap buffer overflow reported in Secunia SA74169.,	lha->compsize -= extdsize - 2;
Resolves possible null-pointer dereference reported by OSS-Fuzz.,-       if (length == 0) {
A race condition in chown_one() of systemd allows an attacker to cause systemd to set arbitrary permissions on arbitrary files.,"-        if (name)
-                r = fchownat(fd, name, uid, gid, AT_SYMLINK_NOFOLLOW);"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
So let's follow suit and only accept numbers in decimal notation.,"+        r = safe_atou32_full(s, 10, &uid);"
don't accept arbitrarily sized journal data fields.,"+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                if (r == 0) 
+                        break;"
journal-remote: set a limit on the number of fields in a message.,"+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                r = read_line(f, LONG_LINE_MAX, &line);"
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,+        unit_add_to_gc_queue(u);
"In systemd 223 through 235, a remote DNS server can respond with a custom crafted DNS NSEC resource record to trigger an infinite loop in the dns_packet_read_type_window() function of the 'systemd-resolved' service and cause a DoS of the affected service. ","        if (p->question->n_keys != 1)
                return 0;"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
journal: do not remove multiple spaces after identifier in syslog message.,"+        e += strspn(p + e, WHITESPACE);"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g.","+                r = read_line(f, LONG_LINE_MAX, &line);"
let's rework the recursive logic to use O_PATH.,"+        xsprintf(procfs_path, ""/proc/self/fd/%i"", fd);"
journal: do not remove multiple spaces after identifier in syslog message.,"+        if (p[e] != '\0' && strchr(WHITESPACE, p[e]))
+                e++;"
"When executing the udevadm trigger command, a memory leak may occur.","         r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);"
nss-mymachines: do not allow overlong machine names.,"+        if (e - p > HOST_NAME_MAX - 1) 
+                goto not_found;"
systemd-resolved through 233 allows remote attackers to cause a denial of service (daemon crash) via a crafted DNS response with an empty question section.,"        if (p->question->n_keys != 1)
                return 0;"
Units that failed to load were never cleaned up.,+        unit_add_to_gc_queue(u);
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,         unit_add_to_dbus_queue(u);
resolved: fix loop on packets with pseudo dns types.,"+                for (; bitmask; bit++, bitmask >>= 1)"
"A malicious DNS server can exploit this via a response with a specially crafted TCP payload to trick systemd-resolved into allocating a buffer that's too small, and subsequently write arbitrary data beyond the end of it.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
"This behaviour is definitely not expected by users, since tools generally only accept decimal numbers (e.g.","+        r = safe_atou32_full(s, 10, &uid);"
journald: don't accept arbitrarily sized journal data fields.,"+                        if (l > DATA_SIZE_MAX) {
+                                log_debug(""Received binary data block too large, ignoring."");
+                                break;
+                        }"
"Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.",-#define ENTRY_SIZE_MAX (1024*1024*32)
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","-                        if (r == -E2BIG)
-                                log_warning_errno(r, ""Entry is too above maximum of %u, aborting connection %p."","
nss-mymachines: do not allow overlong machine names.,"+        if (e - p > HOST_NAME_MAX - 1)
+                goto not_found;"
journal-remote: set a limit on the number of fields in a message.,"+                        if (r == -ENOBUFS)
+                                log_warning_errno(r, ""Entry is above the maximum of %u, aborting connection %p."",
                                                  DATA_SIZE_MAX, connection);"
"systemd 37-1 does not properly handle non-existent services, which causes a denial of service (failure of login procedure).",+        unit_add_to_gc_queue(u);
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
garbage collect units with load error.,+        unit_add_to_gc_queue(u);
So it seems that it's not uncommon for dhcp6-client to get the length wrong.,"+        if (*buflen < offsetof(DHCP6Option, data) + len)"
A race condition in chown_one() of systemd allows an attacker to cause systemd to set arbitrary permissions on arbitrary files.,"-                if (!S_ISLNK(st->st_mode))
-                        r = fchmodat(fd, name, st->st_mode, 0);"
A stack-based buffer overflow vulnerability was found in getpwnam()/getgrnam() functions of NSS module nss-mymachines provided by systemd.,"        r = parse_uid(e + 1, &uid);"
basic/user-util: always use base 10 for user/group numbers.,         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
bus_open leak sd_event_source when udevadm trigger.,+        b->io_event_source = sd_event_source_unref(b->io_event_source);
An out-of-bounds read when parsing a crafted syslog message that could lead to information disclosure.,         *buf = p + e;
journald: don't accept arbitrarily sized journal data fields.,+#define DATA_SIZE_MAX (1024*1024*64)
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        if (r == -ENOBUFS)
+                                log_warning_errno(r, ""Entry is above the maximum of %u, aborting connection %p."",
                                                  DATA_SIZE_MAX, connection);"
"An integer overflow, leading to heap-based buffer overflow flaw was found in the way journald functionality of systemd, a system and service manager, processed native messages.","+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
So let's follow suit and only accept numbers in decimal notation.,         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
journal: do not remove multiple spaces after identifier in syslog message.,"-        e += strspn(p + e, WHITESPACE);"
An out-of-bounds read when parsing a crafted syslog message that could lead to information disclosure.,"-        e += strspn(p + e, WHITESPACE);"
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,-                        return -errno;
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,+        unit_add_to_gc_queue(u);
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g.","+                if (r < 0)
+                        return log_error_errno(r, ""Failed to read serialization line: %m"");"
This can lead to a denial of service attack or arbitrary code execution in some cases.,"-                        if (r == -E2BIG)
-                                log_warning_errno(r, ""Entry is too above maximum of %u, aborting connection %p."","
"An integer overflow, leading to heap-based buffer overflow flaw was found in the way journald functionality of systemd, a system and service manager, processed native messages.",-#define ENTRY_SIZE_MAX (1024*1024*32)
Stack-based buffer overflow in the getpwnam and getgrnam functions of the NSS module nss-mymachines in systemd.,"        r = parse_uid(e + 1, &uid);"
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,"-               if (!fgets(line, sizeof(line), f)) {"
dhcp6 packet size calculation fixes.,"+        if (*buflen < offsetof(DHCP6Option, data) + len)"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                if (r < 0)
+                        return log_error_errno(r, ""Failed to read serialization line: %m"");"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
"This behaviour is definitely not expected by users, since tools generally only accept decimal numbers (e.g.",         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
resolved: simplify alloc size calculation.,"+        a = MAX(mtu, DNS_PACKET_HEADER_SIZE);"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
A buffer overflow vulnerability in the dhcp6 client of systemd allows a malicious dhcp6 server to overwrite heap memory in systemd-networkd.,        *buflen -= sizeof(DHCP6Option);
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,"-                        if (feof(f))
-                                return 0;"
fix loop on packets with pseudo dns types.,"+        if (!p->question)
+                return 0;"
"Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.","+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"A malicious DNS server can exploit this via a response with a specially crafted TCP payload to trick systemd-resolved into allocating a buffer that's too small, and subsequently write arbitrary data beyond the end of it.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
journald: don't accept arbitrarily sized journal data fields.,"+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
basic/user-util: always use base 10 for user/group numbers.,"+        r = safe_atou32_full(s, 10, &uid);"
The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().,-            u_int addr_size = 4;
which could cause an out-of-bounds read when decoding an invalid packet.,         optlen = EXTRACT_16BITS(tlv + 2);
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
CVE-2017-13025/IPv6 mobility: Add a bounds check before fetching data,+			ND_TCHECK_128BITS(&bp[i+2]);
"In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo), put it right.",-                if(len < 1)
Fix some bounds checks.,+	ND_TCHECK(*k);
In aodv_extension() do a bounds check on the extension header before we look at it.,+	ND_TCHECK(*ep);
This fixes a buffer over-read discovered by Kamil Frankowicz.,"-	ND_TCHECK2(dp[0], 0);"
This fixes a buffer over-read discovered by Kamil Frankowicz.,-					ND_TCHECK(dp[0]);
This fixes a buffer over-read discovered by Yannick Formaggio.,-	if (len < sizeof(*prep)) {
Do bounds checking when comparing strings.,"+	if (!ND_TTEST2(*str2, tl1)) {
+		return 0;
+	}"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,-        while (len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+			if (optlen == 6)
 				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_MP).,"                 ND_TCHECK2(opt[i+2], cap_len);"
"If it returns a negative number, it hasn't necessarily filled in buf, so just return immediately; this is similar to the IPv4 code path, wherein we just return a negative number, and print nothing, on an error.","+        if (plenbytes < 0)
+            return plenbytes;"
The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_print().," 			if (dp->icmp6_data16[1] & 0xc0)
 				ND_PRINT((ndo,"" ""));"
fix bounds checks for UNI.,"+                    if(subobj_len < 4 || subobj_len > total_subobj_len)
                         goto invalid;"
fix bounds checks for UNI,"+                    if (total_subobj_len < 4)
+                        goto invalid;"
"It can fail, so make sure it doesn't before comparing its result with the password.","+	if (strcmp(user_password, crypt_password) != 0)"
CVE-2017-13037/IP: Add bounds checks when printing time stamp options.,+	ND_TCHECK(cp[2]);
Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         type = *(tptr);
Check before fetching the length from the included packet's IPv4 header.,+		ND_TCHECK_16BITS(&ip->ip_len);
"clean up some other bounds checks,","-            if (msg_tlen < 4)
-                goto trunc;"
CVE-2017-12896/ISAKMP: Do bounds checks in isakmp_rfc3948_print().,+	ND_TCHECK(bp[0]);
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \0.,+	len = strlen (ptr);
The Apple PKTAP parser in tcpdump before 4.9.2 has a buffer over-read in print-pktap.c:pktap_if_print().,"-			hdrlen += printer(ndo, h, p);"
The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().,"-	else if (l_strnstart(""END"", 4, (const char *)bp, length))"
tcpdump.org tcpdump 4.9.2 is affected by: CWE-126: Buffer Over-read.,"         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));"
In aodv_extension() do a bounds check on the extension header before we look at it., 	switch (ep->type) {
This fixes a buffer over-read,"                     ND_PRINT((ndo, ""\n\t\tRestart Flags: [%s], Restart Time %us"","
Add length checks.,"+	ND_TCHECK2(*p, CHDLC_HDRLEN);"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:nfs_printfh().,"-		strncpy(temp, sfsname, NFSX_V3FHMAX);"
"While we're at it, clean up some other bounds checks, so we check that we have a complete IPv4 message header if it's IPv4 and a complete IPv6 message header if it's IPv6.","+            ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
"Check before fetching the ""access"" part of the NFSv3 ACCESS results.",+				ND_TCHECK(dp[4]);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-	if (!ND_TTEST2(*ar_tpa(ap), PROTO_LEN(ap))) {"
CVE-2017-12899/DECnet: Fix bounds checking.,+	    ND_TCHECK(rhp->rh_short.sh_flags);
Prevent a possible buffer overread in chdlc_print() and replace the custom check in chdlc_if_print() with a standard check in chdlc_print() so that the latter certainly does not over-read even when reached via juniper_chdlc_print()., 	proto = EXTRACT_16BITS(&p[2]);
do sanity checks on PHB header length before allocating memory.,"+	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
+            (total_length > BT_SHB_INSANE_MAX)) {"
Don't crash if crypt() fails., 		return -1;
"Include a test for the ""check before fetching the ""access"" part..."" fix, using the capture supplied by the reporter(s).",-				ND_TCHECK(dp[2]);
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.","+            if (subl == 0)
+                break;"
The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,-				if (chars_processed >= data_size) {
Add more bounds checks.,"+            ND_TCHECK2(p[0], 2);"
This fixes a buffer over-read,"             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_start),"
Add two bounds checks before fetching data, 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
This fixes a buffer over-read,"-	while (tp->e_nxt)
-		if (tp->e_addr0 == i &&
-		    tp->e_addr1 == j &&
-		    tp->e_addr2 == k &&
-		    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""NUL "", 4, (const char *)bp, length))"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_multicast_vpn().,"-            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);"
Calculate the reply payload length in a local variable.,+	replylen = 0;
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.",+	ND_TCHECK(*idp);
The Babel parser in tcpdump before 4.9.3 has a buffer over-read in print-babel.c:babel_print_v2().,-                if(len < 1)
The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().,         vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,"             ND_PRINT((ndo, ""\n\t    IOS version: %u.%u, EIGRP version %u.%u"",
                    tlv_ptr.eigrp_tlv_sw_version->ios_major,"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply()., 	astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.,"+	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
+            (total_length > BT_SHB_INSANE_MAX)) {"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio,"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.", 			while (cp < ep && cp < ep2) {
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
Buffer Over-read.,"         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));"
(for 4.9.3) CVE-2018-14882/ICMP6 RPL: Add a missing bounds check.,+                ND_TCHECK(opt->rpl_dio_len);
The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_nodeinfo_print()., 			if (cp[0] == ep - cp - 1) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 	ptr = cp[2] - 1;
"The loop can be executed more than once (that's kinda the whole point of a loop), so the check has to be made each time through the loop, not just once before the loop is executed.","+		    ND_TCHECK2(tptr[0], 3);"
Clean up bounds checking.,-		if (j * sizeof(*ni) != length - 4)
CVE-2017-12996/PIMv2: Make sure PIM TLVs have the right length.,+				if (olen != 4) {
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,             bit_length = tlv_ptr.eigrp_tlv_ip_ext->plen;
Check that the entire ar_stat field is present in the capture.,+	ND_TCHECK(dp[0]);
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""RPY "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP RPY""));"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.",           len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;
(for 4.9.3) CVE-2018-14465/RSVP: Add a missing bounds check in rsvp_obj_print().,+                ND_TCHECK_32BITS(obj_tptr);
The arguments to memcpy() were completely wrong.,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
CVE-2017-16808/AoE: Add a missing bounds check.,"+		ND_TCHECK_LEN(cp, MAC_ADDR_LEN);"
In rx_cache_insert() and rx_cache_find() properly read the serviceId field of the rx_header structure as a 16-bit integer. ,+		    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&
This fixes a buffer over-read discovered by Kim Gwan Yeong., 		ni6 = (const struct icmp6_nodeinfo *)dp;
CVE-2017-13025/IPv6 mobility: Add a bounds check before fetching data.,+			ND_TCHECK_128BITS(&bp[i+2]);
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",             l2info->proto = EXTRACT_16BITS(p);
This fixes a buffer over-read,"             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_start),"
The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().,-            if (!saw_digit)
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""SEQ "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP SEQ""));"
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-					ND_PRINT((ndo, "" ?0x%04x?"", EXTRACT_16BITS(bp+2)));"
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""ERR "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ERR""));"
Add length checks.,"+                if (length < 2)
+                    goto trunc;"
"In aoev1_reserve_print() check bounds, before trying to print an Ethernet address."," 		ND_PRINT(""\n\tEthernet Address %u: %s"", i, etheraddr_string(ndo, cp));"
Fix processing of TIM IE.,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
"When bgp_attr_print() tried to decode the variable-length nexthop value for the NSAP VPN case, it did not check that the declared length is good to interpret the value as a mapped IPv4 or IPv6 address.",-                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)
Add an intermediate bounds check to make it safe.,+		if (caplen < hdrlen + 1) {
CVE-2017-13049/Rx: add a missing bounds check for Ubik.,+			ND_TCHECK_32BITS(bp);
The VRRP parser in tcpdump before 4.9.3 has a buffer over-read in print-vrrp.c:vrrp_print().," 				ND_PRINT((ndo, "", (bad vrrp cksum %x)"",
 					EXTRACT_16BITS(&bp[6])));"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		    i -= sizeof(*ni), ++ni) {"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);
CVE-2017-13022/IP: Add bounds checks to ip_printroute().,"+			if (ip_printroute(ndo, cp, option_len) == -1)
+				goto trunc;"
The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print().," 		ND_PRINT((ndo, ""\n\t      Area address (length: %u): %s"","
Add more bounds checks.,"+        ND_TCHECK2(p[0], 3);"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().," 				ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64,
 						EXTRACT_32BITS(&dp[4]),
 						EXTRACT_32BITS(&dp[2]),
 						EXTRACT_64BITS(&dp[0])));"
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,             bit_length = tlv_ptr.eigrp_tlv_ip_int->plen;
This fixes a buffer over-read,-		for (ni = rp->rip6_nets; i >= sizeof(*ni);
CVE-2017-13023/IPv6 mobility: Add a bounds check before fetching data.,+			ND_TCHECK_16BITS(&bp[i+2]);
Clean up other length tests while we're at it.,"-   for (i=0; *data && i < length ; i++, data++)"
"Move a return to make the code a bit cleaner (i.e., make it more obvious that if we don't have enough of the PGM header, we just print the source and destination IP addresses, mark it as incomplete PGM, and don't try to look at the PGM header).",-			return;
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-12993/Juniper: Add more bounds checks.,+        ND_TCHECK(*gh);
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"")""));"
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.",+	ND_TCHECK(*idp);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options"," 			else
+				ND_PRINT((ndo, "" [optlen != 6]""));"
CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+			nhdr.caplen = caplen;
The OSPFv3 parser in tcpdump before 4.9.3 has a buffer over-read in print-ospf6.c:ospf6_print_lshdr().,-	ND_TCHECK(lshp->ls_type);
"could over-read the input buffer,","         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,                     subobj_len  = EXTRACT_16BITS(obj_tptr);
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+        if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
+          goto trunc;"
This fixes a buffer over-read,"+   for (i=0; i < length && *data; i++, data++)
        ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 	    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);
The PPP parser in tcpdump before 4.9.2 has a buffer over-read in print-ppp.c:handle_mlppp().,"     ND_PRINT((ndo, ""seq 0x%03x, Flags [%s], length %u"",
            (EXTRACT_16BITS(p))&0x0fff, 
            bittok2str(ppp_ml_flag_values, ""none"", *p & 0xc0),"
fix VPN route target bounds checks,"-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print()., 		len -= advance;
"The IKEv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c, several functions.",-	ND_TCHECK(*ext);
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",         extracted_ethertype = EXTRACT_16BITS(p);
The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_id().,"         snprintf(pos, sizeof(id) - (pos - id), ""%02x"", *cp++);"
CVE-2017-13005/NFS: Add two bounds checks before fetching data.,"+	if (!ND_TTEST(rp->rm_call.cb_proc))
+		return (0);"
The IKEv1 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c:ikev1_id_print().,"-			if (len < 20)
-				ND_PRINT((ndo,"" len=%d [bad: < 20]"", len));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
"This is what BIND 9.11.0-P2 does; it not only detects pointers that loop, as ""point backwards"" means ""point before anything we\'ve processed so far, including what we\'re processing right now"", so the pointer can\'t point to itself (as that\'s what we\'re processing right now).",+				if (offset >= max_offset) {
Rearrange those steps the correct way around.,-            bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
Use ND_TTEST() rather than comparing against ndo->ndo_snapend ourselves; it's easy to get the tests wrong.,"-    if (*pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" status=(""));"
Add a missing bounds check in icmp_print().,+				ND_TCHECK_16BITS(&dp->icmp_cksum);
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""ERR "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ERR""));"
The IP parser in tcpdump before 4.9.2 has a buffer over-read in print-ip.c:ip_printts()., 	ptr = cp[2] - 1;
CVE-2017-13014/White Board: Do more bounds checks.,"+	if (len < sizeof(*prep) || !ND_TTEST(*prep))
 		return (-1);"
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \\0.,+	len = strlen (ptr);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         len = EXTRACT_16BITS(tptr+2);
CVE-2017-12993/Juniper: Add more bounds checks.,+        ND_TCHECK(*ih);
CVE-2017-13022/IP: Add bounds checks to ip_printroute().,"+		ND_TCHECK2(cp[len], 4);"
Clean up bounds checking.,"-		if (j == 1
-		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
-		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
-			ND_PRINT((ndo, "" ripng-req dump""));
-			break;"
Ryan Ackroyd had independently identified this buffer over-read later by means of fuzzing and provided the packet capture file for the test., 			if (optlen > 2) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",                     af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;
The total length of the OID is the OID length plus the length of the OID length itself.,"+        if (tlen < 1U + oid_len) {
             return 0;
         }"
This fixes a buffer over-read,                         for (i = 0; i < tptr[1] * as_size; i += as_size) {
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check","         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
"It can fail, so make sure it doesn't before comparing its result with the password.",+	if (crypt_password == NULL)
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_attr_print() (MP_REACH_NLRI).,-                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)
"Add a length check to fix that and remove a useless boundary check from a loop because the boundary is tested for the full length of ""V"" before the switch block.","+            if (subl == 0)
+                break;"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
This caused an out-of-bounds read and could cause a write.,"-	if (ptr[strlen(ptr) - 1] == '\n')
-		ptr[strlen(ptr) - 1] = '\0';"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,-					ND_TCHECK(dp[0]);
CVE-2017-13002/AODV: Add some missing bounds checks.,+	ND_TCHECK(*ep);
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;","-			hdrlen += printer(ndo, h, p);"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"")""));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_MCID_MIN_LEN);"
"Also, put the buffer on the stack; no reason to make it static.",-		static char temp[NFSX_V3FHMAX+1];
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""RPY "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP RPY""));"
"Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst (if the request had extra stuff at the end, so that the variable is non-zero).",-			plen+= strlen(d->description);
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-	i = min(length, amt);"
offset has already been advanced to point to the bitmap; we shouldn't add the amount to advance again.,"-			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);"
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","+	as_printf(ndo, asbuf, sizeof(asbuf), EXTRACT_32BITS(pptr + 1));"
CVE-2017-12993/Juniper: Add more bounds checks.,"+        ND_TCHECK2(p[0], 2);"
CVE-2017-12985/IPv6: Check for print routines returning -1 when running past the end.,"                 if (in_cksum(vec, 1)) {"
CVE-2017-13690/IKEv2: Fix some bounds checks.,+	ND_TCHECK(*idp);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
This fixes a buffer overflow,"-                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
-                                     sepstr, lp->s);"
"The bounds check in esis_print() tested one pointer at the beginning of a loop that incremented another, make the trivial fix.",-                    ND_TCHECK(*pptr);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-	ND_TCHECK(*ext);
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-					unsigned_relts_print(ndo, *(bp+1));"
Rearrange those steps the correct way around.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                 ND_PRINT((ndo, "" FASTv%u"",
                        EAP_TTLS_VERSION(*(tptr + 5))))"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""ERR "", 4, (const char *)bp, length))"
This fixes a buffer over-read,-	amt = ndo->ndo_snapend - dat;
The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().,-    if (*bp != '\r')
CVE-2017-13690/IKEv2: Fix some bounds checks.,"+	ND_TCHECK2(*ext, sizeof(a));"
"The White Board protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-wb.c:wb_prep(), several functions.", 	n = EXTRACT_32BITS(&prep->pp_n);
Rearrange those steps the correct way around.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
"Also, make the buffer bigger.",+                    bufp += string_size;
Fixup the part of rsvp_obj_print() that decodes the GENERALIZED_UNI object from RFC 3476 Section 3.1 to check the sub-objects inside that object more thoroughly.,"+                    if(subobj_len < 4 || subobj_len > total_subobj_len)
                         goto invalid;"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-	ND_TCHECK(*ext);
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	if (!ND_TTEST2(*str2, tl1)) {
+		return 0;
+	}"
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \0.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,"-		        ND_TCHECK2(tptr[3], 8);"
add a missing length check,"+        if (tlv_len < 6) {
+            return hexdump;
+        }"
Calculate the reply payload length in a local variable.," 		if (d->name)
+			replylen += strlen(d->name);"
The OSPFv3 parser in tcpdump before 4.9.2 has a buffer over-read in print-ospf6.c:ospf6_decode_v3().," 		ND_PRINT((ndo, ""\n\tOptions [%s]"",
 		          bittok2str(ospf6_option_values, ""none"",
 		          EXTRACT_32BITS(&hellop->hello_options))));"
This fixes a buffer over-read,-				if (EXTRACT_16BITS(bp+2) != 0) {
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.","                    tok2str(juniper_protocol_values,""Unknown"",gh->proto),"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-          ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_BVID_MIN_LEN);"
This fixes a buffer over-read discovered by Kamil Frankowicz., 	astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
CVE-2017-13690/IKEv2: Fix some bounds checks.,-	ND_TCHECK(*ext);
"The TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop counter will overflow and you can loop infinitely.",         	i=i+3;
"Add bounds checks,","+    ND_TCHECK2(*tptr, 2);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",             subtype = *(tptr+4);
Add two bounds checks before fetching data, 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
Fix a bounds check,"+        if (tlen < 1U + oid_len) {
             return 0;
         }"
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.","+	ND_TCHECK2(*ext, sizeof(a));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
CVE-2017-13028/BOOTP: Add a bounds check before fetching data This,+	ND_TCHECK(bp->bp_flags);
Improve bounds and length checks.,"+	if (length < CHDLC_HDRLEN)
+		goto trunc;"
The VTP parser in tcpdump before 4.9.2 has a buffer over-read in print-vtp.c:vtp_print()., 	    len = *tptr;
fix VPN route target bounds checks,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-	ND_TCHECK(*ext);
This fixes a buffer over-read discovered by Kamil Frankowicz.," 			ND_PRINT((ndo, "" c %04x"", EXTRACT_32BITS(&dp[0])));"
CVE-2017-12989/RESP: Make sure resp_get_length() advances the pointer for invalid lengths.,"+    if (*bp != '\r') {
+        bp++;
         goto invalid;
+    }"
(for 4.9.3) CVE-2018-16228/HNCP: make buffer access safer.,"+        if (plenbytes < 0)
+            return plenbytes;"
Add a bounds check before fetching data,+		ND_TCHECK_32BITS(&hellop->hello_options);
"After we advance the pointer by the length value in the buffer, make sure it points to something in the captured data.", 	s += (*s) + 1;
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-12995/Check for DNS compression pointers that don't point backwards.,+				if (offset >= max_offset) {
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
Need to test bounds check for the last field of the structure lsa6_hdr.,+	ND_TCHECK(lshp->ls_length);
(for 4.9.3) CVE-2018-14463/VRRP: Add a missing bounds check in vrrp_print().,"+			if (in_cksum(vec, 1)) {"
Do bounds checking as we access items.,+	ND_TCHECK(rp->rip6_vers);
fix an Extended IS Reachability sub-TLV,"+            if (subl == 0)
+                break;"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		if (j == 1
-		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
-		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
-			ND_PRINT((ndo, "" ripng-req dump""));
-			break;"
"While we're at it, add the RFC number, and check the validity of the length for the Hello extension.",+		if (ep->length < 4) {
put an existing bounds check right,+                    ND_TCHECK(*tptr);
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().," 		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,=B105
This fixes a buffer over-read, 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,"                     ND_PRINT((ndo, "" %s (%u),"",
                            tok2str(eap_type_values, ""unknown"", *(tptr+count)),
                            *(tptr + count)));"
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_RESTART).,"                     ND_PRINT((ndo, ""\n\t\tRestart Flags: [%s], Restart Time %us"","
CVE-2017-12989/RESP: Make sure resp_get_length() advances the pointer for invalid lengths.,"+    if (*bp != '\n') {
+        bp++;
         goto invalid;
+    }"
"Check before fetching the ""access"" part of the NFSv3 ACCESS results.",-				ND_TCHECK(dp[2]);
This fixes a buffer over-read discovered by Bhargava Shastry.," 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));"
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levom??ki.,-				chars_processed++;
Enforce a limit on how many times smb_fdata() can recurse.,"+		if (depth == 10)
+			ND_PRINT((ndo, ""(too many nested levels, not recursing)""));"
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check","+        if (tlv_len < 6) {
+            return hexdump;
+        }"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_extd_ip_reach().,         status_byte=*(tptr++);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
Clean up bounds checking.,"-		if (j * sizeof(*ni) != length - 4)
-			ND_PRINT((ndo, "" ripng-req %d[%u]:"", j, length));"
Calculate the reply payload length in a local variable.," 		if (d->description)
+			replylen += strlen(d->description);"
CVE-2017-13032/RADIUS: Check whether a byte exists before testing its value.,"+           if (length < 1)
+              goto trunc;"
"Check for running out of packet data before checking for running out of captured data, and distinguish between running out of packet data (which might just mean ""no more strings"") and running out of captured data (which means ""truncated"").",+	if (!ND_TTEST(**pptr)) {
"The TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop counter will overflow and you can loop infinitely.",+    u_int i;
CVE-2017-13008/IEEE 802.11: Fix TIM bitmap copy to copy from p + offset.,"+			memcpy(tim.bitmap, p + offset, tim.length - 3);"
The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().,-	uint8_t  ip6r0_slmap[3];
Add missing checks to dhcpv6_print().,"+        if (i + 4 + optlen > length)
+            return -1;"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+	struct pcap_pkthdr nhdr;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 	ND_PRINT((ndo, "", Config Rev %x"", EXTRACT_32BITS(tptr)));"
In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo),"+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
add some bounds checks,"+        if (sizeof(struct vqp_obj_tlv_t) > tlen)
+            goto trunc;"
"However, dhcpv6_print() in the same file didn't do the same for the DHCPv6 options within the HNCP DHCPv6-Data TLV value, which could cause an out-of-bounds read when decoding an invalid packet.",         optlen = EXTRACT_16BITS(tlv + 2);
CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().,+                    space_left -= string_size;
In rx_cache_insert() and rx_cache_find() properly read the serviceId field of the rx_header structure as a 16-bit integer. ,+	rxent->serviceId = EXTRACT_16BITS(&rxh->serviceId);
Calculate the reply payload length in a local variable.,+		replylen += sizeof(struct rpcap_findalldevs_if);
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.","-                ND_TCHECK2(*tptr, 4);"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		j = length / sizeof(*ni);
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,"                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio"
Don't crash if crypt() fails.,+		return -1;
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_DIGEST_MIN_LEN);"
(for 4.9.3) CVE-2018-14882/ICMP6 RPL: Add a missing bounds check,+                ND_TCHECK(opt->rpl_dio_len);
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,"             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_start),"
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.","+	ND_TCHECK2(*ext, sizeof(a));"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_rt_routing_info().,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
Prevent a possible buffer overread in chdlc_print() and replace the custom check in chdlc_if_print() with a standard check in chdlc_print() so that the latter certainly does not over-read even when reached via juniper_chdlc_print().,"+	return chdlc_print(ndo, p, h->len);"
CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+	struct pcap_pkthdr nhdr;
"Also, put the buffer on the stack; no reason to make it static.",+		char temp[NFSX_V3FHMAX+1];
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 			ND_PRINT((ndo, ""(refresh: %u)"",
 				EXTRACT_16BITS(&bp[i+2]) << 2));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",                     subobj_len  = EXTRACT_16BITS(obj_tptr);
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""ANS "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ANS""));"
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them.,+	len = dp->ip6r_len;
Add more bounds checks.,+        ND_TCHECK(*gh);
"If one is, don't run past the end.","+    if (sysid_len > id_len)
+        sysid_len = id_len;"
CVE-2017-13015/EAP: Add more bounds checks.,+                ND_TCHECK_8BITS(tptr + 5);
Check for DNS compression pointers that don't point backwards.,+				if (offset >= max_offset) {
This fixes a buffer over-read,             l2info->proto = EXTRACT_16BITS(p);
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,+                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
offset has already been advanced to point to the bitmap; we shouldn't add the amount to advance again.,"-			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);"
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-				ND_PRINT((ndo, ""v%d"", *bp));"
This fixes a buffer overflow,+                    space_left -= string_size;
CVE-2017-12998/IS-IS: Check for 2 bytes if we're going to fetch 2 bytes.,"+        if (!ND_TTEST2(*tptr, 2)) 
             return (0);"
CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().,+                    space_left -= string_size;
"The bounds check in esis_print() tested one pointer at the beginning of a loop that incremented another, make the trivial fix.",+                    ND_TCHECK(*tptr);
"When those functions tried to read 32 bits the extra 16 bits could be outside of the bounds checked in rx_print() for the rx_header structure, as serviceId is the last field in that structure.",-		    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&
Improve bounds and length checks.,"+                if (length < 2)
+                    goto trunc;"
CVE-2017-12992/RIPng: Clean up bounds checking.,"-		if (j == 1
-		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
-		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
-			ND_PRINT((ndo, "" ripng-req dump""));
-			break;"
The telnet parser in tcpdump before 4.9.2 has a buffer over-read in print-telnet.c:telnet_parse().," 		if (*p != IAC)
 			goto pktend;"
add checks to make sure the subTLV fits within the TLV.,"+      	if (stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN)
+      	  goto trunc;"
"do a common check to make sure we captured the entire subTLV,","+    ND_TCHECK2(*(tptr), stlv_len);"
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",             l2info->proto = EXTRACT_16BITS(p);
"In aoev1_reserve_print() check bounds, before trying to print an Ethernet address.","+		ND_TCHECK_LEN(cp, MAC_ADDR_LEN);"
Calculate the reply payload length in a local variable.,+				replylen += (sizeof(struct rpcap_sockaddr) * 4);
fix VPN route target bounds checks,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
"clean up some other bounds checks,","-            ND_TCHECK2(*msg_data, 4);"
CVE-2017-13687/CHDLC: Improve bounds and length checks.,"+	ND_TCHECK2(*p, CHDLC_HDRLEN);"
"clean up some other bounds checks,","-        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+    ND_TCHECK2(*(tptr), stlv_len);"
This fixes a buffer over-read,             bit_length = tlv_ptr.eigrp_tlv_ip_ext->plen;
"Add bounds checks,","+          if (stlv_len < 8)
+            goto trunc;"
(for 4.9.3) CVE-2018-14461/LDP: Fix a bounds check.,+	TLV_TCHECK(12);
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	if (l_strnstart(""MSG"", 4, (const char *)bp, length))"
Add a missing option length check., 		case DH6OPT_RECONF_MSG:
The Cisco HDLC parser in tcpdump before 4.9.2 has a buffer over-read in print-chdlc.c:chdlc_print().,"+	return chdlc_print(ndo, p, h->len);"
(for 4.9.3) CVE-2018-14468/FRF.16: Add a missing length check.,+                if (ie_len != 4) {
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst,			plen+= strlen(d->name);
The ISAKMP parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c:isakmp_rfc3948_print()., 	if(length == 1 && bp[0]==0xff) {
Add a bounds check and a comment to bgp_capabilities_print().,+                    ND_TCHECK_8BITS(opt + i + 5);
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,-        tptr = tptr + sizeof(struct isis_subtlv_spb_mcid);
Add two bounds checks before fetching data,"+	if (!ND_TTEST(rp->rm_call.cb_proc))
+		return (0);"
Add missing checks to make this safe.,"+                                else if (tlen == BGP_VPN_RD_LEN + 3 + sizeof(struct in6_addr)
+                                         && EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)"
"We might, for example, want to make sure the upper 2 bits of the label length/pointer byte are 00 or 11, and that if we encounter a pointer and jump backwards to what we think is a label the label ends before the beginning of the last label we processed, to make sure the pointer doesn't point backwards into the *middle* of a label, and also make sure the entire name is <= 255 bytes long.",+				if (offset >= max_offset) {
Add more bounds checks.,"+        ND_TCHECK2(p[0], 2);"
Properly terminate all struct tok arrays.,"+    { 0, NULL},"
"The IKEv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c, several functions.",-	ND_TCHECK(*ext);
don't print the address as an IPv4 address.,"+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+            if (!ext_dp->icmp_length &&
+                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		if (j * sizeof(*ni) != length - 4)
CVE-2017-12999/IS-IS: Add a missing length check.,"+	        ND_TCHECK2(*tptr, alen);"
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_MP).,"                    ND_PRINT((ndo, ""\n\t\tAFI %s (%u), SAFI %s (%u)"",
                           tok2str(af_values, ""Unknown"",
                                      EXTRACT_16BITS(opt+i+2)),"
CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.,"+				ND_PRINT((ndo,"")""));"
add checks to make sure the subTLV fits within the TLV.,+        while (stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
This fixes a buffer over-read discovered by Kamil Frankowicz.,-		temp[sizeof(temp) - 1] = '\0';
CVE-2017-13015/EAP: Add more bounds checks.,+        ND_TCHECK_8BITS(tptr);
(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \\0.,+	len = strlen (ptr);
Properly check for buffer overflow in bittok2str_internal().,+                    space_left -= string_size;
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check","+        if (tlv_len < 6) {
+            return hexdump;
+        }"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+    ND_TCHECK2(*(tptr), stlv_len);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-            u_int addr_size = 4;
Properly terminate all struct tok arrays.,"+    { 0,  NULL},"
fix decoding of MVPN route types 6 and 7 RFC 6514 Section 4.6 defines the structure for Shared Tree Join (6) and Source Tree Join (7) multicast VPN route types.,+            pptr += BGP_VPN_RD_LEN + 4;
The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().,"-            ND_TCHECK2(*msg_data, 4);"
Fixup the part of rsvp_obj_print() that decodes the GENERALIZED_UNI object from RFC 3476 Section 3.1 to check the sub-objects inside that object more thoroughly.,"+                    if (total_subobj_len < 4)
+                        goto invalid;"
CVE-2017-12987/IEEE 802.11: Fix processing of TIM IE.,"+			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);"
The FRF.16 parser in tcpdump before 4.9.3 has a buffer over-read in print-fr.c:mfr_print().,"                 ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));"
(for 4.9.3) LMP: Add some missing bounds checks,+	    ND_TCHECK_8BITS(obj_tptr + offset + 3);
The ICMPv6 parser in tcpdump before 4.9.3 has a buffer over-read in print-icmp6.c.,                 opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);
NULL pointer dereference,"-	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)"
CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"")""));"
"While we're at it, clean up some other bounds checks, so we check that we have a complete IPv4 message header if it's IPv4 and a complete IPv6 message header if it's IPv6.","+            ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
This fixes a buffer over-read,"-				unsigned_relts_print(ndo, EXTRACT_16BITS(bp));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
Several protocol parsers in tcpdump before 4.9.2 could cause a buffer over-read in addrtoname.c:lookup_bytestring().,"-	while (tp->e_nxt)
-		if (tp->e_addr0 == i &&
-		    tp->e_addr1 == j &&
-		    tp->e_addr2 == k &&
-		    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,"-			    print_unknown_data(ndo, tptr+3,""\n\t      "", length-3);"
In aodv_extension() do a bounds check on the extension header before we look at it., 	switch (ep->type) {
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,         type = *(tptr);
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""RPY "", 4, (const char *)bp, length))"
Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
Add a missing bounds check in rsvp_obj_print().,+                ND_TCHECK_32BITS(obj_tptr);
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,"-		    ND_TCHECK2(tptr[3], length - 3);"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
This fixes a buffer over-read,         switch (ih->type) {
This fixes a buffer over-read discovered by Kamil Frankowicz.,-	if (caplen <= 1) {
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,             subtype = *(tptr+4);
The RSVP parser in tcpdump before 4.9.3 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,"                 ND_PRINT((ndo, ""%s  CT: %u"",
                        ident,
                        EXTRACT_32BITS(obj_tptr) & 0x7));"
"Add bounds checks,","+    if (len < stlv_len)
+      goto trunc;"
CVE-2017-13048/RSVP: fix decoding of Fast Reroute objects.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().," 			ND_PRINT((ndo, ""(refresh: %u)"",
 				EXTRACT_16BITS(&bp[i+2]) << 2));"
Add more bounds checks.,+        ND_TCHECK(*mh);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-            pptr += BGP_VPN_RD_LEN;
CVE-2017-12993/Juniper: Add more bounds checks.,+    ND_TCHECK(p[0]);
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check and could over-read the input buffer, put it right.","+        if (tlv_len < 6) {
+            return hexdump;
+        }"
CVE-2017-12900/Properly terminate all struct tok arrays.,"+    { 0,  NULL},"
(for 4.9.3) CVE-2018-14462/ICMP: Add a missing bounds check in icmp_print().,+				ND_TCHECK_16BITS(&dp->icmp_cksum);
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+            if (!ext_dp->icmp_length &&
+                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {"
"In ldp_tlv_print(), the FT Session TLV length must be 12, not 8 (RFC3479)",+	TLV_TCHECK(12);
CVE-2017-12898/NFS: Fix bounds checking.,+				ND_TCHECK(dp[4]);
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		    i -= sizeof(*ni), ++ni) {"
CVE-2017-13021/ICMP6: Add a missing bounds check.,+			ND_TCHECK(dp->icmp6_data16[1]);
Add two missing bounds checks,"+	if (strcmp((const char *)(data1 + 2), MAILSLOT_BROWSE_STR) == 0) {"
add DHCPv4-Data bounds checks,"+        if (i + 2 > length)
+            return -1;"
This fixes a buffer over-read discovered by Kamil Frankowicz.," 		if (length < sizeof(struct aodv_hello))
 			goto trunc;"
CVE-2017-13044/HNCP: add DHCPv4-Data bounds checks.,"+        if (i + 2 + optlen > length)
+            return -1;"
Add two missing bounds checks,"+	ND_TCHECK2(*(data1 + 2), strlen(PIPE_LANMAN_STR) + 1);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.",=B105
"While we're at it, print a truncation error if the packets are truncated, rather than just, in effect, ignoring the result of the routines that print particular packet types.","+		ND_PRINT((ndo, ""%s"", tstr));"
"Don't pass the remaining caplen - that's too hard to get right, and we were getting it wrong in at least one case;",-	if (caplen <= 1) {
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
This fixes a buffer over-read discovered by Bhargava Shastry., 				uint16_t icmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);
CVE-2017-13035/Properly handle IS-IS IDs shorter than a system ID (MAC address).,+    for (i = 1; i <= sysid_len; i++) {
This fixes a buffer over-read,"-				ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(bp)));"
This fixes a buffer over-read,         status_byte=*(tptr++);
"rt6_print(), ah_print(), and esp_print() return -1 if they run up against the end of the packet while dissecting; if that happens, stop dissecting, don't try to fetch the next header value, because 1) *it* might be past the end of the packet and 2) we won't be using it in any case, as we'll be exiting the loop.","+			if (advance < 0)
+				return;"
add checks to make sure the subTLV fits within the TLV.,"+    if (len < stlv_len)
+      goto trunc;"
Check for print routines returning -1 when running past the end.,"+                       in_cksum(vec, 1) ? ""in"" : """",
+                       hlen));"
"print_prefix() has a buffer and does not initialize it. It may call decode_prefix6(), which also does not initialize the buffer on invalid input. When that happens, make sure to return from print_prefix() before trying to print the [still uninitialized] buffer.","+        if (plenbytes < 0)
+            return plenbytes;"
CVE-2017-13048/RSVP: fix decoding of Fast Reroute objects.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
CVE-2017-13690/IKEv2: Fix some bounds checks.,-	ND_TCHECK(*ext);
The IKEv1 parser in tcpdump before 4.9.3 has a buffer over-read in print-isakmp.c:ikev1_n_print().,+			ND_TCHECK_32BITS(cp);
Add a missing bounds check.,+		ND_TCHECK(*p);
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,"             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_start),"
Add bounds checks to ip_printroute().,"+			if (ip_printroute(ndo, cp, option_len) == -1)
+				goto trunc;"
add a missing length check,"+	        ND_TCHECK2(*tptr, alen);"
"decode_multicast_vpn() didn't implement the Source AS field of that structure properly, adjust the offsets to put it right.",-            pptr += BGP_VPN_RD_LEN;
Use ND_TTEST() for the bounds checks in isoclns_print().,+	if (!ND_TTEST(*p)) {
CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+			nhdr.len = length;
(for 4.9.3) SMB: Add two missing bounds checks,"+	if (strcmp((const char *)(data1 + 2), MAILSLOT_BROWSE_STR) == 0) {"
CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_RESTART).,                            EXTRACT_16BITS(opt+i+2)&0xfff));
add DHCPv6-Data bounds checks,"+        if (i + 4 > length)
+            return -1;"
"The Zephyr parser in tcpdump before 4.9.2 has a buffer over-read in print-zephyr.c, several functions.","-    if (*pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
This fixes a buffer over-read,"-   for (i=0; *data && i < length ; i++, data++)"
Add missing checks to dhcpv6_print().,"+        if (i + 4 > length)
+            return -1;"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-        if (tlen < oid_len) {
"Check for running out of packet data before checking for running out of captured data, and distinguish between running out of packet data (which might just mean ""no more strings"") and running out of captured data (which means ""truncated"").","+	if (*len == 0) {
+	    return NULL;
+	}"
Clean up bounds checking.,"-	if (ndo->ndo_snapend < dat)
-		return;"
add some bounds checks,"+            if (vqp_obj_len != 4)
+                goto trunc;"
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" attrs=(""));"
This fixes a buffer over-read,"-				ND_PRINT((ndo, ""v%d"", *bp));"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		for (ni = rp->rip6_nets; i >= sizeof(*ni);
"rt6_print(), ah_print(), and esp_print() return -1 if they run up against the end of the packet while dissecting; if that happens, stop dissecting, don't try to fetch the next header value, because 1) *it* might be past the end of the packet and 2) we won't be using it in any case, as we'll be exiting the loop.","+			if (advance < 0)
+				return;"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,+                vec[0].len = hlen;
"rt6_print(), ah_print(), and esp_print() return -1 if they run up against the end of the packet while dissecting; if that happens, stop dissecting, don't try to fetch the next header value, because 1) *it* might be past the end of the packet and 2) we won't be using it in any case, as we'll be exiting the loop.","+			if (advance < 0)
+				return;"
CVE-2017-13046/BGP: fix an existing bounds check for PMSI Tunnel.,"+                ND_TCHECK2(tptr[0], 5);"
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().," 		ip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));"
(for 4.9.3) LMP: Add some missing bounds checks,+	    ND_TCHECK_32BITS(obj_tptr + offset + 4);
CVE-2017-13042/HNCP: add DHCPv6-Data bounds checks.,"+        if (i + 4 + optlen > length)
+            return -1;"
"It also fetched the varying number of octets of the route target field from 4 octets lower than the correct offset, put it right.","-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.",             for (te_class = 0; te_class < (subl-1)/4; te_class++) {
"An IPv6 address plus subnet mask is 32 bytes, not 20 bytes.","-			if (len < 20)
-				ND_PRINT((ndo,"" len=%d [bad: < 20]"", len));"
(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
"The loop can be executed more than once (that's kinda the whole point of a loop), so the check has to be made each time through the loop, not just once before the loop is executed.","+		    ND_TCHECK2(tptr[0], 3);"
CVE-2017-12993/Juniper: Add more bounds checks.,"+            ND_TCHECK2(p[0], 2);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 		opt_type = *bp++;
CVE-2017-12898/NFS: Fix bounds checking.,-				ND_TCHECK(dp[2]);
This fixes an infinite loop," 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);"
This fixes a buffer over-read discovered by Kamil Frankowicz., 	int mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,"                 ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                        tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                        *(tptr + 5)));"
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",     *endp = bp;
CVE-2017-12994/BGP: Move a test inside a loop.,"+		    ND_TCHECK2(tptr[0], 3);"
"Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst (if the request had extra stuff at the end, so that the variable is non-zero).",			plen+= strlen(d->name);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));"
Add length checks.,+                ND_TCHECK_16BITS(p);
This fixes a buffer over-read,"                    tok2str(juniper_protocol_values,""Unknown"",gh->proto),"
The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().,"+   for (i=0; i < length && *data; i++, data++)
        ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                    ND_PRINT((ndo, ""\n\t\tAFI %s (%u), SAFI %s (%u)"",
                           tok2str(af_values, ""Unknown"",
                                      EXTRACT_16BITS(opt+i+2)),"
Add bounds checks when printing time stamp options.,+	ND_TCHECK(cp[2]);
CVE-2017-13028/BOOTP: Add a bounds check before fetching data.,+	ND_TCHECK(bp->bp_flags);
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+				ND_PRINT((ndo,"")""));"
has a buffer over-read,                 opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);
"If it returns a negative number, it hasn't necessarily filled in buf, so just return immediately; this is similar to the IPv4 code path, wherein we just return a negative number, and print nothing, on an error.","         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));"
The PGM parser in tcpdump before 4.9.2 has a buffer over-read in print-pgm.c:pgm_print()., 		opt_type = *bp++;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levom??ki.,-				if (chars_processed >= data_size) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-                ND_TCHECK2(tptr[0], 5);"
"While we're at it, print a truncation error if the packets are truncated, rather than just, in effect, ignoring the result of the routines that print particular packet types.","+		ND_PRINT((ndo, ""%s"", tstr));"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+            if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN)
+              goto trunc;"
CVE-2017-13004/Juniper: Add a bounds check.,+            ND_TCHECK_16BITS(p+l2info->cookie_len);
This fixes a buffer over-read,-	uint8_t  ip6r0_reserved;
Do some additional length checks while we're at it.,"+		    ND_TCHECK2(tptr[3], length);"
"Add bounds checks,","         ND_PRINT((ndo, ""\n\t        RES: %d V: %d A: %d D: %d"",
                         (*(tptr) >> 5), (((*tptr)>> 4) & 0x01),"
CVE-2017-13015/EAP: Add more bounds checks.,+                ND_TCHECK_8BITS(tptr + 5);
rpcapd/daemon.c in libpcap before 1.9.1 allows attackers to cause a denial of service (NULL pointer dereference and daemon crash) if a crypt() call fails.,"+	crypt_password = crypt(password, user_password);"
"Update to reflect the actual IPv6 RFC. In RFC 1883, the Type 0 routing header had a 1-byte reserved field and a 3-byte strict/loose bit map; in RFC 2460, that changed to a 4-byte reserved field.",+	uint32_t ip6r0_reserved;
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+			ND_PRINT((ndo,"" attrs=(""));"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"                 if (in_cksum(vec, 1)) {"
This fixes a buffer over-read,             l2info->proto = EXTRACT_16BITS(p);
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.",+	ND_TCHECK(*k);
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_MCID_MIN_LEN);"
CVE-2017-13005/NFS: Add two bounds checks before fetching data., 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
This fixes a buffer over-read,-	TLV_TCHECK(8);
Add two bounds checks before fetching data, 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levom??ki.,-					return (NULL);
Add missing checks to make this safe.,"+                                if (tlen == BGP_VPN_RD_LEN + 4 + sizeof(struct in_addr)
+                                    && EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().,"-			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);"
The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_id()., 	pos += strlen(pos);
The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().,         	i=i+3;
The ISO CLNS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isoclns_print().,-	if (caplen <= 1) {
The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().,-    if (*bp != '\n')
CVE-2017-13053/BGP: fix VPN route target bounds checks.,"-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
This fixes a buffer over-read, 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().,"-	else if (l_strnstart(""ANS "", 4, (const char *)bp, length))"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+    if (len < stlv_len)
+      goto trunc;"
CVE-2017-13015/EAP: Add more bounds checks.,+            ND_TCHECK_8BITS(tptr+4);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options"," 			else
+				ND_PRINT((ndo, "" [optlen != 4 or 6]""));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-                ND_TCHECK2(*tptr, 4);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-        len = len - sizeof(struct isis_subtlv_spb_mcid);
don't print the address as an IPv4 address.,"+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
Add bounds checks to ip_printroute().,+	ND_TCHECK(cp[2]);
"It also fetched the varying number of octets of the route target field from 4 octets lower than the correct offset, put it right.","-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
has a buffer over-read,+	len = dp->ip6r_len;
This fixes an infinite loop.,-    uint8_t i;
fix decoding of MVPN route types 6 and 7 RFC 6514 Section 4.6 defines the structure for Shared Tree Join (6) and Source Tree Join (7) multicast VPN route types.,"+            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-	i -= (sizeof(struct rip6) - sizeof(struct netinfo6));
In aoev1_reserve_print() check bounds before trying to print an Ethernet address.,"+		ND_TCHECK_LEN(cp, MAC_ADDR_LEN);"
Add a bounds check in name_len().,"+	ND_TCHECK2(*s, 1);"
CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data,+			ND_TCHECK_16BITS(&bp[i+2]);
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them., 	ND_TCHECK(dp->ip6r_segleft);
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them., 	ND_TCHECK(dp->ip6r_segleft);
"An IPv6 address plus subnet mask is 32 bytes, not 20 bytes.","+			if (len < 32)
+				ND_PRINT((ndo,"" len=%d [bad: < 32]"", len));"
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.","         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "",
                    EXTRACT_32BITS(&mh->service_id),"
(for 4.9.3) CVE-2018-14466/Rx: fix an over-read bug,-		    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&
add DHCPv6-Data bounds checks,"+        if (i + 4 + optlen > length)
+            return -1;"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:nfs_printfh().,-		temp[sizeof(temp) - 1] = '\0';
This fixes a buffer over-read discovered by Yannick Formaggio.,"-			hdrlen += printer(ndo, h, p);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 	pos += strlen(pos);
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" status=(""));"
CVE-2017-13015/EAP: Add more bounds checks.,+                    ND_TCHECK_32BITS(tptr + 6);
The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print().,"                        isonsap_string(ndo, tptr, alen)));"
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check and could over-read the input buffer, put it right.","+        if (tlv_len < 6) {
+            return hexdump;
+        }"
Don't use an 8-bit loop counter.,-    uint8_t i;
"Check for running out of packet data before checking for running out of captured data, and distinguish between running out of packet data (which might just mean ""no more strings"") and running out of captured data (which means ""truncated"").",+	if (!ND_TTEST(**pptr)) {
Add a bounds check before fetching data,+			ND_TCHECK_16BITS(&bp[i+2]);
Improve bounds and length checks.,"+	ND_TCHECK2(*p, CHDLC_HDRLEN);"
CVE-2017-13005/NFS: Add two bounds checks before fetching data.,"+	if (!ND_TTEST(rp->rm_call.cb_vers))
+		return (0);"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		if (trunc)
-			ND_PRINT((ndo, ""[|ripng]""));"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-            ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN);"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
CVE-2017-13053/BGP: fix VPN route target bounds checks.,+	ND_TCHECK_32BITS(pptr + 1);
has a buffer over-read,-	len = dp->ip6r_len;
print_prefix() has a buffer and does not initialize it.,"+        if (plenbytes < 0)
+            return plenbytes;"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+				ND_PRINT((ndo, "" (elapsed time %u)"", EXTRACT_16BITS(option + 6)));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",             pptr += opli;
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_RESTART).,"                            ((opt[i+2])&0x80) ? ""R"" : ""none"","
CVE-2017-12901/EIGRP: Do more length checks.,+            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_sw_version)) {
This fixes a buffer over-read discovered by Yannick Formaggio.,"-			hdrlen += printer(ndo, h, p);"
In aodv_extension() do a bounds check on the extension header before we look at it.,+	ND_TCHECK(*ep);
This fixes a buffer over-read,"-					ND_PRINT((ndo, "", interval ""));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"")""));"
Properly check for buffer overflow in bittok2str_internal().,+                    space_left -= string_size;
"Also, make the buffer bigger.",+                    bufp += string_size;
Don't fetch the length field from the header until after we've checked for the existence of a field at or after that field., 	ND_TCHECK(dp->ip6r_segleft);
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,"-                ND_TCHECK2(tptr[0], 5);"
The command-line argument parser in tcpdump before 4.9.3 has a buffer overflow in tcpdump.c:get_next_file().,"-	if (ptr[strlen(ptr) - 1] == '\n')
-		ptr[strlen(ptr) - 1] = '\0';"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-	if (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))
-		return;"
Add more bounds checks.,+    ND_TCHECK(p[0]);
CVE-2017-12988/TELNET: Add a missing bounds check.,+		ND_TCHECK(*p);
"When bgp_attr_print() tried to decode the variable-length nexthop value for the NSAP VPN case, it did not check that the declared length is good to interpret the value as a mapped IPv4 or IPv6 address.",-                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)
This fixes a buffer over-read discovered by Kamil Frankowicz.,-				ND_TCHECK(dp[2]);
CVE-2017-13047/ES-IS: put an existing bounds check right.,-                    ND_TCHECK(*pptr);
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,"-	ND_TCHECK2(dp[0], 0);"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"")""));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
(for 4.9.3) LMP: Add some missing bounds checks,+	    ND_TCHECK_32BITS(obj_tptr + offset + 8);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
 				EXTRACT_16BITS(&bp[i+2]),
 				EXTRACT_16BITS(&bp[i+4])));"
The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().,-            int name_entries_valid = 0;
"In aoev1_reserve_print() check bounds, before trying to print an Ethernet address."," 		ND_PRINT(""\n\tEthernet Address %u: %s"", i, etheraddr_string(ndo, cp));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","         snprintf(pos, sizeof(id) - (pos - id), ""%02x"", *cp++);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,-        len = len - sizeof(struct isis_subtlv_spb_mcid);
This fixes a buffer over-read,-		for (ni = rp->rip6_nets; i >= sizeof(*ni);
CVE-2017-12993/Juniper: Add more bounds checks.,"+        ND_TCHECK2(p[0], 3);"
Do bounds checking as we access items.,"+		for (ni = rp->rip6_nets; length_left >= sizeof(*ni);
+		    length_left -= sizeof(*ni), ++ni) {
+			ND_TCHECK(*ni);"
"The White Board protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-wb.c:wb_prep(), several functions.",-	if (len < sizeof(*prep)) {
This fixes a buffer over-read discovered by Yannick Formaggio., 	n = EXTRACT_32BITS(&prep->pp_n);
"In ldp_tlv_print(), the FT Session TLV length must be 12, not 8 (RFC3479)",-	TLV_TCHECK(8);
The IKEv1 parser in tcpdump before 4.9.3 has a buffer over-read in print-isakmp.c:ikev1_n_print().," 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));"
"Move a return to make the code a bit cleaner (i.e., make it more obvious that if we don't have enough of the PGM header, we just print the source and destination IP addresses, mark it as incomplete PGM, and don't try to look at the PGM header).",-			return;
The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().,"-	else if (l_strnstart(""SEQ "", 4, (const char *)bp, length))"
Pass a properly updated struct pcap_pkthdr to the sub-dissector.,"+			hdrlen += printer(ndo, &nhdr, p);"
"When bgp_attr_print() tried to decode the variable-length nexthop value for the NSAP VPN case, it did not check that the declared length is good to interpret the value as a mapped IPv4 or IPv6 address.","+                                if (tlen == BGP_VPN_RD_LEN + 4 + sizeof(struct in_addr)
+                                    && EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)"
"While we're at it, clean up some other bounds checks, so we check that we have a complete IPv4 message header if it's IPv4 and a complete IPv6 message header if it's IPv6.","-        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
"Add bounds checks,","+            if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN)
+              goto trunc;"
The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv4_print().,         optlen = (uint8_t)tlv[1];
CVE-2017-12901/EIGRP: Do more length checks.,+            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_ip_ext)) {
CVE-2017-13053/BGP: fix VPN route target bounds checks.,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_multicast_vpn().,-            pptr += BGP_VPN_RD_LEN;
This fixes a buffer over-read,"-    if (*len <= 0 || !pptr || !*pptr)
-	return NULL;"
"clean up some other bounds checks,","-        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
"do a common check to make sure we captured the entire subTLV,","+    ND_TCHECK2(*(tptr), stlv_len);"
Add two missing bounds checks,"+	ND_TCHECK2(*(data1 + 2), strlen(MAILSLOT_BROWSE_STR) + 1);"
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",     *endp = bp;
CVE-2017-13005/NFS: Add two bounds checks before fetching data.,"+	if (!ND_TTEST(rp->rm_call.cb_vers))
+		return (0);"
"Also, add some infinite-pointer-loop captures.",+				if (offset >= max_offset) {
Do bounds checking.,+    if (!ND_TTEST_16BITS(p)) {
This fixes a buffer over-read discovered by Bhargava Shastry.,+			ND_TCHECK_32BITS(cp);
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.","+            if (subl == 0)
+                break;"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+                       in_cksum(vec, 1) ? ""in"" : """",
+                       hlen));"
In mfr_print() check this before trying to read those 4 bytes.,"                 ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));"
The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,                     af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;
The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().,-	uint8_t  ip6r0_reserved;
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().,+                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
CVE-2017-13045/VQP: add some bounds checks.,"+            if (vqp_obj_len != ETHER_ADDR_LEN)
+                goto trunc;"
In rx_cache_insert() and rx_cache_find() properly read the serviceId field of the rx_header structure as a 16-bit integer.,+		    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&
This fixes a buffer over-read,"-	i = min(length, amt);"
The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().,            if (length < 3)
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,-				if (*(bp+1) != 0) {
Check for print routines returning -1 when running past the end.,"+            if (!ext_dp->icmp_length &&
+                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {"
This fixes a buffer over-read,"-    if (*pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"                 if (in_cksum(vec, 1)) {"
Reverse the test in a for loop to test the length before testing whether we have a null byte.,"+   for (i=0; i < length && *data; i++, data++)
        ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+                       in_cksum(vec, 1) ? ""in"" : """",
+                       hlen));"
This fixes a buffer over-read,            if (*data <= 0x1F)
CVE-2017-13016/ES-IS: Fix printing of addresses in RD PDUs.,"-		if (netal == 0)
-			ND_PRINT((ndo, ""\n\t  %s"", etheraddr_string(ndo, snpa)));"
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them.,-	len = dp->ip6r_len;
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,"             ND_PRINT((ndo, ""\n\t    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %u"",
                    EXTRACT_16BITS(tlv_ptr.eigrp_tlv_general_parm->holdtime),"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.",-        len = len - sizeof(struct isis_subtlv_spb_mcid);
(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely.,+	len = strlen (ptr);
The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().,         vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);
"The ARP parser in tcpdump before 4.9.2 has a buffer over-read in print-arp.c, several functions.","-	if (!ND_TTEST2(*ar_tpa(ap), PROTO_LEN(ap))) {"
"Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst (if the request had extra stuff at the end, so that the variable is non-zero).",-		plen+= sizeof(struct rpcap_findalldevs_if);
(for 4.9.3) CVE-2018-14467/BGP: Fix BGP_CAPCODE_MP.,+                    ND_TCHECK_8BITS(opt + i + 5);
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (ATMTPROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong tplen>""));"
CVE-2017-13005/NFS: Add two bounds checks before fetching data., 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \\0.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions."," 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);"
This fixes a buffer over-read,-		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
"Also, put the buffer on the stack; no reason to make it static.",+		char temp[NFSX_V3FHMAX+1];
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
This fixes a buffer over-read,     tlen=len-sizeof(struct eigrp_common_header);
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"")""));"
Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst,-			plen+= strlen(d->description);
CVE-2017-12987/IEEE 802.11: Fix processing of TIM IE.,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
"In ldp_tlv_print(), the FT Session TLV length must be 12, not 8 (RFC3479).",+	TLV_TCHECK(12);
Prevent a possible buffer overread in chdlc_print() and replace the custom check in chdlc_if_print() with a standard check in chdlc_print() so that the latter certainly does not over-read even when reached via juniper_chdlc_print().,"                 if (*(p+1) == 0x81 ||
                     *(p+1) == 0x82 ||
                     *(p+1) == 0x83)"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;","-			hdrlen += printer(ndo, h, p);"
Add some missing bounds checks.,+	ND_TCHECK(*ep);
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.",                 bw.i = EXTRACT_32BITS(tptr);
"Add bounds checks,","+        if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
+          goto trunc;"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.",           tptr = tptr + 2;
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,     tlen=len-sizeof(struct eigrp_common_header);
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
This fixes a buffer over-read,"-					unsigned_relts_print(ndo, *(bp+1));"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+				ND_PRINT((ndo, "" (elapsed time %u)"", EXTRACT_32BITS(option + 6)));"
Fix TIM bitmap copy to copy from p + offset.,"+			memcpy(tim.bitmap, p + offset, tim.length - 3);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
This fixes a buffer over-read," 		ND_PRINT((ndo, ""\n\t      Area address (length: %u): %s"","
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""NUL "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP NUL""));"
CVE-2017-12900/Properly terminate all struct tok arrays.,"+    { 0, NULL},"
Check for print routines returning -1 when running past the end.,"                 if (in_cksum(vec, 1)) {"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,"                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio,"
Improve bounds and length checks.,+                ND_TCHECK_16BITS(p);
Enforce a limit on how many times bgp_attr_print() can recurse.,"+			if (!bgp_attr_print(ndo, atype, p, alen, 0))
 				goto trunc;"
(for 4.9.3) CVE-2018-14881/BGP: Fix BGP_CAPCODE_RESTART.,+                    ND_TCHECK_16BITS(opt + i + 2);
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;","+			hdrlen += printer(ndo, &nhdr, p);"
The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().,-    uint8_t i;
"It can fail, so make sure it doesn't before comparing its result with the password.",+		return -1;
This fixes a buffer over-read,-	uint8_t  ip6r0_slmap[3];
This fixes a buffer over-read,"-		if (j == 1
-		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
-		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
-			ND_PRINT((ndo, "" ripng-req dump""));
-			break;"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (ATMTPROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong tplen>""));"
(for 4.9.3) CVE-2018-14466/Rx: fix an over-read bug.,-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
"If we're skipping over padding before the *real* flags, check whether the real flags are in the captured data before fetching it.",+	    ND_TCHECK(rhp->rh_short.sh_flags);
CVE-2017-13031/Check for the presence of the entire IPv6 fragment header.,-	ND_TCHECK(dp->ip6f_offlg);
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \\0.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
only print it as a MAC address if it's 6 bytes long.,"+		if (snpal == 6)
+			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
+			       snpal,
+			       etheraddr_string(ndo, snpa)));"
The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().,"-	else if (l_strnstart(""RPY "", 4, (const char *)bp, length))"
This fixes a buffer overflow,+                    space_left -= string_size;
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""ANS "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ANS""));"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+				ND_PRINT((ndo,"")""));"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options."," 			else
+				ND_PRINT((ndo, "" [optlen != 4 or 6]""));"
CVE-2017-12992/RIPng: Clean up bounds checking.,"-		if (j * sizeof(*ni) != length - 4)
-			ND_PRINT((ndo, "" ripng-req %d[%u]:"", j, length));"
This fixes a buffer over-read,"-		    i -= sizeof(*ni), ++ni) {"
CVE-2017-13044/HNCP: add DHCPv4-Data bounds checks.,"+        if (i + 2 > length)
+            return -1;"
This fixes a buffer over-read,"-	if (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))
-		return;"
The Rx protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-rx.c:ubik_print()., 			temp = EXTRACT_32BITS(bp);
CVE-2017-13020/VTP: Add some missing bounds checks.,+	ND_TCHECK_32BITS(tptr);
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","-		ND_PRINT((ndo,"")""));"
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",         switch (ih->type) {
fix bounds checks for UNI.,"+                    if (total_subobj_len < 4)
+                        goto invalid;"
This fixes a buffer over-read discovered by Kamil Frankowicz.," 				ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64,
 						EXTRACT_32BITS(&dp[4]),
 						EXTRACT_32BITS(&dp[2]),
 						EXTRACT_64BITS(&dp[0])));"
rpcapd/daemon.c in libpcap before 1.9.1 allows attackers to cause a denial of service (NULL pointer dereference and daemon crash) if a crypt() call fails.,"-	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""ANS "", 4, (const char *)bp, length))"
"The loop can be executed more than once (that's kinda the whole point of a loop), so the check has to be made each time through the loop, not just once before the loop is executed.","-		ND_TCHECK2(tptr[0], 3);"
"Update to reflect the actual IPv6 RFC. In RFC 1883, the Type 0 routing header had a 1-byte reserved field and a 3-byte strict/loose bit map; in RFC 2460, that changed to a 4-byte reserved field.",+	uint8_t  ip6r0_segleft;
"We do bounds checks based on the TLV length, so if the TLV's length is too short, and we don't check for that, we could end up fetching data past the end of the TLV - including past the length of the captured data in the packet.",+				if (olen != 4) {
This fixes an infinite loop,-    if (*bp != '\r')
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_rt_routing_info().,"-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 			ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));"
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,         tlv_tlen=eigrp_tlv_len-sizeof(struct eigrp_tlv_header);
This fixes a buffer over-read,-                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)
CVE-2017-13041/ICMP6: Add more bounds checks.,+			ND_TCHECK(cp[0]);
CVE-2017-12901/EIGRP: Do more length checks.,+        if (eigrp_tlv_len < sizeof(struct eigrp_tlv_header)) {
In mfr_print() check this before trying to read those 4 bytes.,+                if (ie_len != 4) {
No need to test other fields.,-	ND_TCHECK(lshp->ls_seq);
This fixes a buffer over-read,"         if (EXTRACT_24BITS(p) == 0xfefe03 || 
             EXTRACT_24BITS(p) == 0xaaaa03) {"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;",+			nhdr.caplen = caplen;
Add a missing bounds check in vrrp_print().,+				ND_TCHECK_16BITS(&bp[6]);
This fixes a buffer over-read,+	TLV_TCHECK(12);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+			if (optlen == 6)
 				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
This fixes a buffer over-read, 	    switch (EXTRACT_16BITS(bp)) {
This fixes a buffer over-read discovered by Kamil Frankowicz.,"-		strncpy(temp, sfsname, NFSX_V3FHMAX);"
Add length checks.,"+	if (length < CHDLC_HDRLEN)
+		goto trunc;"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
(for 4.9.3) LMP: Add some missing bounds checks,+	    ND_TCHECK_8BITS(obj_tptr + offset + 2);
"The Zephyr parser in tcpdump before 4.9.2 has a buffer over-read in print-zephyr.c, several functions.","-    if (*len <= 0 || !pptr || !*pptr)
-	return NULL;"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+			ND_PRINT((ndo,"")""));"
Check for print routines returning -1 when running past the end.,"+            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {"
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""SEQ "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP SEQ""));"
"Also, put the buffer on the stack; no reason to make it static.",-		static char temp[NFSX_V3FHMAX+1];
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,"+                if (subtype == EAP_TYPE_TTLS)
+                    ND_PRINT((ndo, "" TTLSv%u"",
+                           EAP_TTLS_VERSION(*(tptr + 5))));"
The DCCP parser in tcpdump before 4.9.3 has a buffer over-read in print-dccp.c:dccp_print_option()., 			if (optlen > 2) {
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",+    *endp = bp;
"CVE-2017-12894/In lookup_bytestring(), take the length of the byte string into account.","+	while (tp->bs_nxt)
+		if (nlen == tp->bs_nbytes &&
+		    tp->bs_addr0 == i &&
+		    tp->bs_addr1 == j &&
+		    tp->bs_addr2 == k &&
+		    memcmp((const char *)bs, (const char *)(tp->bs_bytes), nlen) == 0)
 			return tp;"
This fixes a buffer over-read,"                            ((opt[i+2])&0x80) ? ""R"" : ""none"","
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""END"", 4, (const char *)bp, length))"
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them.,-	len = dp->ip6r_len;
Add a missing bounds check,+		ND_TCHECK(*p);
CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.,"+			hdrlen += printer(ndo, &nhdr, p);"
hncp_print_rec() validates each HNCP TLV to be within the declared as well as the on-the-wire packet space.,"+        if (i + 4 + optlen > length)
+            return -1;"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_nodeinfo_print()., 		ni6 = (const struct icmp6_nodeinfo *)dp;
CVE-2017-12992/RIPng: Clean up bounds checking.,-		if (j * sizeof(*ni) != length - 4)
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,-            vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 		ND_PRINT((ndo, "" %s"", ipaddr_string(ndo, &cp[len])));"
add some bounds checks,"+            if (vqp_obj_len != ETHER_ADDR_LEN)
+                goto trunc;"
don't print the address as an IPv4 address.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
"We've already advanced the pointer past the PAN ID, if present; it now points to the address, so don't add 2 to it.","-			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p + 2)));"
"Some of them are variable-length, with a field giving the total length, and therefore they can be shorter than 6 octets.","+    if (sysid_len > id_len)
+        sysid_len = id_len;"
CVE-2017-12901/EIGRP: Do more length checks.,+            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_at_int)) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         switch(vqp_obj_type) {
"rt6_print(), ah_print(), and esp_print() return -1 if they run up against the end of the packet while dissecting; if that happens, stop dissecting, don't try to fetch the next header value, because 1) *it* might be past the end of the packet and 2) we won't be using it in any case, as we'll be exiting the loop.","+			if (advance < 0)
+				return;"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+			ND_PRINT((ndo,"" status=(""));"
CVE-2017-13045/VQP: add some bounds checks.,"+            if (vqp_obj_len != 4)
+                goto trunc;"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;",+			nhdr.caplen = caplen;
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" status=(""));"
CVE-2017-13053/BGP: fix VPN route target bounds checks.,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
add some bounds checks,"+        if (vqp_obj_len > tlen)
+            goto trunc;"
Add the missing check.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,"                     ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));"
This fixes a buffer over-read,-	i -= (sizeof(struct rip6) - sizeof(struct netinfo6));
The LLDP parser in tcpdump before 4.9.2 has a buffer over-read in print-lldp.c:lldp_mgmt_addr_tlv_print().,-        if (tlen < oid_len) {
CVE-2017-13036/OSPFv3: Add a bounds check before fetching data.,+		ND_TCHECK_32BITS(&hellop->hello_options);
This fixes a buffer over-read, 	ui = EXTRACT_32BITS(tptr);
Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+			nhdr.len = length;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-            ND_TCHECK2(*msg_data, 4);"
The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print().," 			advance = esp_print(ndo, cp, len, (const u_char *)ip6, &enh, &padlen);"
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,         len = EXTRACT_16BITS(tptr+2);
Add more bounds checks.,+        ND_TCHECK(*ih);
Clean up bounds checking.,"-		if (trunc)
-			ND_PRINT((ndo, ""[|ripng]""));"
Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+			nhdr.caplen = caplen;
(for 4.9.3) CVE-2018-14466/Rx: fix an over-read bug,-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
"Add bounds checks,","+    if (len < stlv_len)
+      goto trunc;"
has a buffer over-read,-	ND_TCHECK(lshp->ls_type);
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
Move a test inside a loop.,"+		    ND_TCHECK2(tptr[0], 3);"
CVE-2017-12992/RIPng: Clean up bounds checking.,"-	if (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))
-		return;"
ieee802_11_print() tried to access the Mesh Flags subfield of the Mesh Control field to find the size of the latter and increment the expected 802.11 header length before checking it is fully present in the input buffer.,+		if (caplen < hdrlen + 1) {
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().,-            vec[0].len = hlen;
The DCCP parser in tcpdump before 4.9.3 has a buffer over-read in print-dccp.c:dccp_print_option()., 			if (optlen == 6)
don't print the address as an IPv4 address.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
Check for the presence of the entire IPv6 fragment header.,-	ND_TCHECK(dp->ip6f_offlg);
The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,"-					ND_PRINT((ndo, ""<LOOP>""));"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
The DCCP parser in tcpdump before 4.9.3 has a buffer over-read in print-dccp.c:dccp_print_option().," 			else if (optlen == 4)
 				ND_PRINT((ndo, "" %u"", EXTRACT_16BITS(option + 2)));"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.",+			switch (optlen) {
CVE-2017-12992/RIPng: Clean up bounds checking.,"-		if (trunc)
-			ND_PRINT((ndo, ""[|ripng]""));"
(for 4.9.3) CVE-2018-14469/ISAKMP: Add a missing bounds check.,+			ND_TCHECK_32BITS(cp);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         optlen = EXTRACT_16BITS(tlv + 2);
Fix printing of ISAKMPv1 Notification payload data.,"+				ND_PRINT((ndo,"")""));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-            int name_entries_valid = 0;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-			if (len < 20)
-				ND_PRINT((ndo,"" len=%d [bad: < 20]"", len));"
The VTP parser in tcpdump before 4.9.2 has a buffer over-read in print-vtp.c:vtp_print().," 	ND_PRINT((ndo, "", Config Rev %x"", EXTRACT_32BITS(tptr)));"
"decode_multicast_vpn() didn't implement the Source AS field of that structure properly, adjust the offsets to put it right.",+            pptr += BGP_VPN_RD_LEN + 4;
This fixes a buffer over-read,"                        isonsap_string(ndo, tptr, alen)));"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.","-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_DIGEST_MIN_LEN);"
Ryan Ackroyd had independently identified this buffer over-read later by means of fuzzing and provided the packet capture file for the test., 			if (optlen == 6)
The LLDP parser in tcpdump before 4.9.2 has a buffer over-read in print-lldp.c:lldp_private_8023_print().,"         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
This fixes a buffer over-read,-	uint8_t  ip6r0_segleft;
CVE-2017-13688/OLSR: Do bounds checks before we fetch data.,"+            ND_TCHECK2(*msg_data, 4);"
CVE-2017-12901/EIGRP: Do more length checks.,+            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_ip_int)) {
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+				ND_PRINT((ndo, "" (elapsed time %u)"", EXTRACT_16BITS(option + 6)));"
Several protocol parsers in tcpdump before 4.9.2 could cause a buffer overflow in util-print.c:bittok2str_internal().,+                    space_left -= string_size;
The LDP parser in tcpdump before 4.9.3 has a buffer over-read in print-ldp.c:ldp_tlv_print().,+	TLV_TCHECK(12);
CVE-2017-12902/Zephyr: Fix bounds checking.,+	if (!ND_TTEST(**pptr)) {
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,                         for (i = 0; i < tptr[1] * as_size; i += as_size) {
Add two missing bounds checks,"+	if (strcmp((const char *)(data1 + 2), PIPE_LANMAN_STR) == 0) {"
NULL pointer dereference,"+	crypt_password = crypt(password, user_password);"
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.,-				if (chars_processed >= data_size) {
This fixes a buffer over-read,"-					ND_PRINT((ndo, "" ?0x%04x?"", EXTRACT_16BITS(bp+2)));"
The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_extd_ip_reach().,"-        if (!ND_TTEST2(*tptr, 1))"
This addresses Include Security issue F12: [libpcap] Remote Packet Capture Daemon Null Pointer Dereference Denial of Service.,"-	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)"
CVE-2017-12901/EIGRP: Do more length checks.,+    if (len < sizeof(struct eigrp_common_header)) {
has buffer over-reads," 	smb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr);"
The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().,            if (*data <= 0x1F)
CVE-2017-13045/VQP: add some bounds checks.,"+        if (sizeof(struct vqp_obj_tlv_t) > tlen)
+            goto trunc;"
"After we advance the pointer by the length value in the buffer, make sure it points to something in the captured data.","+	ND_TCHECK2(*s, 1);"
Add more bounds checks.,"+            ND_TCHECK2(p[0], 2);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 	if (EXTRACT_16BITS(&bp->bp_secs))
 		ND_PRINT((ndo, "", secs %d"", EXTRACT_16BITS(&bp->bp_secs)));"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		if (j * sizeof(*ni) != length - 4)
-			ND_PRINT((ndo, "" ripng-req %d[%u]:"", j, length));"
Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst,-				plen+= (sizeof(struct rpcap_sockaddr) * 4);
CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data.,+			ND_TCHECK_16BITS(&bp[i+2]);
CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data,+			ND_TCHECK_16BITS(&bp[i+2]);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 		ip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));"
Add a missing bounds check in vrrp_print().,"+			if (in_cksum(vec, 1)) {"
CVE-2017-13689/IKEv1: Fix addr+subnet length check.,"+			if (len < 32)
+				ND_PRINT((ndo,"" len=%d [bad: < 32]"", len));"
The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
The IEEE 802.15.4 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_15_4.c:ieee802_15_4_if_print().,"-			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p + 2)));"
"When that happens, make sure to return from print_prefix() before trying to print the [still uninitialized] buffer.","+        if (plenbytes < 0)
+            return plenbytes;"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;",+			nhdr = *h;
CVE-2017-12900/Properly terminate all struct tok arrays.,"+    { 0, NULL}"
CVE-2017-13017/DHCPv6: Add a missing option length check., 		case DH6OPT_RECONF_MSG:
"Scan the list of netinfo6 entries based on the supplied packet length, without taking the captured length into account; let the aforementioned bounds checking handle that.","+		for (ni = rp->rip6_nets; length_left >= sizeof(*ni);
+		    length_left -= sizeof(*ni), ++ni) {
+			ND_TCHECK(*ni);"
The ICMP parser in tcpdump before 4.9.3 has a buffer over-read in print-icmp.c:icmp_print()., 				uint16_t icmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);
CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" attrs=(""));"
The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().," 			ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));"
add checks to make sure the subTLV fits within the TLV.,"+        if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
+          goto trunc;"
CVE-2017-13001/NFS: Don't copy more data than is in the file handle.,"+		if (stringlen > NFSX_V3FHMAX)
+			stringlen = NFSX_V3FHMAX;"
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-				unsigned_relts_print(ndo, EXTRACT_16BITS(bp));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);
The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,-				chars_processed++;
The LDP parser in tcpdump before 4.9.3 has a buffer over-read in print-ldp.c:ldp_tlv_print()., 	ui = EXTRACT_32BITS(tptr);
(for 4.9.3) CVE-2018-14463/VRRP: Add a missing bounds check in vrrp_print().,+				ND_TCHECK_16BITS(&bp[6]);
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (ATMTPROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong tplen>""));"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"     ND_PRINT((ndo, ""seq 0x%03x, Flags [%s], length %u"",
            (EXTRACT_16BITS(p))&0x0fff, 
            bittok2str(ppp_ml_flag_values, ""none"", *p & 0xc0),"
Add some missing bounds checks,+	ND_TCHECK(*ep);
CVE-2017-12900/Properly terminate all struct tok arrays.,"+    { 0, NULL }"
CVE-2017-13032/RADIUS: Check whether a byte exists before testing its value.,"+           if (length < 1)
+              goto trunc;"
In ikev1_n_print() check bounds before trying to fetch the replay detection status.,+			ND_TCHECK_32BITS(cp);
This fixes a stack exhaustion,"-                    if (!bgp_attr_print(ndo, atype, tptr, alen))"
The LDP parser in tcpdump before 4.9.3 has a buffer over-read in print-ldp.c:ldp_tlv_print().,-	TLV_TCHECK(8);
fix VPN route target bounds checks,+	ND_TCHECK_32BITS(pptr + 1);
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:xid_map_enter()., 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
Do bounds checking.,+    if (length < 2) {
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
Properly terminate all struct tok arrays.,"+    { 0, NULL }"
"Always print the SNPA, and flag it as such; only print it as a MAC address if it's 6 bytes long."," 		else
+			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
+			       snpal,
+			       linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal)));"
"This fixes a buffer overflow discovered by Bhargava Shastry, SecT/TU Berlin.",+                    space_left -= string_size;
The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().,-	len = dp->ip6r_len;
(for 4.9.3) CVE-2018-14880/OSPFv3: Fix a bounds check.,+	ND_TCHECK(lshp->ls_length);
CVE-2017-13027/LLDP: Fix a bounds check.,"+        if (tlen < 1U + oid_len) {
             return 0;
         }"
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",+    *endp = bp;
Don't fetch the length field from the header until after we've checked for the existence of a field at or after that field.,+	len = dp->ip6r_len;
Fix bounds checking.,+	    ND_TCHECK(rhp->rh_short.sh_flags);
This fixes a buffer over-read discovered by Kamil Frankowicz., 	if(length == 1 && bp[0]==0xff) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                 ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                        tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                        *(tptr + 5)));"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"")""));"
The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,-					return (NULL);
Add two bounds checks before fetching data,"+	if (!ND_TTEST(rp->rm_call.cb_vers))
+		return (0);"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header; pass an updated header, just as we do for PPI.",+			nhdr.caplen = caplen;
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check and could over-read the input buffer, put it right.'","         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
Identify the NET as such.,"+		if (netal != 0)
+			ND_PRINT((ndo, ""\n\t  NET (length: %u) %s"",
+			       netal,
+			       isonsap_string(ndo, neta, netal)));"
CVE-2017-12985/IPv6: Check for print routines returning -1 when running past the end.,"+            if (!ext_dp->icmp_length &&
+                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {"
Add missing bounds check.,+			ND_TCHECK(tptr[1]);
This fixes a buffer over-read,"-		if (trunc)
-			ND_PRINT((ndo, ""[|ripng]""));"
"We do bounds checks based on the TLV length, so if the TLV's length is too short, and we don't check for that, we could end up fetching data past the end of the TLV - including past the length of the captured data in the packet.",+				if (olen != 4) {
This fixes a buffer over-read discovered by Bhargava Shastry.,"                 ND_PRINT((ndo, ""%s  CT: %u"",
                        ident,
                        EXTRACT_32BITS(obj_tptr) & 0x7));"
"While we're at it, print a truncation error if the packets are truncated, rather than just, in effect, ignoring the result of the routines that print particular packet types.","+		ND_PRINT((ndo, ""%s"", tstr));"
This fixes a buffer over-read,"         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
                    sh->svc_id,"
Add more bounds checks.,"+        ND_TCHECK2(p[0], 3);"
In ikev1_n_print() check bounds before trying to fetch the replay detection status.," 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));"
"Don't pass the remaining caplen - that's too hard to get right, and we were getting it wrong in at least one case; just use ND_TTEST().",-	if (caplen <= 1) {
"After we advance the pointer by the length value in the buffer, make sure it points to something in the captured data.", 	s += (*s) + 1;
Enforce a limit on how many times bgp_attr_print() can recurse.,"+                    if (attr_set_level == 10)
+                        ND_PRINT((ndo, ""(too many nested levels, not recursing)""));"
Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
"Add bounds checks,","+    ND_TCHECK2(*(tptr), stlv_len);"
Add a bounds check and a comment to bgp_capabilities_print().,+                    ND_TCHECK_16BITS(opt + i + 2);
The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_is_reach_subtlv().,"-                ND_TCHECK2(*tptr, 4);"
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	if (l_strnstart(ndo, ""MSG"", 4, (const char *)bp, length)) /* A REQuest */
 		ND_PRINT((ndo, "" BEEP MSG""));"
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \0.,+	len = strlen (ptr);
"If decode_prefix6() returns a negative number, don't print buf.","         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));"
This fixes a buffer over-read discovered by Yannick Formaggio.," 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)
 			return;"
Add a missing bounds check in lmp_print_data_link_subobjs().,+	    ND_TCHECK_32BITS(obj_tptr + offset + 4);
In rx_cache_insert() and rx_cache_find() properly read the serviceId field of the rx_header structure as a 16-bit integer.,+	rxent->serviceId = EXTRACT_16BITS(&rxh->serviceId);
This fixes a buffer over-read,                            EXTRACT_16BITS(opt+i+2)&0xfff));
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print().," 			advance = rt6_print(ndo, cp, (const u_char *)ip6);"
(for 4.9.3) CVE-2018-14470/Babel: fix an existing length check.,"+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().," 			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
 				EXTRACT_16BITS(&bp[i+2]),
 				EXTRACT_16BITS(&bp[i+4])));"
CVE-2017-13054/LLDP: add a missing length check.,"+        if (tlv_len < 6) {
+            return hexdump;
+        }"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
CVE-2017-13688/OLSR: Do bounds checks before we fetch data.,"+            ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,"                 if (obj_tlen < sizeof(struct rsvp_obj_frr_t))
                     return-1;"
This fixes a buffer over-read discovered by Kim Gwan Yeong., 			if (cp[0] == ep - cp - 1) {
CVE-2017-13051/RSVP: fix bounds checks for UNI.,"+                    if(subobj_len < 4 || subobj_len > total_subobj_len)
                         goto invalid;"
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().,-            vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().,-            u_int name_entries = EXTRACT_16BITS(msg_data+2);
Add bounds checks when printing time stamp options.,"+		ND_TCHECK2(cp[len], hoplen);"
"When those functions tried to read 32 bits the extra 16 bits could be outside of the bounds checked in rx_print() for the rx_header structure, as serviceId is the last field in that structure.",-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_DIGEST_MIN_LEN);"
CVE-2017-13687/CHDLC: Improve bounds and length checks.,"+                if (length < 2)
+                    goto trunc;"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {"
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.","         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
                    sh->svc_id,"
This fixes a buffer over-read,-				if (*(bp+1) != 0) {
This fixes a buffer over-read,            if (length < 3)
Do bounds checking as we access items.,"+		for (ni = rp->rip6_nets; length_left >= sizeof(*ni);
+		    length_left -= sizeof(*ni), ++ni) {
+			ND_TCHECK(*ni);"
CVE-2017-13015/EAP: Add more bounds checks.,+                ND_TCHECK_8BITS(tptr + 5);
"The Zephyr parser in tcpdump before 4.9.2 has a buffer over-read in print-zephyr.c, several functions.","-    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
This fixes a buffer over-read,"-		        ND_TCHECK2(tptr[3], 8);"
CVE-2017-13016/ES-IS: Fix printing of addresses in RD PDUs.,"+		if (snpal == 6)
+			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
+			       snpal,
+			       etheraddr_string(ndo, snpa)));"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().," 			ND_PRINT((ndo, "" c %04x"", EXTRACT_32BITS(&dp[0])));"
This addresses Include Security issue F12: [libpcap] Remote Packet Capture Daemon Null Pointer Dereference Denial of Service.,"+	crypt_password = crypt(password, user_password);"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.",         len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
fix an existing length check,"+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
"In aoev1_reserve_print() check bounds, before trying to print an Ethernet address.","+		ND_TCHECK_LEN(cp, MAC_ADDR_LEN);"
CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
"It can fail, so make sure it doesn't before comparing its result with the password.","+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+				ND_PRINT((ndo, "" [optlen != 6 or 8 or 10]""));"
"In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo), put it right.","+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
This fixes a buffer over-read,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
CVE-2017-13020/VTP: Add some missing bounds checks.,+	    ND_TCHECK_8BITS(tptr);
"decode_multicast_vpn() didn't implement the Source AS field of that structure properly, adjust the offsets to put it right.","+            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         optlen = (uint8_t)tlv[1];
The IP parser in tcpdump before 4.9.2 has a buffer over-read in print-ip.c:ip_printts().," 	if (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)
 		ND_PRINT((ndo, ""[bad ptr %u]"", cp[2]));"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:xid_map_enter()., 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
This fixes a buffer over-read,"             ND_PRINT((ndo, ""\n\t    IOS version: %u.%u, EIGRP version %u.%u"",
                    tlv_ptr.eigrp_tlv_sw_version->ios_major,"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"")""));"
"Fix the bounds checking for the NFSv3 WRITE procedure to check whether the length of the opaque data being written is present in the captured data, not just whether the byte count is present in the captured data.",-				ND_TCHECK(dp[2]);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 		ND_PRINT((ndo, ""%s%d@%s"", type, EXTRACT_32BITS(&cp[len+hoplen-4]),
 		       hoplen!=8 ? """" : ipaddr_string(ndo, &cp[len])));"
CVE-2017-12994/BGP: Move a test inside a loop.,"-		ND_TCHECK2(tptr[0], 3);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",           len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;
Do some additional length checks while we're at it.,"+		        if (length < 8)
+		            goto trunc;"
don't print the address as an IPv4 address.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;",+			nhdr.len = length;
CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data,+			ND_TCHECK_16BITS(&bp[i+4]);
CVE-2017-13015/EAP: Add more bounds checks.,+        ND_TCHECK_16BITS(tptr+2);
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.",+	ND_TCHECK(*k);
The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,"                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio,"
In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo),"+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
CVE-2017-13047/ES-IS: put an existing bounds check right.,+                    ND_TCHECK(*tptr);
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-          ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN);"
Fix printing of ISAKMPv1 Notification payload data.,"+				ND_PRINT((ndo,"")""));"
The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv6_print().,         optlen = EXTRACT_16BITS(tlv + 2);
CVE-2017-13042/HNCP: add DHCPv6-Data bounds checks.,"+        if (i + 4 > length)
+            return -1;"
don't print the address as an IPv4 address.,=B105
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",+    *endp = bp;
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,-				ND_TCHECK(dp[2]);
CVE-2017-12993/Juniper: Add more bounds checks.,"+            ND_TCHECK2(p[0], 2);"
This fixes a buffer over-read,"-    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().,         switch(vqp_obj_type) {
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.,"-					ND_PRINT((ndo, ""<LOOP>""));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	else if (ATMTPROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong tplen>""));"
Don't crash if crypt() fails.,+	if (crypt_password == NULL)
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header; pass an updated header, just as we do for PPI.","+			hdrlen += printer(ndo, &nhdr, p);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",           tptr = tptr + 2;
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.",+        while (stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
This fixes an infinite loop, 			while (cp < ep && cp < ep2) {
CVE-2017-13005/NFS: Add two bounds checks before fetching data.,"+	if (!ND_TTEST(rp->rm_call.cb_proc))
+		return (0);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 			tp = (const u_char *)(dh6o + 1);
CVE-2017-12991/BGP: Add missing bounds check.,+			ND_TCHECK(tptr[1]);
CVE-2017-12902/Zephyr: Fix bounds checking.,"+	if (*len == 0) {
+	    return NULL;
+	}"
sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.,"+                              total_length,"
"Always print the SNPA, and flag it as such; only print it as a MAC address if it's 6 bytes long.","+		if (snpal == 6)
+			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
+			       snpal,
+			       etheraddr_string(ndo, snpa)));"
(for 4.9.3) SMB: Add two missing bounds checks,"+	ND_TCHECK2(*(data1 + 2), strlen(PIPE_LANMAN_STR) + 1);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","             ND_PRINT((ndo, ""\n\t  Version %u, Entries %u%s"",
                    EXTRACT_16BITS(msg_data),
                    name_entries, (name_entries_valid == 0) ? "" (invalid)"" : """"));"
CVE-2017-13687/CHDLC: Improve bounds and length checks.,"+	if (length < CHDLC_HDRLEN)
+		goto trunc;"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.","-          ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN);"
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
Do bounds checking as we access items.,+	ND_TCHECK(rp->rip6_cmd);
CVE-2017-12992/RIPng: Clean up bounds checking.,"-	if (ndo->ndo_snapend < dat)
-		return;"
This fixes a buffer over-read,         tlv_tlen=eigrp_tlv_len-sizeof(struct eigrp_tlv_header);
CVE-2017-13045/VQP: add some bounds checks.,+        ND_TCHECK(*vqp_obj_tlv);
Ryan Ackroyd had independently identified this buffer over-read later by means of fuzzing and provided the packet capture file for the test.," 			else if (optlen == 4)
 				ND_PRINT((ndo, "" %u"", EXTRACT_16BITS(option + 2)));"
CVE-2017-13690/IKEv2: Fix some bounds checks.,-	ND_TCHECK(*ext);
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-				ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(bp)));"
CVE-2017-13687/CHDLC: Improve bounds and length checks.,+                ND_TCHECK_16BITS(p);
This fixes a buffer over-read,"             ND_PRINT((ndo, ""\n\t    Cable-range: %u-%u, Router-ID %u"",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start),"
CVE-2017-12996/PIMv2: Make sure PIM TLVs have the right length.,+				if (olen != 2) {
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" attrs=(""));"
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""END"", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP END""));"
Fix some bounds checks.,+	ND_TCHECK(*idp);
Do more bounds checks.,"+	if (len < sizeof(*prep) || !ND_TTEST(*prep))
 		return (-1);"
"Check for running out of packet data before checking for running out of captured data, and distinguish between running out of packet data (which might just mean ""no more strings"") and running out of captured data (which means ""truncated"").","+	if (*len == 0) {
+	    return NULL;
+	}"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-	amt = ndo->ndo_snapend - dat;
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+			ND_PRINT((ndo,"")""));"
In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo),-                if(len < 1)
This fixes a buffer over-read, 	ft_flags = EXTRACT_16BITS(tptr);
This fixes a buffer over-read,-		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
CVE-2017-13055/IS-IS: fix an Extended IS Reachability sub-TLV.,"+            if (subl == 0)
+                break;"
The OSPFv3 parser in tcpdump before 4.9.3 has a buffer over-read in print-ospf6.c:ospf6_print_lshdr().,-	ND_TCHECK(lshp->ls_seq);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options."," 			else
+				ND_PRINT((ndo, "" [optlen != 6]""));"
Several protocol parsers in tcpdump before 4.9.2 could cause a buffer overflow in util-print.c:bittok2str_internal().,+                    space_left -= string_size;
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",+    *endp = bp;
"The White Board protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-wb.c:wb_prep(), several functions."," 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)
 			return;"
(for 4.9.3) SMB: Add two missing bounds checks,"+	ND_TCHECK2(*(data1 + 2), strlen(MAILSLOT_BROWSE_STR) + 1);"
CVE-2017-13045/VQP: add some bounds checks.,"+        if (vqp_obj_len > tlen)
+            goto trunc;"
The ISO ES-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:esis_print().,             pptr += opli;
CVE-2017-13034/PGM: Add a bounds check.,+	    ND_TCHECK_16BITS(bp);
This fixes a buffer over-read,         extracted_ethertype = EXTRACT_16BITS(p);
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().,+                vec[0].len = hlen;
Add a missing length check.,"+	        ND_TCHECK2(*tptr, alen);"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"" status=(""));"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+    if (len < stlv_len)
+      goto trunc;"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                 ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));"
Add two bounds checks before fetching data, 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
"This fixes a buffer overflow discovered by Bhargava Shastry, SecT/TU Berlin.","-                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
-                                     sepstr, lp->s);"
"While we're at it, print a truncation error if the packets are truncated, rather than just, in effect, ignoring the result of the routines that print particular packet types.","+		ND_PRINT((ndo, ""%s"", tstr));"
The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
The DECnet parser in tcpdump before 4.9.2 has a buffer over-read in print-decnet.c:decnet_print()., 	    mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
CVE-2017-12897/ISO CLNS: Use ND_TTEST() for the bounds checks in isoclns_print().,+	if (!ND_TTEST(*p)) {
This fixes a buffer over-read,"-		    ND_TCHECK2(tptr[3], length - 3);"
The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_is_reach_subtlv().,                 bw.i = EXTRACT_32BITS(tptr);
"While we're at it, clean up some other bounds checks, so we check that we have a complete IPv4 message header if it's IPv4 and a complete IPv6 message header if it's IPv6.","-            ND_TCHECK2(*msg_data, 4);"
CVE-2017-13012/ICMP: Add a missing bounds check.,+		ND_TCHECK_16BITS(&ip->ip_len);
CVE-2017-13028/BOOTP: Add a bounds check before fetching data,+	ND_TCHECK(bp->bp_flags);
CVE-2017-12985/IPv6: Check for print routines returning -1 when running past the end.,"+                       in_cksum(vec, 1) ? ""in"" : """",
+                       hlen));"
The PGM parser in tcpdump before 4.9.2 has a buffer over-read in print-pgm.c:pgm_print()., 	    switch (EXTRACT_16BITS(bp)) {
This fixes a buffer over-read discovered by Henri Salo from Nixu Corporation., 			temp = EXTRACT_32BITS(bp);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-            u_int name_entries = EXTRACT_16BITS(msg_data+2);
This fixes a buffer over-read,"         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "",
                    EXTRACT_32BITS(&mh->service_id),"
The Cisco HDLC parser in tcpdump before 4.9.2 has a buffer over-read in print-chdlc.c:chdlc_print().,"-        return (chdlc_print(ndo, p,length));"
