text,code
"The aarch64_ext_ldst_reglist function in opcodes/aarch64-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+  if (value >= ARRAY_SIZE (data))
+    return 0;"
Fix seg-faults in objdump when disassembling a corrupt versados binary.,-         int offsetlen = flag & 0x7;
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
x86: Check for valid PLT section size Update x86 get_synthetic_symtab to check for valid PLT section size before examining PLT section contents.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-         int offsetlen = flag & 0x7;
Check for the index exceeding OP_BUF_LEN.,+#define GETBYTE() (ld->rl78->n_bytes < (OP_BUF_LEN - 1) ? ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr): 0)
Handle archives with corrupt extended name tables.,"+      if (amt > (bfd_size_type) bfd_get_size (abfd))
+       goto byebye;"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-         char hdr[8];
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347, rloc + reloc_size will cause integer overflow in line 13348.", 	  rloc = start + rp->r_offset;
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  size = bfd_get_section_size (sect);
Fix handling of corrupt STABS enum type strings.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
"The disassemble_bytes function in objdump.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of rae insns printing for this file during ""objdump -D"" execution.","-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
Fix address violation when disassembling a corrupt binary.,"-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
Fix a seg-fault triggered by reading a mal-formed archive.,"       if (amt + 1 == 0)
        goto byebye;"
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
Check for corrupt NAME:VALUE pairs.,"+      while (*p != ':' && *p != 0)
        ++p;"
Fix null pointer dereference when parsing a corrupt ELF binary.,          idx = (Elf_Internal_Group *) shdr->contents;
(alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix handling of corrupt STABS enum type strings.,"+      while (*p != ':' && *p != 0)
        ++p;"
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,-                 char datum = * ((char *) eopt + offset + len);
Check for corrupt NAME:VALUE pairs.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-             ent = print_mips_got_entry (data, pltgot, ent, data_end);"
Add sentinel.,"static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
Fix seg-fault reading malformed archive.,+         bfd_ardata (abfd)->extended_names = NULL;
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
But it does not forbid directory traversal in the paths.,+         bfd_ardata (abfd)->extended_names_size = 0;
Pass num_syms to target_specific_reloc_handling.," static bfd_boolean
 target_specific_reloc_handling (Elf_Internal_Rela * reloc,
                                unsigned char *     start,
                                unsigned char *     end,
+                               Elf_Internal_Sym *  symtab,
+                               unsigned long       num_syms)"
Fix address violation when disassembling a corrupt binary.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
I have checked in a small patch that adds a check for a NULL buffer pointer and then repsonds appropriately.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".","-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-         if (byte_get (data + ent - pltgot, addr_size)
-             >> (addr_size * 8 - 1) != 0)"
Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.,   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
Fix address violations when atempting to parse fuzzed binaries.,-  if (bfd_get_section_size (sect) < 0x24)
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
Exit early if passed an empty string.,"+  if (*orig == 0)
+    return (bfd_vma) 0;"
PR 21933 * elf.c (elf_read_notes): Check for a note size of -1.,-  if (size <= 0)
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+           if (start + reloc->r_offset + 4 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);
+           else
+             byte_put (start + reloc->r_offset, value, 4);"
Clip index to prevent overflow.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
Fix seg-fault reading malformed archive.,"+      if (amt > (bfd_size_type) bfd_get_size (abfd))
+       goto byebye;"
Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[300];
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
readelf: Fix overlarge memory allocation when reading a binary with an excessive number of program headers.,"+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
Fix seg-fault reading malformed archive.,+         bfd_ardata (abfd)->extended_names_size = 0;
Detect over large section offsets in the DT_SYMTAB entry.,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Pass num_syms to target_specific_reloc_handling.,"+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.",-      if (plt == NULL)
Update check for invalid word offsets in ARM unwind information.,"+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
(alpha_vms_object_p): Check for a truncated record.,+       (alpha_vms_object_p): Check for a truncated record.
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+         if (res == res_base)
+           return FALSE;"
Clip index to prevent overflow.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
Check valid bnd register.,"+      if (reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
The elf_read_notesfunction in bfd/elf.c in GNU Binutils 2.29 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Fix stack buffer overflows when parsing corrupt ihex files.,-      char hdr[8];
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
PR binutils/21591 * versados.c (versados_mkobject): Zero the allocated tdata structure.,"+      tdata_type *tdata = bfd_zalloc (abfd, amt);"
(alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
PR binutils/21157 * stabs.c (parse_stab_enum_type): Check for corrupt NAME:VALUE pairs.,"+      while (*p != ':' && *p != 0)
        ++p;"
Fix a seg-fault triggered by reading a mal-formed archive.,       bfd_ardata (abfd)->extended_names_size = amt;
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347, rloc + reloc_size will cause integer overflow in line 13348.",-	  if ((rloc + reloc_size) > end || (rloc < start))
Fix out of bounds memory access when trying to allocate space for a note of size -1.,-  if (size <= 0)
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"Date: Wed, 29 Aug 2012 20:11:50 +0200 From: Florian Weimer <fw@...eb.enyo.de> To: oss-security@...ts.openwall.com Subject: CVE-2012-3509: objalloc_alloc integer overflows in libiberty Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.","+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
"GNU Binutils 2017-04-03 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash), related to the process_mips_specific function in readelf.c, via a crafted ELF file that triggers a large memory-allocation attempt.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
Pass num_syms to target_specific_reloc_handling.,"+  if (reloc)
+    {
+      reloc_type = get_reloc_type (reloc->r_info);
+      sym_index = get_reloc_symindex (reloc->r_info);
+    }"
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt_entry_size
+                           + lazy_plt->plt_entry_size)))"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-                 char datum = * ((char *) eopt + offset + len);
"Error in ""OP_G"": global-buffer-overflow",       oappend (names64[modrm.reg + add]);
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+      if (modrm.reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
Check for the source pointer exceeding the end pointer before the first byte is read.,"+  if (src >= endp)
+    return FALSE;"
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,-                 char datum = * ((char *) eopt + offset + len);
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
Check for symbol table overflow before accessing symbol value.,"+           if (sym_index >= num_syms)
+             error (_(""MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             saved_sym = symtab + sym_index;
            return TRUE;"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix handling of corrupt STABS enum type strings.,"       name = savestring (*pp, p - *pp);"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
ld * testsuite/ld-nds32/diff.d: Adjust expected output.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, non_lazy_plt->plt_entry,"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
But it does not forbid directory traversal in the paths.,+         bfd_ardata (abfd)->extended_names = NULL;
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+         if (res == res_base)
+           return FALSE;"
Check for buffer overrun when printing out rae insns.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
"Fix read-after-free error in readelf when processing multiple, relocated sections in an MSP430 binary.","-         if (target_specific_reloc_handling (rp, start, end, symtab))"
(rl78_decode_opcode): Use OP_BUF_LEN as the length of the op_buf array.,+  unsigned char op_buf[OP_BUF_LEN] = {0};
Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[512];
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plt == NULL || plt->size == 0)
        continue;"
"readelf.c in GNU Binutils 2017-04-12 has a ""shift exponent too large for type unsigned long"" issue, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted ELF file.",-       unsigned long  val = 0;
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+         if (srcp + esdids + offsetlen >= endp)
+           return;"
"fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.",-  if (saved_file == NULL || file != saved_file)
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (memory consumption) via a crafted ELF file with many program headers, related to the get_program_headers function in readelf.c.","+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
"readelf: fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  if (size < 0x24)
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-                 char datum = * ((char *) eopt + offset + len);
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-         char hdr[8];
"Unavailable data is handled gracefully in MIPS GOT processing done by `print_mips_got_entry', so all that is needed in special GOT[1] handling is to verify whether data can be retrieved for the purpose of the GNU marker check done with `byte_get'.","+      if (data
+         && data + ent - pltgot + addr_size <= data_end
+         && (byte_get (data + ent - pltgot, addr_size)
+             >> (addr_size * 8 - 1)) != 0)"
Use to check for corrupt pair relocs.,"+         if (res == res_base)
+           return FALSE;"
PR other/54411: integer overflow in objalloc_alloc 2012-09-18 Florian Weimer <fweimer@redhat.com> PR other/54411 * objalloc.h (objalloc_alloc): Do not use fast path on wraparound.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-      char hdr[8];
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,"   inote.namesz = H_GET_32 (abfd, enote->namesz);"
PR binutils/21157 * stabs.c (parse_stab_enum_type): Check for corrupt NAME:VALUE pairs.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
Prevent address violation problem when disassembling corrupt aarch64 binary.,"+  if (value >= ARRAY_SIZE (data))
+    return 0;"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"Multiple integer overflows in the (1) _objalloc_alloc function in objalloc.c and (2) objalloc_alloc macro in include/objalloc.h in GNU libiberty, as used by binutils 2.22, allow remote attackers to cause a denial of service (crash) via vectors related to the ""addition of CHUNK_HEADER_SIZE to the length,"" which triggers a heap-based buffer overflow.",   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
PR binutils/20892 * aoutx.h (find_nearest_line): Handle the case where the function name is empty.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"opcodes/rl78-decode.opc in GNU Binutils 2.28 has an unbounded GETBYTE macro, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-#define GETBYTE() (ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr))
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",       oappend (names_bnd[modrm.reg]);
"Error in ""OP_G"": global-buffer-overflow",       oappend (names_bnd[modrm.reg]);
"The ieee_object_p function in bfd/ieee.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, might allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  unsigned char buffer[300];
Check for the index exceeding OP_BUF_LEN.,+#define GETBYTE() (ld->rl78->n_bytes < (OP_BUF_LEN - 1) ? ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr): 0)
"GNU assembler in GNU Binutils 2.28 is vulnerable to a global buffer overflow (of size 1) while attempting to unget an EOF character from the input stream, potentially leading to a program crash.","+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
"The _bfd_vms_slurp_etir function in bfd/vms-alpha.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",+      if (cmd_length < 4 || (ptr + cmd_length > maxptr + 4))
Clip index to prevent overflow.,"+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
"The ieee_archive_p function in bfd/ieee.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, might allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  unsigned char buffer[512];
"Remove the extra error reporting code then, introduced with commit 75ec1fdbb797 (""Fix runtime seg-fault in readelf when parsing a corrupt MIPS binary."")",-         if (data + ent - pltgot > data_end - addr_size)
PR gas/20898 * app.c (do_scrub_chars): Do not attempt to unget EOF.,"+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,+  size = bfd_get_section_size (sect);
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,-                 char datum = * ((char *) eopt + offset + len);
readelf: Update check for invalid word offsets in ARM unwind information.,"+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","-                 && (memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"Error in ""sh_elf_set_mach_from_flags"": global-buffer-overflow",-  if (flags >= sizeof(sh_ef_bfd_table))
PR binutils/21379 * readelf.c (process_dynamic_section): Detect over large section offsets in the DT_SYMTAB entry.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
PR 21957 * elf.c (setup_group): Check for an empty or very small group section.,"+         if (idx == NULL || shdr->sh_size < 4)
+           {
+             _bfd_error_handler (_(""%B: group section '%A' has no contents""),
+                                 abfd, shdr->bfd_section);
+             elf_tdata (abfd)->group_sect_ptr[i] = NULL;
+             bfd_set_error (bfd_error_bad_value);
+             return FALSE;
+           }"
Fix a seg-fault disassembling a corrupt binary.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-             error (_(""Invalid got entry - %#lx - overflows GOT table\n""),
-                    (long) ent);"
Pass num_syms to target_specific_reloc_handling.,"+                   if (start + reloc->r_offset + reloc_size >= end)
+                     error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                            start + reloc->r_offset + reloc_size, end);"
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,+  size = bfd_get_section_size (sect);
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MN10300 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
Fix shift overflow when parsing an overlarge note value.,"+       if (bytes > sizeof (val))
+         {
+           error (_(""corrupt name field: namesz of %lu is too large for a numeric value\n""),
+                  pnote->namesz);
+           return FALSE;
+         }"
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  size = bfd_get_section_size (sect);
"The setup_group function in elf.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a group section that is too small.","+         if (idx == NULL || shdr->sh_size < 4)
+           {
+             _bfd_error_handler (_(""%B: group section '%A' has no contents""),
+                                 abfd, shdr->bfd_section);
+             elf_tdata (abfd)->group_sect_ptr[i] = NULL;
+             bfd_set_error (bfd_error_bad_value);
+             return FALSE;
+           }"
(alpha_vms_object_p): Check for a truncated record.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
"Error in ""rl78_decode_opcode"": stack-buffer-overflow",-#define GETBYTE() (ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr))
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
"The getsym function in tekhex.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (stack-based buffer over-read and application crash) via a malformed tekhex binary.",   *srcp = src + i;
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt_entry_size
+                           + lazy_plt->plt_entry_size)))"
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  size = bfd_get_section_size (sect);
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
"Multiple integer overflows in the (1) _objalloc_alloc function in objalloc.c and (2) objalloc_alloc macro in include/objalloc.h in GNU libiberty, as used by binutils 2.22, allow remote attackers to cause a denial of service (crash) via vectors related to the ""addition of CHUNK_HEADER_SIZE to the length,"" which triggers a heap-based buffer overflow.","+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
bfd * mach-o.c (bfd_mach_o_canonicalize_relocs): Pass the base address of the relocs to the canonicalize_one_reloc routine.,"+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
* readelf.c (process_mips_specific): Fix incorrect escape sequence handling.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
Check for an invalid offset in the otr structure.,"+         if (srcp + esdids + offsetlen >= endp)
+           return;"
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,+                 if (j + bpc <= stop_offset * opb)
PR binutils/21582 * ieee.c (ieee_object_p): Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[300];
Subject: CVE-2012-3509: objalloc_alloc integer overflows in libiberty.,   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-         char hdr[8];
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix null pointer dereference when parsing a corrupt ELF binary.,"          if (shdr == NULL)
            continue;"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym1 = saved_sym2 = 0;
+           return TRUE;
+         }"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents,
                      non_lazy_ibt_plt->plt_entry,"
Check for an out of range value.,"+  if (value >= ARRAY_SIZE (data))
+    return 0;"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
readelf: Fix overlarge memory allocation when reading a binary with an excessive number of program headers.,"+  if (elf_header.e_phnum
+      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
+      >= current_file_size)
+    {
+      error (_(""Too many program headers - %#x - the file is not that big\n""),
+            elf_header.e_phnum);
+      return FALSE;
+    }"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+         if (res == res_base)
+           return FALSE;"
Add num_syms parameter.," static bfd_boolean
 target_specific_reloc_handling (Elf_Internal_Rela * reloc,
                                unsigned char *     start,
                                unsigned char *     end,
+                               Elf_Internal_Sym *  symtab,
+                               unsigned long       num_syms)"
Check for buffer overflow before writing relocated values.,"+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  if (section_headers != NULL
+      && (saved_file == NULL || file != saved_file))"
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
"When ""uvalue"" is a specific value,  ""block_start + uvalue"" will cause integer overflow.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.",-             goto got_print_fail;
binutils/ * readelf.c (process_mips_specific): Remove error reporting from GOT[1] processing.,-         if (data + ent - pltgot > data_end - addr_size)
Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
Check for buffer overrun when printing out rae insns.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
"Error in ""print_insn_score16"": global-buffer-overflow","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
Pass num_syms to target_specific_reloc_handling.,"+         if (target_specific_reloc_handling (rp, start, end, symtab, num_syms))
            continue;"
Fix a seg-fault triggered by reading a mal-formed archive.,"       bfd_ardata (abfd)->extended_names = (char *) bfd_zalloc (abfd, amt + 1);"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
"readelf.c in GNU Binutils 2017-04-12 has a ""cannot be represented in type long"" issue, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted ELF file.","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
PR 24829 * readelf.c (apply_relocations): Catch potential integer overflow whilst checking reloc location against section size.,+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",+         unsigned int offsetlen = flag & 0x7;
Pass num_syms to target_specific_reloc_handling.,"+           if (sym_index >= num_syms)
+             error (_(""RL78_SYM reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             {
+               saved_sym2 = symtab[sym_index].st_value;
+               saved_sym2 += reloc->r_addend;
+             }
            return TRUE;"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,+  if (size < 0x24)
(alpha_vms_object_p): Check for a truncated record.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,+       (alpha_vms_object_p): Check for a truncated record.
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,+  if (size < 0x24)
"The disassemble_bytes function in objdump.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of rae insns printing for this file during ""objdump -D"" execution.","-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
Fix incorrect escape sequence on platform with signed char.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+           if (start + reloc->r_offset + 2 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-                 char datum = * ((char *) eopt + offset + len);
The elf_read_notesfunction in bfd/elf.c in GNU Binutils 2.29 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file.,-  if (size <= 0)
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
Fix seg-fault when trying to disassemble a corrupt score binary.,"static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
PR binutils/21578 * elf32-sh.c (sh_elf_set_mach_from_flags): Fix check for invalid flag value.,"+  if (flags >= ARRAY_SIZE (sh_ef_bfd_table))
     return FALSE;"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+  if (section_headers != NULL
+      && (saved_file == NULL || file != saved_file))"
PR binutils/21345 * readelf.c (process_mips_specific): Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
"When ""uvalue"" is a specific value, ""block_start + uvalue"" will cause integer overflow.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names = NULL;
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+         if (res == res_base)
+           return FALSE;"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to the byte_get_little_endian function in elfcomm.c, the get_unwind_section_word function in readelf.c, and ARM unwind information that contains invalid word offsets.","+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
"Maybe it can fix like this:
   if ((rloc + reloc_size) > end || (rloc < start) || (rloc + reloc_size) < start)



Triggering the bug requires accurate input. I'm not sure the poc file can trigger a crash in your environment.",+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
Check for buffer overflow before writing relocated values.,"+           if (start + reloc->r_offset + 2 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);"
"The get_build_id function in opncls.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted file in which a certain size field is larger than a corresponding data field, as demonstrated by mishandling within the objdump program.",       oappend (names64[modrm.reg + add]);
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,-         char hdr[8];
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-      char hdr[8];
"The aarch64_ext_ldst_reglist function in opcodes/aarch64-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",   info->reglist.num_regs = data[value].num_regs;
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, non_lazy_plt->plt_entry,"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
"Which in turn will reset uvalue to a sane number, and so allow the rest of the code to continue.",+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  if (size < 0x24)
Fix out of bounds memory access when trying to allocate space for a note of size -1.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Pass num_syms to target_specific_reloc_handling.,"+               if (sym_index >= num_syms)
+                 error (_(""MN10300 reloc contains invalid symbol index %lu\n""),
+                        sym_index);"
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
PR gas/20898 * app.c (do_scrub_chars): Do not attempt to unget EOF.,"+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plt == NULL || plt->size == 0)
        continue;"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  if (size < 0x24)
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
PR 21933 * elf.c (elf_read_notes): Check for a note size of -1.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Check for symbol table overflow before accessing symbol value.,"+           if (sym_index >= num_syms)
+             error (_(""MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             saved_sym = symtab + sym_index;
            return TRUE;"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
Fix buffer overrun when parsing a corrupt tekhex binary.,   *srcp = src + i;
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
2012-09-18 Florian Weimer <fweimer@redhat.com> PR other/54411 * objalloc.h (objalloc_alloc): Do not use fast path on wraparound.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
Check for buffer overflow before writing relocated values.,"+         if (target_specific_reloc_handling (rp, start, end, symtab))
            continue;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.",-      if (plts[j].type == plt_unknown)
(rl78_decode_opcode): Use OP_BUF_LEN as the length of the op_buf array.,+  unsigned char op_buf[OP_BUF_LEN] = {0};
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,"   inote.type = H_GET_32 (abfd, enote->type);"
PR binutils/21378 * readelf.c (print_gnu_build_attribute_name): Check for an overlarge name field.,"+       if (bytes > sizeof (val))
+         {
+           error (_(""corrupt name field: namesz of %lu is too large for a numeric value\n""),
+                  pnote->namesz);
+           return FALSE;
+         }"
"The score_opcodes function in opcodes/score7-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",       oappend (names64[modrm.reg + add]);
"Error in ""bfd_get_string"": stack-buffer-overflow.",-  unsigned char buffer[512];
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,-      char hdr[8];
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Check valid bnd register.,"+      if (modrm.reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  size = bfd_get_section_size (sect);
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347,  rloc + reloc_size will cause integer overflow in line 13348. ",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
PR binutils/21591 * versados.c (versados_mkobject): Zero the allocated tdata structure.,+         unsigned int offsetlen = flag & 0x7;
Use to check for corrupt pair relocs.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-      char hdr[8];
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,-         char hdr[8];
PR binutils/17533 * archive.c (_bfd_slurp_extended_name_table): Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names_size = 0;
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
Check for buffer overflow before writing relocated values.,"+           if (start + reloc->r_offset + 4 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);
+           else
+             byte_put (start + reloc->r_offset, value, 4);"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
"fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
asan: arm-darwin: buffer overflow.,"+         if (res == res_base)
+           return FALSE;"
"The sh_elf_set_mach_from_flags function in bfd/elf32-sh.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  if (flags >= sizeof(sh_ef_bfd_table))
Avoid a possible compiler bug by using a static buffer instead of a stack local buffer.,+  static unsigned char buffer[300];
Detect over large section offsets in the DT_SYMTAB entry. ,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Clip index to prevent overflow.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
Pass num_syms to target_specific_reloc_handling.,"+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
Pass end to target_specific_reloc_handling.,"+         if (target_specific_reloc_handling (rp, start, end, symtab))
            continue;"
"The versados_mkobject function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not initialize a certain data structure, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","-      tdata_type *tdata = bfd_alloc (abfd, amt);"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  if (elf_header.e_phnum
+      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
+      >= current_file_size)
+    {
+      error (_(""Too many program headers - %#x - the file is not that big\n""),
+            elf_header.e_phnum);
+      return FALSE;
+    }"
"When integer overflow, these two statements have different judgment results.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/17533 * archive.c (_bfd_slurp_extended_name_table): Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names = NULL;
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
Fix check for source pointer walking off the end of the input buffer.,"+  for (i = 0; i < len && (src + i) < endp; i++)
     dstp[i] = src[i];"
Pass num_syms to target_specific_reloc_handling.,"+               if (sym_index >= num_syms)
+                 error (_(""MSP430 reloc contains invalid symbol index %lu\n""),
+                        sym_index);"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, lazy_plt->plt0_entry,"
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,   enote = (Elf_External_Note *) contents;
Pass num_syms to target_specific_reloc_handling.,+  unsigned long sym_index = 0;
avformat/rtmppkt: Check for packet size mismatches.,+                prev_pkt[channel_id].size);
"The decode_uncompressed function in libavcodec/faxcompr.c in FFmpeg before 2.8.2 does not validate uncompressed runs, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted CCITT FAX data.","+        if (*runs >= runend) {
+            av_log(avctx, AV_LOG_ERROR, ""uncompressed run overrun\n"");
+            return AVERROR_INVALIDDATA;
+        }"
avcodec/mjpegdec: Fix small picture upscale.,+                        line[w - 1] = line[(w - 1) / 3];
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckedNumeric<size_t>(bytes_per_entry);"
Fixes: use after free(),"         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
-                                        size2, mime);
+                                        size2, NULL);"
"Heap-based buffer overflow in libavformat/rtmppkt.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check for RTMP packet size mismatches.",     if (!prev_pkt[channel_id].read) {
The filter_slice function in libavfilter/vf_transpose.c in FFmpeg through 3.4.1 allows remote attackers to cause a denial of service (out-of-array access) via a crafted MP4 file.,-    for (plane = 0; out->data[plane]; plane++) {
avcodec/utvideodec: Add several out of array read related checks.,"+                if (c->control_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.,         size_t raw_bpp = s->bpp - byte_depth;
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",+            s->avctx->level   = level;
Fixes denial of service due to use of sscanf in inner loop for tag scaning. ,"-           if (sscanf(in+tag_close+1, ""%127[^<>]>%n"", buffer, &len) >= 1 && len > 0) {"
Fixes: out of array read. ,"                 if (slice_end < 0 || slice_end < slice_start ||
-                    bytestream2_get_bytes_left(&gb) < slice_end) {
+                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL)"
Fixes: out of array read. ,-                return AVERROR_INVALIDDATA;
swscale/utils: Clear pix buffers.,"+    FF_ALLOCZ_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg 3.0 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.,"         av_log(ctx->avctx, AV_LOG_ERROR,"
"The ff_mpv_common_init function in libavcodec/mpegvideo.c in FFmpeg before 2.7.2 does not properly maintain the encoding context, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted MPEG data.","-    memset(&s->last_picture, 0, sizeof(s->last_picture));"
avformat/movenc: Do not pass AVCodecParameters in avpriv_request_sample.,"-                avpriv_request_sample(track->par, ""Multiple independent substreams"");"
"As a result, the variable ""item_num"" turns negative, bypassing the check for a large value.",+    if (item_num > 65536 || item_num < 0) {
avformat/rtpdec_h264: Fix heap-buffer-overflow.,"+        if (*value == 0 || value[strlen(value) - 1] == ',') {
            av_log(s, AV_LOG_WARNING, ""Missing PPS in sprop-parameter-sets, ignoring\n"");
            return 0;
        }"
FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.,         for (y = 0; y < s->height; ++y) {
avcodec/utvideodec: Add several out of array read related checks.,"+                    if ((bits + 1) * 8 > get_bits_left(&pbit))
+                        return AVERROR_INVALIDDATA;"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
Multiple integer underflows in the ff_mjpeg_decode_frame function in libavcodec/mjpegdec.c in FFmpeg before 2.7.2 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.,-                        ((uint16_t*)line)[w - 1] =
rawenc: Only accept the appropriate stream type for raw muxers.,"+    if (   s->oformat->audio_codec != AV_CODEC_ID_NONE
+        && s->streams[0]->codecpar->codec_type != AVMEDIA_TYPE_AUDIO) {
+        av_log(s, AV_LOG_ERROR, ""%s files have exactly one audio stream\n"",
+               s->oformat->name);
+        return AVERROR(EINVAL);
+    }"
Its easier to just avoid it and use only studio_profile.,"     if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
        !s->cur_pic.f                                                  ||
-       s->cur_pic.field_picture                                       ||
-       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO
+       s->cur_pic.field_picture
     )"
Fixes out of array access,"-    tile->coord[1][1] = FFMIN((tiley + 1) * s->tile_height + s->tile_offset_y, s->height);"
Fixes: out of array access.,ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));
Check ymin vs. h.,"+        for (y = 0; y < FFMIN(s->ymin, s->h); y++) {"
Do not trust the counts.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme SGPD count exceeds implementation limit."");"
Fixes: out of array read.,"             get_bits(gb, 8);"
This ensures that no stale pointers leak through on any path. ,"-    memset(&s->next_picture, 0, sizeof(s->next_picture));"
"When a crafted RL2 file, which claims a large ""frame_count"" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
The export function in libavfilter/vf_signature.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a long filename.,"-        strcpy(filename, sic->filename);"
avcodec/dnxhddec: Move mb height check out of non hr branch.,"+        if (ctx->mb_height > 68 ||
+            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
             av_log(ctx->avctx, AV_LOG_ERROR,
                    ""mb height too big: %d\n"", ctx->mb_height);
             return AVERROR_INVALIDDATA;
         }"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
Fixes: out of array read. ,"-                if (!mms->streams)
-                    return AVERROR(ENOMEM);"
There is a heap-buffer-overflow at libavfilter/vf_colorconstancy.c:282 in slice_get_derivative.,-    if (tags == 16 && i == 8) {
Fixes: out of array read. ,-            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
avcodec/mpeg4videodec: Check read profile before setting it.,"+    *profile = get_bits(gb, 4);"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
avcodec/jpeg2000dwt: Check ndeclevels before calling dwt_decode*().,"+    if (s->ndeclevels == 0)
+        return 0;"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.","+        av_log(NULL, AV_LOG_ERROR, ""RTMP packet size mismatch %d != %d\n"","
Fixes: Infinite loop.,             pes_header_data_length = avio_r8(pb);
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
avcodec/webp: Always set pix_fmt.,+    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
"The jpeg2000_read_main_headers function in libavcodec/jpeg2000dec.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 does not enforce uniqueness of the SIZ marker in a JPEG 2000 image, which allows remote attackers to cause a denial of service (out-of-bounds heap-memory access) or possibly have unspecified other impact via a crafted image with two or more of these markers.","+            if (s->ncomponents) {
+                av_log(s->avctx, AV_LOG_ERROR, ""Duplicate SIZ\n"");
+                return AVERROR_INVALIDDATA;
+            }"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init(). ,"-    memset(&s->current_picture, 0, sizeof(s->current_picture));"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.",-  int sample_count = reader->box_size() - reader->pos();
"The update_dimensions function in libavcodec/vp8.c in FFmpeg through 2.8.1, as used in Google Chrome before 46.0.2490.71 and other products, relies on a coefficient-partition count during multi-threaded operation, which allows remote attackers to cause a denial of service (race condition and memory corruption) or possibly have unspecified other impact via a crafted WebM file.",s->macroblocks_base       = av_mallocz((s->mb_width + s->mb_height * 2 + 1) *sizeof(*s->macroblocks));
Subject: [CVE-2017-15672]: ffmpeg: read out of bounds of buffer when it parsing an craft mp4 file.,-             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
"The allocate_buffers function in libavcodec/alac.c in FFmpeg before 2.7.2 does not initialize certain context data, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted Apple Lossless Audio Codec (ALAC) data.","+    for (ch = 0; ch < 2; ch++) {
+        alac->predict_error_buffer[ch]  = NULL;
+        alac->output_samples_buffer[ch] = NULL;
+        alac->extra_bits_buffer[ch]     = NULL;
+    }"
"Validates the set channel layout as well as verifies that the received layout to the function matches the reference layout, so that it matches the implemented re-ordering logic.",+    if (layout == AV_CH_LAYOUT_22POINT2) {
MSE: Fix moar mp4 parsing security bugs.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
avformat/mov: Check sample size.,"+                    if (sample_size > 0x3FFFFFFF) {
+                        av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\n"", sample_size);
+                        return;
+                    }"
avcodec/dnxhd_parser: Do not return invalid value from dnxhd_find_frame_end() on error.,"+                if (remaining <= 0) {
+                    remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
+                    if (remaining <= 0)
+                        continue;
                 }"
avcodec/msrledec: avcodec/msrledec: restructure msrle_decode_pal4() based on the line number instead of the pixel pointer.,+                    pic->data[0][line * pic->linesize[0] + pixel_ptr] = stream_byte & 0x0F;
avcodec/msrledec: avcodec/msrledec: restructure msrle_decode_pal4() based on the line number instead of the pixel pointer.,+                    pic->data[0][line * pic->linesize[0] + pixel_ptr] = stream_byte >> 4;
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->deblock_coefs    = NULL;
avformat/mvdec: Fix DoS due to lack of eof check.,"+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(count <= entries.max_size());
Fixes: out of array read. ,"-            if (mms->stream_num < MMS_MAX_STREAMS &&
-                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {"
Clear pointers in ff_rv34_decode_init_thread_copy().,+        r->cbp_chroma       = NULL;
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init().,"-    memset(&s->current_picture, 0, sizeof(s->current_picture));"
The read_gab2_sub function in libavformat/avidec.c in FFmpeg before 3.1.4 allows remote attackers to cause a denial of service (NULL pointer used) via a crafted AVI file.,"+            if (ast->sub_ctx->nb_streams != 1)
+                goto error;"
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.","-        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");"
avformat/cinedec: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
"The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.",+    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {
"Validates the set channel layout as well as verifies that the received layout to the function matches the reference layout, so that it matches the implemented re-ordering logic.","+    if (layout == PREFIX_FOR_22POINT2 && tags == 16 && i == 8) {
+        const uint8_t (*reference_layout_map)[3] = aac_channel_layout_map[12];
+        for (int j = 0; j < tags; j++) {
+            if (layout_map[j][0] != reference_layout_map[j][0] ||
+                layout_map[j][2] != reference_layout_map[j][2])
+                goto end_of_layout_definition;
+        }"
Fixes: out of array access.,"-    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+            int profile, level;"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->cbp_chroma       = NULL;
"In FFmpeg 2.4 and 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop).","+        if (reload_count > c->max_reload)
+            return AVERROR_EOF;"
Fixes out of array read.,-    if (s->cdef[0] < 0) {
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.","-  RCHECK(reader->Read4(&count) &&
-         reader->HasBytes(count * (reader->version() == 1 ? 8 : 4)));"
avcodec/jpeg2000dec: Clip all tile coordinates.,"+    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
Fixes: out of array read. ,"             v = get_bits(gb, 8);"
check segment duration value of EXTINF.,"+                if (duration < 0.001 * AV_TIME_BASE) {
+                    av_log(c->ctx, AV_LOG_WARNING, ""Cannot get correct #EXTINF value of segment %s,""
+                                    "" set to default value to 1ms.\n"", seg->url);
+                    duration = 0.001 * AV_TIME_BASE;
+                }"
The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.6 allows remote attackers to cause a denial of service (out-of-bounds array read access) via crafted JPEG 2000 data.,"-        for (x = 0; x < s->ncomponents; x++)
-            s->cdef[x] = x + 1;"
avcodec/hevc_ps: Check chroma_format_idc.,"+    if (sps->chroma_format_idc > 3U) {
+        av_log(avctx, AV_LOG_ERROR, ""chroma_format_idc %d is invalid\n"", sps->chroma_format_idc);
+        return AVERROR_INVALIDDATA;
+    }"
avcodec/dnxhddec: Move mb height check out of non hr branch.,         ctx->data_offset = 0x280;
swscale/utils: Clear pix buffers.,"-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
Fixes: division by 0.,+        if (track->timescale > UINT16_MAX || !track->par->channels) {
Do not trust the counts.,+  const size_t bytes_per_edit = reader->version() == 1 ? 20 : 12;
The svg_probe function in libavformat/img2dec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (Infinite Loop) via a crafted XML file.,-        b += ff_subtitles_next_line(b);
"These 2 fields are not always the same, it is simpler to always use the same field for detecting studio profile.","+            if (c->mpeg4_studio_profile)
                 c->idct_put              = ff_simple_idct_put_int32_10bit;"
"In line libavcodec/h264dec.c:500 in libav(v13_dev0), ffmpeg(n3.4), chromium(56 prior Feb 13, 2017), the return value of init_get_bits is ignored and get_ue_golomb(&gb) is called on an uninitialized get_bits context, which causes a NULL deref exception. ","-            ret = init_get_bits8(&gb, nal->data + 1, (nal->size - 1));"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    *profile = get_bits(gb, 4);"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.",+    s->buf = av_malloc(s->buf_size);
cbs_jpeg_split_fragment in libavcodec/cbs_jpeg.c in FFmpeg 4.1 and 4.2.2 has a heap-based buffer overflow during JPEG_MARKER_SOS handling because of a missing length check.,"+            if (length > end - start)
+                return AVERROR_INVALIDDATA;"
avcodec/utvideodec: Add several out of array read related checks.,"+                if (c->packed_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
"FFmpeg through 4.2 has a ""Conditional jump or move depends on uninitialised value"" issue in h2645_parse because alloc_rbsp_buffer in libavcodec/h2645_parse.c mishandles rbsp_buffer.","     if (rbsp->rbsp_buffer_alloc_size >= size &&
-        (!rbsp->rbsp_buffer_ref || av_buffer_is_writable(rbsp->rbsp_buffer_ref)))
+        (!rbsp->rbsp_buffer_ref || av_buffer_is_writable(rbsp->rbsp_buffer_ref))) {
+        av_assert0(rbsp->rbsp_buffer);
+        memset(rbsp->rbsp_buffer + min_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
         return;
+    }"
Fixes out of array access,"-    tile->coord[0][0] = FFMAX(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x);"
Fix overheads in gauss array.,"                         dst[INDX2D(r, c, width)] += GAUSS(src, r,                        c + GINDX(filtersize, g),
-                                                          in_linesize, height, width, gauss[GINDX(filtersize, g)]);
+                                                          in_linesize, height, width, gauss[g]);"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init(). ,"-    memset(&s->next_picture, 0, sizeof(s->next_picture));"
avcodec/dnxhddec: Move mb height check out of non hr branch.,"+        if (ctx->mb_height > 68 ||
+            (ctx->mb_height << frame->interlaced_frame) > (ctx->height + 15) >> 4) {
             av_log(ctx->avctx, AV_LOG_ERROR,
                    ""mb height too big: %d\n"", ctx->mb_height);
             return AVERROR_INVALIDDATA;
         }"
"Incorrect check results in an integer underflow, which results in MOVAtoms of arbitrary sizes.",-            if (a.size == 1) {
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b2 + b6) >> 7)];
"FFmpeg 2.8 and 4.2.3 has a use-after-free via a crafted EXTINF duration in an m3u8 file because parse_playlist in libavformat/hls.c frees a pointer, and later that pointer is accessed in av_probe_input_format3 in libavformat/format.c.",-                seg->key_type = key_type;
avcodec/hevcdec: Avoid only partly skiping duplicate first slices.,"+            if (s->ref) {
+                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
+                goto fail;
+            }"
avcodec/jpeg2000dec: Clip all tile coordinates.,"+    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
avcodec/mpeg4videodec: Check idx in mpeg4_decode_studio_block().,"+            if (idx > 63)
+                return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Check idx in mpeg4_decode_studio_block().,"+            if (idx > 63)
+                return AVERROR_INVALIDDATA;"
Fixes: out of array read. ,         c->slices      = avctx->extradata[9] + 1;
But such solutions are fragile and tricky to implement portably and would not stop every possible attack nor would they work with all valid hls files.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
MSE: Fix moar mp4 parsing security bugs.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme SGPD count exceeds implementation limit."");"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(sample_count <= sample_depends_on_.max_size());
"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",-        return 1;
Write version 2 of audio atom if channels is not known. ,+        if (track->timescale > UINT16_MAX || !track->par->channels) {
"The ff_mpv_common_init function in libavcodec/mpegvideo.c in FFmpeg before 2.7.2 does not properly maintain the encoding context, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted MPEG data.","-    memset(&s->new_picture, 0, sizeof(s->new_picture));"
avcodec/ivi: Check image dimensions.,"+    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||
         cfg->luma_bands < 1 || cfg->chroma_bands < 1)"
This reduces the attack surface of local file-system information leaking.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+            } else if (s->studio_profile) {
+                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
+                return AVERROR_PATCHWELCOME;
             }"
"In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    err = init_get_bits8(&gb, buf, size);"
There's a division by zero at libavcodec/aaccoder.c:554 and 556.,"+            s->lambda = av_clipf(s->lambda * ratio, FLT_MIN, 65536.f);"
avformat/nsvdec: Fix DoS due to lack of eof check in nsvs_file_offset loop.,"+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
"The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.",-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
+                (level > 0 && level < 9)) {"
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 7*stride] = av_clip_uint8( dst[i + 7*stride] + ((b0 - b4) >> 7));
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->mb_type          = NULL;
Fixes: out of array access. ,             dst[y * linesize + x] = clr;
Clear pointers in ff_rv34_decode_init_thread_copy().,+        r->deblock_coefs    = NULL;
Fixes out of array access. ,"+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);"
"Since non-Haar wavelets need to look into pixels outside the frame, we need to pad the buffer.","+    s->buffer = av_calloc((p_stride + slice_w)*(p_height + slice_h), sizeof(dwtcoef));"
Do not trust the counts.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme ELST count exceeds implementation limit."");"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
"In FFmpeg 3.2 and 4.0.1, an improper argument (AVCodecParameters) passed to the avpriv_request_sample function in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array read while converting a crafted AVI file to MPEG4, leading to a denial of service and possibly an information disclosure.","-                avpriv_request_sample(track->par, ""Multiple independent substreams"");"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.",+        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);
avcodec/jpeg2000dec: More completely check cdef.,+        if (s->cdef[x] < 0) {
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.",-    if (s->ref && sh->first_slice_in_pic_flag) {
Do not trust the counts.,+  RCHECK(count <= edits.max_size());
mov: Fix negative size calculation in mov_read_default().,+            if (a.size == 1 && total_size + 8 <= atom.size) {
Fixes: out of array accesses.,"-                if (delta > data_len[j]) {
-                    return AVERROR_INVALIDDATA;
-                }"
avcodec/mpeg4videodec: Check read profile before setting it.,"+            } else if (s->studio_profile) {
+                avpriv_request_sample(s->avctx, ""Mixes studio and non studio profile\n"");
+                return AVERROR_PATCHWELCOME;
             }"
FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.,+        zstream.avail_out = buf_size - 1;
Fixes out of array access,"-    tile->coord[0][1] = FFMIN((tilex + 1) * s->tile_width  + s->tile_offset_x, s->width);"
avcodec/mpeg4videodec: Check read profile before setting it.,"+            int profile, level;"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.",+                prev_pkt[channel_id].size);
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(count <= edits.max_size());
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b3 - b7) >> 7)];
Fixes out of array access. ,-        if (s->codec_id == AV_CODEC_ID_JV) {
avcodec/mpeg4videodec: Check read profile before setting it.,"+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)"
"The smka_decode_frame function in libavcodec/smacker.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 does not verify that the data size is consistent with the number of channels, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Smacker data.",+    if (unp_size % (avctx->channels * (bits + 1))) {
avformat/avidec: Fix infinite loop in avi_read_nikon().,+    while (avio_tell(s->pb) < end && !avio_feof(s->pb)) {
Fixes: out of array read. ,-            } else {
Crash Type: Stack-buffer-overflow WRITE 1.,"+        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }"
Fixes: out of array read. ,"             v = get_bits(gb, 8);"
Crash Type: Heap-buffer-overflow WRITE {*}.,+    if (s->width != avctx->width || s->height != avctx->height) {
avcodec/mpeg4videoenc: Use 64 bit for times in mpeg4_encode_gop_header().,"+    int64_t hours, minutes, seconds;"
Integer overflow in the asf_write_packet function in libavformat/asfenc.c in FFmpeg before 2.8.5 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PTS (aka presentation timestamp) value in a .mov file.,     pts *= 10000;
avcodec/h264: Clear delayed_pic on deallocation.,"+        memset(h->delayed_pic, 0, sizeof(h->delayed_pic));"
"libavcodec/webp.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not ensure that pix_fmt is set, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file, related to the vp8_decode_mb_row_no_filter and pred8x8_128_dc_8_c functions.",+    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  size_t sample_count = reader->box_size() - reader->pos();
There is a heap-buffer-overflow at libavfilter/vf_colorconstancy.c:282 in slice_get_derivative.,"+    if (layout == PREFIX_FOR_22POINT2 && tags == 16 && i == 8) {
+        const uint8_t (*reference_layout_map)[3] = aac_channel_layout_map[12];
+        for (int j = 0; j < tags; j++) {
+            if (layout_map[j][0] != reference_layout_map[j][0] ||
+                layout_map[j][2] != reference_layout_map[j][2])
+                goto end_of_layout_definition;
+        }"
The decode_init function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via an AVI file.,"         av_log(avctx, AV_LOG_DEBUG, ""Encoder version %d.%d.%d.%d\n"",
                avctx->extradata[3], avctx->extradata[2],
                avctx->extradata[1], avctx->extradata[0]);"
avformat/rtmppkt: Check for packet size mismatches.,+    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {
Fixes: use of uninitialized variables. ,"-            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,"
"The sdp_parse_fmtp_config_h264 function in libavformat/rtpdec_h264.c in FFmpeg before 3.3.4 mishandles empty sprop-parameter-sets values, which allows remote attackers to cause a denial of service (heap buffer overflow) or possibly have unspecified other impact via a crafted sdp file.","+        if (*value == 0 || value[strlen(value) - 1] == ',') {
            av_log(s, AV_LOG_WARNING, ""Missing PPS in sprop-parameter-sets, ignoring\n"");
            return 0;
        }"
Check for bitstream end in read_quant_matrix_ext(). ,"+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;"
Revert to zero-initializing buffers for FFmpegVideoDecoder.,+    const size_t num_planes = VideoFrame::NumPlanes(frame->format());
Fixes: assertion failure.,"+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
+        s->avctx->bits_per_raw_sample = 0;"
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,             pes_header_data_length = avio_r8(pb);
avcodec/utvideodec: Check subsample factors.,"+    if ((avctx->width  & ((1<<h_shift)-1)) ||
+        (avctx->height & ((1<<v_shift)-1))) {
+        avpriv_request_sample(avctx, ""Odd dimensions"");
+        return AVERROR_PATCHWELCOME;
+    }"
"When a crafted CINE file, which claims a large ""duration"" field in the header but does not contain sufficient backing data, is provided, the image-offset parsing loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Remove use of FF_PROFILE_MPEG4_SIMPLE_STUDIO as indicator of studio profile.,"     if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
        !s->cur_pic.f                                                  ||
-       s->cur_pic.field_picture                                       ||
-       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO
+       s->cur_pic.field_picture
     )"
Crash Type: Stack-buffer-overflow WRITE 1.,"+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);"
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 3*stride] = av_clip_uint8( dst[i + 3*stride] + ((b3 + b7) >> 7));
"Due to incorrect use of strtoll function > and integer sizes (chunk_size in int64_t)[2], it was possible to pass > negative chunk_size in chunk encoding, so after computing final size > using FFMIN function later on it would be passed as argument to > avio_read function.",+            av_assert0(len <= c->chunk_size);
FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.,"+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);"
libavformat/movenc.c in FFmpeg 3.2 and 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format.,-        if (track->timescale > UINT16_MAX) {
"In libavformat/nsvdec.c in FFmpeg 2.4 and 3.3.3, a DoS in nsv_parse_NSVf_header() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted NSV file, which claims a large ""table_entries_used"" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.","+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
"The ff_hevc_parse_sps function in libavcodec/hevc_ps.c in FFmpeg before 2.8.2 does not validate the Chroma Format Indicator, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted High Efficiency Video Coding (HEVC) data.","+    if (sps->chroma_format_idc > 3U) {
+        av_log(avctx, AV_LOG_ERROR, ""chroma_format_idc %d is invalid\n"", sps->chroma_format_idc);
+        return AVERROR_INVALIDDATA;
+    }"
avcodec/utvideodec: Add several out of array read related checks.,"+            if (3 * ((dst + send * stride - dest + 7)/8) > get_bits_left(&cbit))
+                return AVERROR_INVALIDDATA;"
SUMMARY: AddressSanitizer: stack-buffer-overflow.,"     int i, n, total_non_cc_elements;"
zero initialize the rbsp buffer. ,+    int min_size = size;
avcodec/utvideodec: Add several out of array read related checks.,"+                    if ((bits + 1) * 8 > get_bits_left(&pbit))
+                        return AVERROR_INVALIDDATA;"
avcodec/exr: Check tile positions.,"+        if (s->xmin || s->ymin) {
+            avpriv_report_missing_feature(s->avctx, ""Tiles with xmin/ymin"");
+            return AVERROR_PATCHWELCOME;
+        }"
avcodec/exr: Check tile positions.,"+        if (line < s->ymin || line > s->ymax ||
+            col  < s->xmin || col  > s->xmax)
+            return AVERROR_INVALIDDATA;"
Fixes out of array access.,         sbr->kx[0] = sbr->kx[1];
avformat/mxfdec: Fix av_log context.,"+                    av_log(mxf, AV_LOG_TRACE, ""could not resolve essence container data strong ref\n"");"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"When a crafted RL2 file, which claims a large ""frame_count"" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
Fixes: Out of array access. ,             j = scantable[idx++];
"he flv_write_packet function in libavformat/flvenc.c in FFmpeg through 2.8 does not check for an empty audio packet, leading to an assertion failure.","+    if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {
+        av_log(s, AV_LOG_WARNING, ""Empty audio Packet\n"");
+        return AVERROR(EINVAL);
+    }"
The decode_plane function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,"+            if (3 * ((dst + send * stride - dest + 7)/8) > get_bits_left(&cbit))
+                return AVERROR_INVALIDDATA;"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init().,"-    memset(&s->new_picture, 0, sizeof(s->new_picture));"
Its easier to just avoid it and use only studio_profile.,"     if (avctx->bits_per_raw_sample > 8) {
-        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
+        av_assert1(s->studio_profile);
         return avctx->pix_fmt;
     }"
"But when using this structure in read_header() of libavcodec/ffv1dec.c, It will minus a bigger trailer than buf_size to read size through AV_RB24().",             int size = AV_RB24(p-trailer);
"In FFmpeg 2.4 and 3.3.3, the read_data function in libavformat/hls.c does not restrict reload attempts for an insufficient list, which allows remote attackers to cause a denial of service (infinite loop).","+        if (reload_count > c->max_reload)
+            return AVERROR_EOF;"
avformat/rl2: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
Fixes: NULL pointer dereference and out of array access.,-    if (s->ref && sh->first_slice_in_pic_flag) {
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",if (!copy->internal) {
avcodec/xwddec: Check bpp more completely.,"+        if (bpp == 1 && pixdepth == 1) {
             avctx->pix_fmt = AV_PIX_FMT_MONOWHITE;"
avcodec/ac3_parser: Check init_get_bits8() for failure.,"+    if (err < 0)
+        return AVERROR_INVALIDDATA;"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
"These 2 fields are not always the same, it is simpler to always use the same field for detecting studio profile.","+    if (s->codec_id == AV_CODEC_ID_MPEG4)
+        s->idsp.mpeg4_studio_profile = s->studio_profile;"
avformat/avidec: Fix memleak with dv in avi.,"+                if (s->streams[0]->internal)
+                    av_freep(&s->streams[0]->internal->avctx);"
avformat/asfenc: Check pts.,"+    if (   pts < - PREROLL_TIME
+        || pts > (INT_MAX-3)/10000LL * ASF_INDEXED_INTERVAL - PREROLL_TIME) {
+        av_log(s, AV_LOG_ERROR, ""input pts %""PRId64"" is invalid\n"", pts);
+        return AVERROR(EINVAL);
+    }"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.",+    s->buf = av_malloc(s->buf_size);
rawenc: Only accept the appropriate stream type for raw muxers.,"+    if (   s->oformat->video_codec != AV_CODEC_ID_NONE
+        && s->streams[0]->codecpar->codec_type != AVMEDIA_TYPE_VIDEO) {
+        av_log(s, AV_LOG_ERROR, ""%s files have exactly one video stream\n"",
+               s->oformat->name);
+        return AVERROR(EINVAL);
+    }"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    *level   = get_bits(gb, 4);"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.",+    if (prev_pkt[channel_id].read && size != prev_pkt[channel_id].size) {
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[0][1] = av_clip((tilex + 1) * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
"When a crafted RL2 file, which claims a large ""frame_count"" field in the header but does not contain sufficient backing data, is provided, the loops (for offset and size tables) would consume huge CPU and memory resources, since there is no EOF check inside these loops.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
Fix overheads in gauss array.,"                         dst[INDX2D(r, c, width)] += GAUSS(src, r + GINDX(filtersize, g), c,
-                                                          width, height, width, gauss[GINDX(filtersize, g)]);
+                                                          width, height, width, gauss[g]);"
avcodec/alac: Clear pointers in allocate_buffers().,"+    for (ch = 0; ch < 2; ch++) {
+        alac->predict_error_buffer[ch]  = NULL;
+        alac->output_samples_buffer[ch] = NULL;
+        alac->extra_bits_buffer[ch]     = NULL;
+    }"
Heap-based buffer overflow in the decode_block function in libavcodec/exr.c in FFmpeg before 3.1.3 allows remote attackers to cause a denial of service (application crash) via vectors involving tile positions.,"+        if (line < s->ymin || line > s->ymax ||
+            col  < s->xmin || col  > s->xmax)
+            return AVERROR_INVALIDDATA;"
Do not trust the counts.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckedNumeric<size_t>(bytes_per_entry);"
avcodec/mpeg4videodec: Check read profile before setting it.,"+            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&
+                (level > 0 && level < 9)) {"
swscale/utils: Clear pix buffers.,"-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b3 + b7) >> 7)];
Check for bitstream end in read_quant_matrix_ext(). ,"+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;"
It does not stop leaks via remote addresses in the LAN.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.",+    s->buf_size = avctx->width*avctx->height*2 + 1000;
"FFmpeg 2.8 and 4.2.3 has a use-after-free via a crafted EXTINF duration in an m3u8 file because parse_playlist in libavformat/hls.c frees a pointer, and later that pointer is accessed in av_probe_input_format3 in libavformat/format.c.",-                seg->duration = duration;
"The gmc_mmx function in libavcodec/x86/mpegvideodsp.c in FFmpeg 2.3 and 3.4 does not properly validate widths and heights, which allows remote attackers to cause a denial of service (integer signedness error and out-of-array read) via a crafted MPEG file.","+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
+                     (unsigned) iy >= height - h || height< h
+                     ;"
Fixes integer overflow. ,-    if (cfg->pic_width < 1 || cfg->pic_height < 1 ||
Fixes: out of array read. ,"-                av_log(NULL, AV_LOG_ERROR,
-                       ""Corrupt stream (too many A/V streams)\n"");"
There is a heap-buffer-overflow at libavfilter/vf_colorconstancy.c:282 in slice_get_derivative.,"                         dst[INDX2D(r, c, width)] += GAUSS(src, r,                        c + GINDX(filtersize, g),
-                                                          in_linesize, height, width, gauss[GINDX(filtersize, g)]);
+                                                          in_linesize, height, width, gauss[g]);"
avcodec/smacker: Check that the data size is a multiple of a sample vector.,+    if (unp_size % (avctx->channels * (bits + 1))) {
avformat/mxfdec: Fix Sign error in mxf_read_primer_pack().,+    if (item_num > 65536 || item_num < 0) {
"In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    if (err < 0)
+        return AVERROR_INVALIDDATA;"
Fixes out of array access. ,"+    if (sps->chroma_format_idc > 3U) {
+        av_log(avctx, AV_LOG_ERROR, ""chroma_format_idc %d is invalid\n"", sps->chroma_format_idc);
+        return AVERROR_INVALIDDATA;
+    }"
Fixes: out of array access.,if (buf_size < ctx->data_offset) {
Fixes out of array access.,"                    !memcmp(c->buffer_ptr - 1, ""\r\n"", 2)) {"
Fixes out of array access.,"         if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,
                                          size)) < 0)"
"The decode_uncompressed function in libavcodec/faxcompr.c in FFmpeg before 2.8.2 does not validate uncompressed runs, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted CCITT FAX data.","+        if (*runs >= runend) {
+            av_log(avctx, AV_LOG_ERROR, ""uncompressed run overrun\n"");
+            return AVERROR_INVALIDDATA;
+        }"
Previously we would accept malformed vp8 video files that had alpha and image planes with different dimensions.,"-             vpx_image->d_h,"
avcodec/msrledec: avcodec/msrledec: restructure msrle_decode_pal4() based on the line number instead of the pixel pointer.,"+    while (line >= 0 && pixel_ptr <= avctx->width) {
         if (bytestream2_get_bytes_left(gb) <= 0) {
             av_log(avctx, AV_LOG_ERROR,
-                   ""MS RLE: bytestream overrun, %d rows left\n"",
-                   row_ptr);
+                   ""MS RLE: bytestream overrun, %dx%d left\n"",
+                   avctx->width - pixel_ptr, line);
             return AVERROR_INVALIDDATA;
         }"
"The ff_mpv_common_init function in libavcodec/mpegvideo.c in FFmpeg before 2.7.2 does not properly maintain the encoding context, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted MPEG data.","-    memset(&s->current_picture, 0, sizeof(s->current_picture));"
The old factor of two seemed to be a workaround that fact and only padded to the left and bottom.,-    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));
avformat/rl2: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
swscale/utils: Clear pix buffers.,"-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"The decode_ihdr_chunk function in libavcodec/pngdec.c in FFmpeg before 2.7.2 does not enforce uniqueness of the IHDR (aka image header) chunk in a PNG image, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted image with two or more of these chunks.","+    if (s->state & PNG_IHDR) {
+        av_log(avctx, AV_LOG_ERROR, ""Multiple IHDR\n"");
+        return AVERROR_INVALIDDATA;
+    }"
block_cmp() in libavcodec/zmbvenc.c in FFmpeg 4.1.3 has a heap-based buffer over-read.,"-    prev_offset = FFALIGN(c->lrange, 16) + c->pstride * c->lrange;"
Fixes out of array access. ,-    for (plane = 0; out->data[plane]; plane++) {
Failure to verify causes total_size > atom.size which will result in negative size calculations later on.,-            if (a.size == 1) {
"The ff_get_buffer function in libavcodec/utils.c in FFmpeg before 2.8.4 preserves width and height values after a failure, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .mov file.",-    if (ret < 0)
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",+            copy->priv_data = NULL;
avformat/pva: Check for EOF before retrying in read_part_of_packet().,"+            if (avio_feof(pb)) {
+                return AVERROR_EOF;
+            }"
avcodec/utvideodec: Add several out of array read related checks.,"+                if (c->control_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Check read profile before setting it.,+            s->avctx->level   = level;
Fixes: division by 0.,-        if (track->timescale > UINT16_MAX) {
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+static int mpeg4_decode_profile_level(MpegEncContext *s, GetBitContext *gb, int *profile, int *level)"
Fixes: out of array read.,"             v = get_bits(gb, 8);"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_edit, static_cast<size_t>(count));"
"So it reads the front memory of bytestream, and get an error size.",             int size = AV_RB24(p-trailer);
avcodec/pngdec: Fix off by 1 size in decode_zbuf().,+        zstream.avail_out = buf_size - 1;
"libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.","+            if (y >= avctx->height)
+                return AVERROR_INVALIDDATA;"
avcodec/mjpegdec: Fix small picture upscale.,"+                        if (w > 1)
+                            ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[w - 1];"
Failure to verify causes total_size > atom.size which will result in negative size calculations later on.,-            if (a.size == 1) {
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  const size_t bytes_per_edit = reader->version() == 1 ? 20 : 12;
"Also use the alpha image stride when copying the alpha plane, because it technically doesn't have to be the same as the image stride.","+             vpx_image_alpha->stride[VPX_PLANE_Y],"
1. avcodec/ansi: Check dimensions.,"+    } else if (avctx->width % FONT_WIDTH || avctx->height % s->font_height) {
+        av_log(avctx, AV_LOG_ERROR, ""Invalid dimensions %d %d\n"", avctx->width, avctx->height);
+        return AVERROR(EINVAL);
     }"
Do not trust the counts.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,             j = scantable[idx++];
Fixes use of freed memory. ,         av_freep(&h->DPB);
Fixes out of array access.,-                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;
avformat/asfdec: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
"In FFmpeg 3.2 and 4.0.1, an improper argument (AVCodecParameters) passed to the avpriv_request_sample function in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array read while converting a crafted AVI file to MPEG4, leading to a denial of service and possibly an information disclosure.","+                avpriv_request_sample(mov->fc, ""Multiple independent substreams"");"
FFmpeg before commit bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 contains an out of array access vulnerability in MXF format demuxer that can result in DoS.,"                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {"
Fixes: NULL pointer dereference and out of array access.,         if (s->sh.first_slice_in_pic_flag) {
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(sample_count <= sample_depends_on_.max_size());
Fixes: null pointer dereference. ,"-    if (s->avctx->profile == 0 && s->avctx->level == 8) {
-        s->avctx->level = 0;"
"In FFmpeg 4.0.1, due to a missing check for negative values of the mquant variable, the vc1_put_blocks_clamped function in libavcodec/vc1_block.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to an information disclosure or a denial of service.",-        if (!mquant || mquant > 31) {                          \
Fixes out of array access. ,                         ptr = s->picture_ptr->data[c] + (linesize * (v * mb_y + y)) + (h * mb_x + x);
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b2 - b6) >> 7)];
"The ff_dwt_decode function in libavcodec/jpeg2000dwt.c in FFmpeg before 2.8.4 does not validate the number of decomposition levels before proceeding with Discrete Wavelet Transform decoding, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    if (s->ndeclevels == 0)
+        return 0;"
aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.,"-            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,"
"The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.","         if (c->palette_size != (1 << (c->bpp - 1)))
             return AVERROR_INVALIDDATA;"
Fixes: null pointer dereference. ,     hdr = *phdr;
Clear pointers in ff_rv34_decode_init_thread_copy().,+        r->cbp_luma         = NULL;
avformat/hls: Fix DoS due to infinite loop.,"+        if (reload_count > c->max_reload)
+            return AVERROR_EOF;"
"When a crafted MV file, which claims a large ""nb_frames"" field in the header but does not contain sufficient backing data, is provided, the loop over the frames would consume huge CPU and memory resources, since there is no EOF check inside the loop.","+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
"The h264_slice_header_init function in libavcodec/h264_slice.c in FFmpeg before 2.8.3 does not validate the relationship between the number of threads and the number of slices, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted H.264 data.","+    h->max_contexts = FFMIN(h->max_contexts, nb_slices);"
h264dec: handle zero-sized NAL units in get_last_needed_nal().,"+            if (ret < 0) {
+                av_log(h->avctx, AV_LOG_ERROR, ""Invalid zero-sized VCL NAL unit\n"");
+                if (h->avctx->err_recognition & AV_EF_EXPLODE)
+                    return ret;
+
+                break;
+            }"
avformat/movenc: Check input sample count.,"+    if (samples_in_chunk < 1) {
+        av_log(s, AV_LOG_ERROR, ""fatal error, input packet contains no samples\n"");
+        return AVERROR_PATCHWELCOME;
+    }"
MSE: Fix moar mp4 parsing security bugs.,+  for (size_t i = 0; i < sample_count; ++i) {
avcodec/htmlsubtitles: Fixes denial of service due to use of sscanf in inner loop for handling braces.,"-            an += sscanf(in, ""{\\an%*1u}%n"", &len) >= 0 && len > 0;"
Issue 449958: Heap-buffer-overflow in media::CopyPlane. ,"-             vpx_image->stride[VPX_PLANE_Y],"
Multiple integer underflows in the ff_mjpeg_decode_frame function in libavcodec/mjpegdec.c in FFmpeg before 2.7.2 allow remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.,-                        ((uint16_t*)line)[w - 2] = ((uint16_t*)line)[(w - 1) / 3];
Fixes: out of array access. ,"                 if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) {"
Fixes: out of array read. ,-                mms->stream_num++;
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 6*stride] = av_clip_uint8( dst[i + 6*stride] + ((b1 - b5) >> 7));
Fixes out of array access.,     if (!prev_pkt[channel_id].read) {
"libavcodec/webp.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not ensure that pix_fmt is set, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file, related to the vp8_decode_mb_row_no_filter and pred8x8_128_dc_8_c functions.",+    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme ELST count exceeds implementation limit."");"
The decode_frame function in libavcodec/utvideodec.c in FFmpeg through 3.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,"                 if (slice_end < 0 || slice_end < slice_start ||
-                    bytestream2_get_bytes_left(&gb) < slice_end) {
+                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL)"
Fixes: Null pointer dereference. ,-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
"The h264_slice_header_init function in libavcodec/h264_slice.c in FFmpeg before 2.8.3 does not validate the relationship between the number of threads and the number of slices, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted H.264 data.","+    h->max_contexts = FFMIN(h->max_contexts, nb_slices);"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->mb_type          = NULL;
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b3 - b7) >> 7)];
Fixes: Null pointer dereference.,"-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->intra_types_hist = NULL;
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.","+                size,"
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",copy->internal = av_malloc(sizeof(AVCodecInternal));
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.","-            sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,"
ffserver: Check chunk size.,"+            if (c->chunk_size <= 0) { // end of stream or invalid chunk size
+                c->chunk_size = 0;
                 goto fail;
+            }"
check that the element type matches before applying SBR: ,"+    if (id_aac != sbr->id_aac) {
+        av_log(ac->avctx, AV_LOG_ERROR,
+            ""element type mismatch %d != %d\n"", id_aac, sbr->id_aac);
+        sbr_turnoff(sbr);
+    }"
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 5*stride] = av_clip_uint8( dst[i + 5*stride] + ((b2 - b6) >> 7));
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.",-    if (s->ref && sh->first_slice_in_pic_flag) {
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme SGPD count exceeds implementation limit."");"
Fixes out of array access. ,"+        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
+            w_align = 8;
+            h_align = 8;
+        }"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b4) >> 7)];
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions. ",+    s->buf = av_malloc(s->buf_size);
Fixes out of array access. ,"+    if (s->state & PNG_IDAT) {
+        av_log(avctx, AV_LOG_ERROR, ""trns after IDAT\n"");
+        return AVERROR_INVALIDDATA;
+    }"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init(). ,"-    memset(&s->new_picture, 0, sizeof(s->new_picture));"
Fixes: Null pointer dereference.,-                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
Reject vp8 video having alpha and image planes of different sizes.,"+      if (vpx_image_alpha->d_h != vpx_image->d_h ||
+          vpx_image_alpha->d_w != vpx_image->d_w) {
+        LOG(ERROR) << ""The alpha plane dimensions are not the same as the ""
+                      ""image dimensions."";
+        return false;
+      }"
"Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size.",-            if (c->chunk_size == 0)
avformat/mov: Check sample size.,"+                if (size > 0x3FFFFFFF) {
+                    av_log(mov->fc, AV_LOG_ERROR, ""Sample size %u is too large\n"", size);
+                    return;
+                }"
It prevents the existing exploit leading to an information leak.,"static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
avcodec/mpeg4videodec: Remove use of FF_PROFILE_MPEG4_SIMPLE_STUDIO as indicator of studio profile.,"     if (avctx->bits_per_raw_sample > 8) {
-        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
+        av_assert1(s->studio_profile);
         return avctx->pix_fmt;
     }"
Fixes: out of array read. ,-            stream_id = flags & 0x7F;
Fixes: out of array read. ,"-    int need_emu  =  (unsigned) ix >= width  - w ||
-                     (unsigned) iy >= height - h;"
Issue 449958: Heap-buffer-overflow in media::CopyPlane.,"-             vpx_image->d_h,"
swscale/utils: Clear pix buffers.,"+    FF_ALLOCZ_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
avformat/rtmppkt: Check for packet size mismatches.,+        ff_rtmp_packet_destroy(&prev_pkt[channel_id]);
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b2 + b6) >> 7)];
avcodec/apedec: Fix integer overflow.,         blockstodecode = s->samples;
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","-    s->avctx->profile = get_bits(gb, 4);"
avcodec/scpr: Check y in first line loop in decompress_i().,"+            if (y >= avctx->height)
+                return AVERROR_INVALIDDATA;"
"An inconsistent bits-per-sample value in the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c in FFmpeg 4.0 may trigger an assertion violation while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
+        s->avctx->bits_per_raw_sample = 0;"
avcodec/ac3_parser: Check init_get_bits8() for failure.,"+    err = init_get_bits8(&gb, buf, size);"
Avoids leaving stale pointers. ,+        r->deblock_coefs    = NULL;
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 4*stride] = av_clip_uint8( dst[i + 4*stride] + ((b3 - b7) >> 7));
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
Crash Type: Use-of-uninitialized-value.,-    frame = VideoFrame::CreateFrame(
This avoids mixing 8bit variants with pro and 10bit with non pro mode.,+    } else if (!c->pro && avctx->extradata_size >= 16) {
"The flv_write_packet function in libavformat/flvenc.c in FFmpeg through 2.8 does not check for an empty audio packet, leading to an assertion failure.","     if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||
         par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)
         flags_size = 2;"
Check ymin vs. h.,             ptr += picture->linesize[i];
Fixes: integer overflow and out of array access.,"         if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size + 
		 AV_INPUT_BUFFER_PADDING_SIZE))) {"
"Also use the alpha image stride when copying the alpha plane, because it technically doesn't have to be the same as the image stride.","+             vpx_image_alpha->d_h,"
swscale/swscale_unscaled: Fix odd height inputs for bayer_to_yv12_wrapper().,"+    if (i + 1 == srcSliceH) {
+        copy(srcPtr, -srcStride[0], dstY, dstU, dstV, -dstStride[0], c->srcW, c->input_rgb2yuv_table);
+    }"
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.","+                        if (   h * mb_x + x >= s->width
+                            || v * mb_y + y >= s->height) {
+                        } else if (bits<=8) {"
Avoids leaving stale pointers. ,+        r->mb_type          = NULL;
avcodec/vc1_block: Fix mqaunt check for negative values,+        if (!mquant || mquant > 31 || mquant < -31) {                          \
Do not trust the counts.,+  RCHECK(sample_count <= sample_depends_on_.max_size());
fix ticket: 8673. set the default EXTINF duration to 1ms if duration is smaller than 1ms.,"+                if (duration < 0.001 * AV_TIME_BASE) {
+                    av_log(c->ctx, AV_LOG_WARNING, ""Cannot get correct #EXTINF value of segment %s,""
+                                    "" set to default value to 1ms.\n"", seg->url);
+                    duration = 0.001 * AV_TIME_BASE;
+                }"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b4) >> 7)];
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 0*stride] = av_clip_uint8( dst[i + 0*stride] + ((b0 + b4) >> 7));
"Heap-based buffer overflow in libavformat/rtmppkt.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check for RTMP packet size mismatches.","         if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,
                                          size)) < 0)"
The decode_plane function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,"+                if (c->control_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
"The VC-2 Video Compression encoder in FFmpeg 3.0 and 3.4 allows remote attackers to cause a denial of service (out-of-bounds read) because of incorrect buffer padding for non-Haar wavelets, related to libavcodec/vc2enc.c and libavcodec/vc2en.",-    av_freep(&s->buffer);
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->deblock_coefs    = NULL;
"The VideoFramePool::PoolImpl::CreateFrame function in media/base/video_frame_pool.cc in Google Chrome before 47.0.2526.73 does not initialize memory for a video-frame data structure, which might allow remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact by leveraging improper interaction with the vp3_h_loop_filter_c function in libavcodec/vp3dsp.c in FFmpeg.",+    const size_t num_planes = VideoFrame::NumPlanes(frame->format());
Fixes: Infinite loop. ,             pes_flags              = avio_rb16(pb);
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 1*stride] = av_clip_uint8( dst[i + 1*stride] + ((b1 + b5) >> 7));
avcodec/pngdec: Fix off by 1 size in decode_zbuf().,"+        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }"
avcodec/cbs_jpeg: Check length for SOS.,"+            if (length > end - start)
+                return AVERROR_INVALIDDATA;"
"libavcodec/tiff.c in FFmpeg before 2.8.6 does not properly validate RowsPerStrip values and YCbCr chrominance subsampling factors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted TIFF file, related to the tiff_decode_tag and decode_frame functions.","+            if (s->subsampling[i] <= 0) {
+                av_log(s->avctx, AV_LOG_ERROR, ""subsampling %d is invalid\n"", s->subsampling[i]);
+                return AVERROR_INVALIDDATA;
+            }"
avcodec/utvideodec: Fix bytes left check in decode_frame().,"                 if (slice_end < 0 || slice_end < slice_start ||
-                    bytestream2_get_bytes_left(&gb) < slice_end) {
+                    bytestream2_get_bytes_left(&gb) < slice_end + 1024LL)"
"When a crafted NSV file, which claims a large ""table_entries_used"" field in the header but does not contain sufficient backing data, is provided, the loop over 'table_entries_used' would consume huge CPU resources, since there is no EOF check inside the loop.","+            if (avio_feof(pb))
+                return AVERROR_INVALIDDATA;"
"Due to incorrect use of strtoll function > and integer sizes (chunk_size in int64_t)[2], it was possible to pass > negative chunk_size in chunk encoding, so after computing final size > using FFMIN function later on it would be passed as argument to > avio_read function.","+            if (c->chunk_size <= 0) { // end of stream or invalid chunk size
+                c->chunk_size = 0;
                 goto fail;
+            }"
Fixes: null pointer dereference. ,"-    s->avctx->level   = get_bits(gb, 4);"
Revert to zero-initializing buffers for FFmpegVideoDecoder. ,+    const size_t num_planes = VideoFrame::NumPlanes(frame->format());
avformat/avidec: Fix infinite loop in avi_read_nikon().,+            while (avio_tell(s->pb) < tag_end && !avio_feof(s->pb)) {
"We must check for size_t overflow when multiplying count by ""bytes_per_offset"".",+  RCHECK(reader->Read4(&count));
This ensures that no stale pointers leak through on any path. ,"-    memset(&s->last_picture, 0, sizeof(s->last_picture));"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.","+    ff_lzw_encode_init(s->lzw, s->buf, s->buf_size,"
Do not trust the counts.,+  size_t sample_count = reader->box_size() - reader->pos();
Revert to zero-initializing buffers for FFmpegVideoDecoder. ,"+    for (size_t i = 0; i < num_planes; ++i) {
+      memset(frame->data(i),
+             0,
+             VideoFrame::PlaneSize(frame->format(),
+                                   i,
+                                   frame->coded_size()).GetArea());
+    }"
Fixes out of array access.,-                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;
Check for bitstream end in read_quant_matrix_ext(). ,"+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Check read profile before setting it.,"+            mpeg4_decode_profile_level(s, gb, &profile, &level);"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.",+            s->avctx->profile = profile;
It prevents the existing exploit leading to an information leak.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
Fixes use of uninitialized memory.,"-    FF_ALLOC_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
"Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size.",+            av_assert0(len <= c->chunk_size);
"When a crafted MXF file, which claims a large ""nb_index_entries"" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU resources, since there is no EOF check inside the loop.","+        if(avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
MSE: Fix moar mp4 parsing security bugs.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_entry, static_cast<size_t>(count));"
Fixes out of array access. ,     samples  = (int16_t *)frame->data[0];
avformat/hls: Check local file extensions.,"static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
Avoids leaving stale pointers. ,+        r->intra_types_hist = NULL;
Fixes: integer overflow and out of array access.,         st->codecpar->extradata_size  = size_bmp - BMP_HEADER_SIZE;
avcodec/tiff: Check subsample & rps values more completely,"+            if (s->subsampling[i] <= 0) {
+                av_log(s->avctx, AV_LOG_ERROR, ""subsampling %d is invalid\n"", s->subsampling[i]);
+                return AVERROR_INVALIDDATA;
+            }"
Fixes use of uninitialized memory.,"-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
Fixes: assertion failure. ,"+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
+        s->avctx->bits_per_raw_sample = 0;"
Crash Type: Heap-buffer-overflow WRITE 1.,             uint8_t *row = &s->image_buf[s->image_linesize * y];
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(count <= entries.max_size());
Fixes: out of array read. ,"             get_bits(gb, 8);"
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.",   entries.resize(count);
Fixes: out of array read.,"             get_bits(gb, 8);"
FFmpeg before 2017-02-07 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame function in libavcodec/pictordec.c.,+    if (s->width != avctx->width || s->height != avctx->height) {
"The ff_sbr_apply function in libavcodec/aacsbr.c in FFmpeg before 2.7.2 does not check for a matching AAC frame syntax element before proceeding with Spectral Band Replication calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted AAC data.",     if (id_aac == TYPE_SCE || id_aac == TYPE_CCE) {
Fixes: out of array access.,    s->width = AV_RL16(&s->avctx->extradata[6]);
Fixes: out of array access.,"     if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {
         ctx->data_offset = 0x170 + (ctx->mb_height << 2);
     }"
This avoids mixing 8bit variants with pro and 10bit with non pro mode.,+    } else if (c->pro && avctx->extradata_size == 8) {
Crash Type: Use-of-uninitialized-value.,"-        format, coded_size, visible_rect, natural_size, timestamp);"
"In line libavcodec/h264dec.c:500 in libav(v13_dev0), ffmpeg(n3.4), chromium(56 prior Feb 13, 2017), the return value of init_get_bits is ignored and get_ue_golomb(&gb) is called on an uninitialized get_bits context, which causes a NULL deref exception.","-            ret = init_get_bits8(&gb, nal->data + 1, (nal->size - 1));"
avformat/rtmppkt: Check for packet size mismatches.,+        prev_pkt[channel_id].read = 0;
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
The decode_init function in libavcodec/utvideodec.c in FFmpeg 2.8 through 3.4.2 allows remote attackers to cause a denial of service (Out of array read) via an AVI file with crafted dimensions within chroma subsampling data.,"+    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &h_shift, &v_shift);"
Fixes use of freed memory. ,"for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
             ff_h264_unref_picture(h, &h->DPB[i]);"
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(count <= edits.max_size());
Fixes out of array access. ,+        zstream.avail_out = buf_size - 1;
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,             pes_flags              = avio_rb16(pb);
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",             err = AVERROR(ENOMEM);
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,             pes_flags              = avio_rb16(pb);
avformat/vividas: improve extradata packing checks in track_header().,"+            ret = ff_alloc_extradata(st->codecpar, xd_size);"
But such solutions are fragile and tricky to implement portably and would not stop every possible attack nor would they work with all valid hls files.,"static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
avcodec/mpeg4videodec: Check read profile before setting it.,+            s->avctx->profile = profile;
Fixes use of freed memory.,         av_freep(&h->DPB);
Fixes out of array access. ,         sbr->m[0] = sbr->m[1];
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  const size_t bytes_per_edit = reader->version() == 1 ? 20 : 12;
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.",-        return 1;
This reduces the attack surface of local file-system information leaking.,"-    if (!av_strstart(proto_name, ""http"", NULL) && !av_strstart(proto_name, ""file"", NULL))"
The avi_read_nikon function in libavformat/avidec.c in FFmpeg before 3.1.4 is vulnerable to infinite loop when it decodes an AVI file that has a crafted 'nctg' structure.,-    while (avio_tell(s->pb) < end) {
avcodec/htmlsubtitles: Fixes denial of service due to use of sscanf in inner loop for handling braces.,"+static int scanbraces(const char* in) {
+    if (strncmp(in, ""{\\an"", 4) != 0) {
+        return 0;
+    }
+    if (!isdigit(in[4])) {
+        return 0;
+    }
+    if (in[5] != '}') {
+        return 0;
+    }
+    return 1;
+}"
Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg 2.4 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file.,"-    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);"
SUMMARY: AddressSanitizer: stack-buffer-overflow.,-    if (tags == 16 && total_non_cc_elements == 16) {
avcodec/utvideodec: Add several out of array read related checks.,"+                if (c->packed_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
Fixes: null pointer dereference. ,"-    s->avctx->profile = get_bits(gb, 4);"
avcodec/jpeg2000dec: Clip all tile coordinates.,"+    tile->coord[1][0] = av_clip(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
avcodec/pngdec: Check trns more completely.,"+    if (!(s->state & PNG_IHDR)) {
+        av_log(avctx, AV_LOG_ERROR, ""trns before IHDR\n"");
+        return AVERROR_INVALIDDATA;
+    }"
avformat/avidec: Check nb_streams in read_gab2_sub().,"+            if (ast->sub_ctx->nb_streams != 1)
+                goto error;"
"The gmc_mmx function in libavcodec/x86/mpegvideodsp.c in FFmpeg 2.3 and 3.4 does not properly validate widths and heights, which allows remote attackers to cause a denial of service (integer signedness error and out-of-array read) via a crafted MPEG file.","+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
+                     (unsigned) iy >= height - h || height< h
+                     ;"
The new code verfies there's enough data in the atom for this to be done.,+            if (a.size == 1 && total_size + 8 <= atom.size) {
Fixes out of array access. ,"+        if (s->codec_id == AV_CODEC_ID_JV ||
+            s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {"
avformat/rl2: Fix DoS due to lack of eof check.,"+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","-    if (s->avctx->profile == 0 && s->avctx->level == 8) {
-        s->avctx->level = 0;"
Fixes: null pointer dereference. ,"     ff_idctdsp_init(&s->idsp, s->avctx);"
Fixes: NULL pointer dereference and out of array access. ,         if (s->sh.first_slice_in_pic_flag) {
"The smka_decode_frame function in libavcodec/smacker.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 does not verify that the data size is consistent with the number of channels, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted Smacker data.",+    if (unp_size % (avctx->channels * (bits + 1))) {
avcodec/dfa: Fix off by 1 error.,-            if (frame_end - frame < width + 3)
We should also avoid attempting to resize vectors beyond their max_size() (potential OOB depending on stl library impl).,+  RCHECK(reader->Read4(&count));
Fixes integer overflow.,     pts *= 10000;
Crash Type: Stack-buffer-overflow WRITE 1.,+        zstream.avail_out = buf_size - 1;
Fixes: out of array read. ,"-                mms->streams = av_fast_realloc(mms->streams,
-                                   &mms->nb_streams_allocated,
-                                   (mms->stream_num + 1) * sizeof(MMSStream));"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_entry, static_cast<size_t>(count));"
This ensures that no stale pointers leak through on any path. ,"-    memset(&s->new_picture, 0, sizeof(s->new_picture));"
"The ff_mpv_common_init function in libavcodec/mpegvideo.c in FFmpeg before 2.7.2 does not properly maintain the encoding context, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted MPEG data.","-    memset(&s->next_picture, 0, sizeof(s->next_picture));"
Fixes: out of array read. ,                        hdr->substreamid == 0 && info->substream[0].bsid) {
Do not trust the counts.,+  RCHECK(count <= entries.max_size());
Previously we would accept malformed vp8 video files that had alpha and image planes with different dimensions.,"-             vpx_image->stride[VPX_PLANE_Y],"
Fixes: Infinite loop. ,             pes_header_data_length = avio_r8(pb);
Fixes out of array access. ,"+        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }"
"The VideoFramePool::PoolImpl::CreateFrame function in media/base/video_frame_pool.cc in Google Chrome before 47.0.2526.73 does not initialize memory for a video-frame data structure, which might allow remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact by leveraging improper interaction with the vp3_h_loop_filter_c function in libavcodec/vp3dsp.c in FFmpeg.",+    const size_t num_planes = VideoFrame::NumPlanes(frame->format());
"The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.",-    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {
"clear priv_data, avoid stale pointer in error case",+            copy->priv_data = NULL;
Fixes: out of array access.,"-    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);"
avcodec/pngdec: Only allow one IHDR chunk: Multiple IHDR chunks are forbidden in PNG.,"+    if (s->state & PNG_IHDR) {
+        av_log(avctx, AV_LOG_ERROR, ""Multiple IHDR\n"");
+        return AVERROR_INVALIDDATA;
+    }"
avformat/rmdec: Do not pass mime type in rm_read_multi() to ff_rm_read_mdpr_codecdata().,"         ret = ff_rm_read_mdpr_codecdata(s, s->pb, st2, st2->priv_data,
-                                        size2, mime);
+                                        size2, NULL);"
Added one additional check for SampleEncryptionEntry (probably overkill).,+  RCHECK(sample_count <= sample_depends_on_.max_size());
avcodec/gif: Fix lzw buffer size.,+    s->buf = av_malloc(s->buf_size);
avcodec/dnxhd_parser: Do not return invalid value from dnxhd_find_frame_end() on error.,"-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;"
Fixes: out of array read. ,-                mms->streams[mms->stream_num].id = stream_id;
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.","+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_edit, static_cast<size_t>(count));"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b1 - b5) >> 7)];
Fixes inconsistency and out of array accesses.,     s->height = bytestream2_get_be32(&s->gb);
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+    if (*profile == 0 && *level == 8) {
+        *level = 0;"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->cbp_luma         = NULL;
This ensures that no stale pointers leak through on any path. ,"-    memset(&s->current_picture, 0, sizeof(s->current_picture));"
"In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact.","+        } else {
+            if (hdr->substreamid != 0) {
+                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
+                ret = AVERROR_PATCHWELCOME;
+                goto end;
+            }
         }"
avcodec/apedec: Fix integer overflow.,"     if (!s->decoded_buffer)
         return AVERROR(ENOMEM);"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.","+    ff_lzw_encode_init(s->lzw, s->buf, s->buf_size,"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","+    FF_ALLOCZ_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
The avi_read_nikon function in libavformat/avidec.c in FFmpeg before 3.1.4 is vulnerable to infinite loop when it decodes an AVI file that has a crafted 'nctg' structure.,-            while (avio_tell(s->pb) < tag_end) {
"libswscale/swscale_unscaled.c in FFmpeg before 2.8.6 does not validate certain height values, which allows remote attackers to cause a denial of service (out-of-bounds array read access) or possibly have unspecified other impact via a crafted .cine file, related to the bayer_to_rgb24_wrapper and bayer_to_yv12_wrapper functions.","+    if (i + 1 == srcSliceH) {
+        copy(srcPtr, -srcStride[0], dstY, dstU, dstV, -dstStride[0], c->srcW, c->input_rgb2yuv_table);
+    }"
"In FFmpeg 3.2 and 4.1, a denial of service in the subtitle decoder allows attackers to hog the CPU via a crafted video file in Matroska format, because ff_htmlmarkup_to_ass in libavcodec/htmlsubtitles.c has a complex format argument to sscanf.","-           if (sscanf(in+tag_close+1, ""%127[^<>]>%n"", buffer, &len) >= 1 && len > 0) {"
"The VC-2 Video Compression encoder in FFmpeg 3.0 and 3.4 allows remote attackers to cause a denial of service (out-of-bounds read) because of incorrect buffer padding for non-Haar wavelets, related to libavcodec/vc2enc.c and libavcodec/vc2en.",-    s->buffer = av_malloc(2*p_width*p_height*sizeof(dwtcoef));
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","+    FF_ALLOCZ_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init().,"-    memset(&s->last_picture, 0, sizeof(s->last_picture));"
avformat/avidec: Fix memleak with dv in avi.,+                av_freep(&s->streams[0]->codec);
avcodec/mjpegdec: Check number of components for JPEG-LS.,+        if (s->nb_components == 3) { s->avctx->pix_fmt = AV_PIX_FMT_RGB24;
The avi_read_seek function in libavformat/avidec.c in FFmpeg before 3.1.4 allows remote attackers to cause a denial of service (assert fault) via a crafted AVI file.,-        av_assert0(fabs(av_q2d(st2->time_base) - ast2->scale / (double)ast2->rate) < av_q2d(st2->time_base) * 0.00000001);
Fixes inconsistency and out of array accesses.,s->width  = bytestream2_get_be32(&s->gb);
"Since non-Haar wavelets need to look into pixels outside the frame, we need to pad the buffer.","+int  ff_vc2enc_init_transforms(VC2TransformContext *t, int p_stride, int p_height,
+                               int slice_w, int slice_h);"
Do not trust the counts.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
avcodec/mjpegdec: Fix small picture upscale.,"+                        if (w > 1)
+                            line[w - 2] = line[w - 1];"
avformat/aadec: Check for scanf() failure.,"+            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);"
avformat/movenc: Check that frame_types other than EAC3_FRAME_TYPE_INDEPENDENT have a supported substream id.,"+        } else {
+            if (hdr->substreamid != 0) {
+                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
+                ret = AVERROR_PATCHWELCOME;
+                goto end;
+            }
         }"
But files with sensitive information like private keys and passwords generally do not use common multimedia filename extensions.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
Integer overflow in the asf_write_packet function in libavformat/asfenc.c in FFmpeg before 2.8.5 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PTS (aka presentation timestamp) value in a .mov file.,"+    if (   pts < - PREROLL_TIME
+        || pts > (INT_MAX-3)/10000LL * ASF_INDEXED_INTERVAL - PREROLL_TIME) {
+        av_log(s, AV_LOG_ERROR, ""input pts %""PRId64"" is invalid\n"", pts);
+        return AVERROR(EINVAL);
+    }"
Fixes out of array read.,"-        if ((s->ncomponents & 1) == 0)
-            s->cdef[s->ncomponents-1] = 0;"
Fixes: out of array access. ,-        for (y = 0; y < s->ymin; y++) {
avcodec/mpeg4videodec: Clear bits_per_raw_sample if it has originated from a previous instance.,"+    if (!s->studio_profile && s->avctx->bits_per_raw_sample != 8)
+        s->avctx->bits_per_raw_sample = 0;"
Added one additional check for SampleEncryptionEntry (probably overkill).,+  for (size_t i = 0; i < sample_count; ++i) {
h264dec: handle zero-sized NAL units in get_last_needed_nal().,"+            ret = init_get_bits8(&gb, nal->data + 1, nal->size - 1);"
Fixes: Null pointer dereference. ,"-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;"
Fixes use of uninitialized memory.,"-    FF_ALLOC_OR_GOTO(c, c->chrVPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b1 + b5) >> 7)];
"The ff_dwt_decode function in libavcodec/jpeg2000dwt.c in FFmpeg before 2.8.4 does not validate the number of decomposition levels before proceeding with Discrete Wavelet Transform decoding, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    if (s->ndeclevels == 0)
+        return 0;"
"Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.","             frame[0] = frame[1] =
             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);"
Fixes out of array access.,         sbr->m[0] = sbr->m[1];
mov: Fix negative size calculation in mov_read_default().,-            if (a.size == 1) {
Fixes: NULL pointer dereference and out of array access. ,-    if (s->ref && sh->first_slice_in_pic_flag) {
"Heap-based buffer overflow in the xwd_decode_frame function in libavcodec/xwddec.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",-        if (pixdepth == 1) {
"The ff_hevc_parse_sps function in libavcodec/hevc_ps.c in FFmpeg before 2.8.2 does not validate the Chroma Format Indicator, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted High Efficiency Video Coding (HEVC) data.","+    if (sps->chroma_format_idc > 3U) {
+        av_log(avctx, AV_LOG_ERROR, ""chroma_format_idc %d is invalid\n"", sps->chroma_format_idc);
+        return AVERROR_INVALIDDATA;
+    }"
MSE: Fix moar mp4 parsing security bugs.,+  RCHECK(count <= entries.max_size());
mov: Fix negative size calculation in mov_read_default().,-            if (a.size == 1) {
Fixes: out of array access.,"         av_log(ctx->avctx, AV_LOG_ERROR,"
Fixes out of array access,"-    tile->coord[1][0] = FFMAX(tiley       * s->tile_height + s->tile_offset_y, s->image_offset_y);"
Fixes out of array read.,"-        for (x = 0; x < s->ncomponents; x++)
-            s->cdef[x] = x + 1;"
Issue 449958: Heap-buffer-overflow in media::CopyPlane. ,"-             vpx_image->d_h,"
Check for duplicate SIZ marker.,"+            if (s->ncomponents) {
+                av_log(s->avctx, AV_LOG_ERROR, ""Duplicate SIZ\n"");
+                return AVERROR_INVALIDDATA;
+            }"
zmbvenc allocates a buffer for a picture with padding on all four sides,"+    prev_offset = FFALIGN(c->lrange * c->bypp, 16) + c->pstride * c->lrange;"
Fixes out of array access.,-            if (frame_end - frame < width + 3)
avcodec/vqavideo: Set video size.,"+   if ((ret = ff_set_dimensions(avctx, s->width, s->height)) < 0) {"
avcodec/pictordec: Fix logic error.,"         ret = ff_set_dimensions(avctx, s->width, s->height);"
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init().,"-    memset(&s->next_picture, 0, sizeof(s->next_picture));"
avformat/asfdec_o: Check size_bmp more fully.,"+    if (size_bmp > BMP_HEADER_SIZE &&
+        size_bmp < INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE) {"
Fixes: Assertion failure. ,"     if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A ||
         par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC)
         flags_size = 2;"
Fixes out of array access,         sbr->m[0] = sbr->m[1];
avcodec/mpeg4videodec: Check read profile before setting it.,+        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
"When a crafted IVR file, which claims a large ""len"" field in the header but does not contain sufficient backing data, is provided, the first type==4 loop would consume huge CPU resources, since there is no EOF check inside the loop.","+            for (j = 0; j < len; j++) {
+                if (avio_feof(pb))
+                    return AVERROR_INVALIDDATA;
                av_log(s, AV_LOG_DEBUG, ""%X"", avio_r8(pb));
+            }"
track_header in libavformat/vividas.c in FFmpeg 4.3.1 has an out-of-bounds write because of incorrect extradata packing.,"-            ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);"
The decode_init function in libavcodec/utvideodec.c in FFmpeg 2.8 through 3.4.2 allows remote attackers to cause a denial of service (Out of array read) via an AVI file with crafted dimensions within chroma subsampling data.,"+    if ((avctx->width  & ((1<<h_shift)-1)) ||
+        (avctx->height & ((1<<v_shift)-1))) {
+        avpriv_request_sample(avctx, ""Odd dimensions"");
+        return AVERROR_PATCHWELCOME;
+    }"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode.,-        dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b1 + b5) >> 7)];
Fixes: out of array access. ,"            data     = av_malloc(end - start +
                                 AV_INPUT_BUFFER_PADDING_SIZE);"
Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg 2.4 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file.,-    av_assert0(decoded_buffer_size <= INT_MAX);
avcodec/utils: correct align value for interplay.,"+        if (s->codec_id == AV_CODEC_ID_INTERPLAY_VIDEO) {
+            w_align = 8;
+            h_align = 8;
+        }"
"Heap-based buffer overflow in the decode_dds1 function in libavcodec/dfa.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",-            if (frame_end - frame < width + 3)
avcodec/dfa: Fix off by 1 error.,"             frame[0] = frame[1] =
             frame[width] = frame[width + 1] =  bytestream2_get_byte(gb);"
avcodec/x86/mpegvideodsp: Fix signedness bug in need_emu.,"+    int need_emu  =  (unsigned) ix >= width  - w || width < w ||
+                     (unsigned) iy >= height - h || height< h
+                     ;"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b4) >> 7)];
The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg 3.0 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.,ctx->mb_scan_index[i] = AV_RB32(buf + 0x170 + (i << 2));
"The allocate_buffers function in libavcodec/alac.c in FFmpeg before 2.7.2 does not initialize certain context data, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted Apple Lossless Audio Codec (ALAC) data.","+    for (ch = 0; ch < 2; ch++) {
+        alac->predict_error_buffer[ch]  = NULL;
+        alac->output_samples_buffer[ch] = NULL;
+        alac->extra_bits_buffer[ch]     = NULL;
+    }"
avformat/avidec: Fix infinite loop in avi_read_nikon().,-    while (avio_tell(s->pb) < end) {
"Heap-based buffer overflow in the xwd_decode_frame function in libavcodec/xwddec.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.",-        } else if (pixdepth == 8) {
The only obvious solution is to prevent access to sensitive information.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
avformat/avidec: Remove ancient assert.,-        av_assert0(fabs(av_q2d(st2->time_base) - ast2->scale / (double)ast2->rate) < av_q2d(st2->time_base) * 0.00000001);
avformat/mms: Add missing chunksize check.,"+            if (chunksize > end - p) {
+                av_log(NULL, AV_LOG_ERROR,
+                    ""Corrupt stream (header chunksize %""PRId64"" is invalid)\n"",
+                    chunksize);
+                return AVERROR_INVALIDDATA;
+            }"
Fixes integer overflow.,"+    if (   pts < - PREROLL_TIME
+        || pts > (INT_MAX-3)/10000LL * ASF_INDEXED_INTERVAL - PREROLL_TIME) {
+        av_log(s, AV_LOG_ERROR, ""input pts %""PRId64"" is invalid\n"", pts);
+        return AVERROR(EINVAL);
+    }"
avformat/avidec: Check nb_streams in read_gab2_sub().,"             ff_read_packet(ast->sub_ctx, &ast->sub_pkt);"
avcodec/mpeg4videodec: Check read profile before setting it.,"+    *level   = get_bits(gb, 4);"
MSE: Fix moar mp4 parsing security bugs.,+  size_t sample_count = reader->box_size() - reader->pos();
Fixes out of array access. ,         sbr->kx[0] = sbr->kx[1];
Avoids leaving stale pointers. ,+        r->cbp_luma         = NULL;
The avi_read_seek function in libavformat/avidec.c in FFmpeg before 3.1.4 allows remote attackers to cause a denial of service (assert fault) via a crafted AVI file. ,-        av_assert0(fabs(av_q2d(st2->time_base) - ast2->scale / (double)ast2->rate) < av_q2d(st2->time_base) * 0.00000001);
zero initialize the rbsp buffer. ,+    rbsp->rbsp_buffer = av_mallocz(size);
avcodec/vc1_block: Fix mqaunt check for negative values,"             av_log(v->s.avctx, AV_LOG_ERROR,                   \
                    ""Overriding invalid mquant %d\n"", mquant);  \"
Fixes: Out of array access. ,             j = scantable[idx++];
avcodec/tiff: Check subsample & rps values more completely,+    if (s->rps <= 0 || s->rps % s->subsampling[1]) {
The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,             j = scantable[idx++];
"The VideoFramePool::PoolImpl::CreateFrame function in media/base/video_frame_pool.cc in Google Chrome before 47.0.2526.73 does not initialize memory for a video-frame data structure, which might allow remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact by leveraging improper interaction with the vp3_h_loop_filter_c function in libavcodec/vp3dsp.c in FFmpeg.","+    for (size_t i = 0; i < num_planes; ++i) {
+      memset(frame->data(i),
+             0,
+             VideoFrame::PlaneSize(frame->format(),
+                                   i,
+                                   frame->coded_size()).GetArea());
+    }"
Fixes out of array access.,-                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[0][0] = av_clip(tilex       * s->tile_width  + s->tile_offset_x, s->image_offset_x, s->width);"
The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.6 allows remote attackers to cause a denial of service (out-of-bounds array read access) via crafted JPEG 2000 data.,"-        if ((s->ncomponents & 1) == 0)
-            s->cdef[s->ncomponents-1] = 0;"
avcodec/utvideodec: Check subsample factors.,"+    av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &h_shift, &v_shift);"
Do not trust the counts.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_entry, static_cast<size_t>(count));"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions. ","+    ff_lzw_encode_init(s->lzw, s->buf, s->buf_size,"
"Heap-based buffer overflow in ffserver.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote attackers to execute arbitrary code by leveraging failure to check chunk size.","+            if (c->chunk_size <= 0) { // end of stream or invalid chunk size
+                c->chunk_size = 0;
                 goto fail;
+            }"
"Several vulnerabilities have been discovered in the FFmpeg multimedia framework, which could result in denial of service or potentially the execution of arbitrary code if malformed files/streams are processed.","         if (!(st->codecpar->extradata = av_malloc(st->codecpar->extradata_size + 
		 AV_INPUT_BUFFER_PADDING_SIZE))) {"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","-    FF_ALLOC_OR_GOTO(c, c->lumPixBuf,  c->vLumBufSize * 3 * sizeof(int16_t *), fail);"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->cbp_chroma       = NULL;
avcodec/utils: Clear dimensions in ff_get_buffer() on failure.,"+    if (ret < 0) {
         av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
+        frame->width = frame->height = 0;
+    }"
avcodec/idctdsp: Transmit studio_profile to init instead of using AVC odecContext profile.,"+    if (s->codec_id == AV_CODEC_ID_MPEG4)
+        s->idsp.mpeg4_studio_profile = s->studio_profile;"
"The jpeg2000_read_main_headers function in libavcodec/jpeg2000dec.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 does not enforce uniqueness of the SIZ marker in a JPEG 2000 image, which allows remote attackers to cause a denial of service (out-of-bounds heap-memory access) or possibly have unspecified other impact via a crafted image with two or more of these markers.","+            if (s->ncomponents) {
+                av_log(s->avctx, AV_LOG_ERROR, ""Duplicate SIZ\n"");
+                return AVERROR_INVALIDDATA;
+            }"
avcodec/h264_slice: Limit max_contexts when slice_context_count is initialized.,"+    h->max_contexts = FFMIN(h->max_contexts, nb_slices);"
"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS.",      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS.",			len = field[n].end - field[n].start;
Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file.,			as->s[as->length] = '\0';
> Undefined behavior / signed integer overflow in TAR parser.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.",        zip->entry_compressed_bytes_read += ENC_HEADER_SIZE;
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
"Using this malformed tar file with ""bsdtar -tf [input]"" will cause a signed integer overflow.","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS.","+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
The _ar_read_header function in archive_read_support_format_ar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds stack read) via a crafted ar file.,"                if (ar->strtab == NULL || number > ar->strtab_size) {
                        archive_set_error(&a->archive, EINVAL,
+                           ""Can't find long filename for GNU/SVR4 archive entry"");
                        archive_entry_copy_pathname(entry, filename);
                        ar_parse_common_header(ar, entry, h);
+                       return (ARCHIVE_FATAL);
                }"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
Issue #767: Buffer overflow printing a filename.,-		if (i > (sizeof(outbuff) - 20)) {
Fix integer overflow when computing location of volume descriptor,		skipsize -= iso9660->current_position;
Fuzzing with CRCs disabled revealed that a call to get_uncompressed_data() would sometimes fail to return at least 'minimum' bytes.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file.",	if (nrd < 0) {
Fuzzing with CRCs disabled revealed that a call to get_uncompressed_data() would sometimes fail to return at least 'minimum' bytes.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"	rab = __archive_read_ahead(a, 1U, &nrd);"
Fix typo in preprocessor macro in archive_read_format_zip_cleanup().,+#if HAVE_LZMA_H && HAVE_LIBLZMA
Resolves possible null-pointer dereference reported by OSS-Fuzz.,"-               else
-                       length = mbsnbytes(_p, n);"
==2650==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x607000000298 at pc 0x5586b16c5082 bp 0x7ffc3d24a950 sp 0x7ffc3d24a940.,			as->s[as->length] = '\0';
"read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",      filename[filename_size++] = '\0';
Heap-based buffer overflow in the zip_read_mac_metadata function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to execute arbitrary code via crafted entry-size values in a ZIP archive.,	metadata = malloc((size_t)rsrc->uncompressed_size);
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+			if ((size_t)bytes_avail > metadata_bytes)
+				bytes_avail = metadata_bytes;"
Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.,"      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size, &g_szalloc))"
A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Avoid a double-free when a window size of 0 is specified.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
Fix a possible heap-buffer-overflow in archive_string_append_from_wcs().,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
"Using this malformed tar file with ""bsdtar -tf [input]"" will cause a signed integer overflow.",        p->remaining = remaining;
7zip: fix crash when parsing certain archives.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
This is a simple NULL dereference leading to a crash.,"    new_window = realloc(rar->lzss.window, new_size);"
"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS.",			st = field[n].start + 1;
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
"When copying data into the allocated buffer, check the copy size against both the compressed entry size and uncompressed entry size.","+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Malformed OS X metadata entry: inconsistent size"");
+			return (ARCHIVE_FATAL);
+		}"
Limit write requests to at most INT_MAX.,"+	if (s > max_write)
+		s = max_write;"
"A RAR file with an invalid zero dictionary size was not being rejected, leading to a zero-sized allocation for the dictionary storage which was then overwritten during the dictionary initialization.","+      if (rar->dictionary_size == 0) {
+	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                          ""Invalid zero dictionary size"");
+	      return (ARCHIVE_FATAL);
+      }"
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Malformed OS X metadata entry: inconsistent size"");
+			return (ARCHIVE_FATAL);
+		}"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,-			numbers[argc++] = (unsigned long)mtree_atol(&p);
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,			outbuff[i] = '\0';
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
"While here, also reject headers with multiple EmptyFile, AntiFile, Name, or Attributes markers.","+			if (zip->entry_names != NULL)
+				return (-1);"
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,"			fprintf(f, ""%s"", outbuff);"
This is a simple NULL dereference leading to a crash.,			st = field[n].start + 1;
Stack out of bounds read in ar parser.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,"-               if (sc != NULL && (sc->flag & SCONV_FROM_UTF16))
-                       length = utf16nbytes(_p, n);"
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
The _ar_read_header function in archive_read_support_format_ar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds stack read) via a crafted ar file.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
This means that in some cases is not enough do few hours of fuzzing and believe that there aren?????t more bugs????? A crafted file causes a stack-buffer overflow write.,"			fprintf(f, ""%s"", outbuff);"
"When sanity-checking the size of an OS X metadata entry, abort this entry if either the compressed or uncompressed size is larger than 4MB.","+	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    ""Mac metadata is too large: %jd > 4M bytes"",
+		    (intmax_t)rsrc->compressed_size);
+		return (ARCHIVE_WARN);
+	}"
Fix a possible heap-buffer-overflow in archive_string_append_from_wcs().,			as->s[as->length] = '\0';
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
Avoid a read off-by-one error for UTF16 names in RAR archives.,-      filename[filename_size++] = '\0';
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
"While pruning trailing text from ar filenames, we did not check for an empty filename.","+       if (p < filename) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+                   ""Found entry with empty filename"");
+               return (ARCHIVE_FATAL);
+       }"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
Stack out of bounds read in ar parser.,"                if (ar->strtab == NULL || number > ar->strtab_size) {
                        archive_set_error(&a->archive, EINVAL,
+                           ""Can't find long filename for GNU/SVR4 archive entry"");
                        archive_entry_copy_pathname(entry, filename);
                        ar_parse_common_header(ar, entry, h);
+                       return (ARCHIVE_FATAL);
                }"
"The safe_fprintf function attempts to ensure clean output for an arbitrary sequence of bytes by doing a trial conversion of the multibyte characters to wide characters -- if the resulting wide character is printable then we pass through the corresponding bytes unaltered, otherwise, we convert them to C-style ASCII escapes.",+		if (i > (sizeof(outbuff) - 128)) {
Resolves possible null-pointer dereference reported by OSS-Fuzz.,"-               if (sc != NULL && (sc->flag & SCONV_FROM_UTF16))
-                       length = utf16nbytes(_p, n);"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,			zip->entry_names = malloc(ll);
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
This is a simple NULL dereference leading to a crash.,			len = field[n].end - field[n].start;
Signed integer overflows are undefined in C.,        p->remaining = remaining;
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.","        p = __archive_read_ahead(a, ENC_HEADER_SIZE, NULL);"
==13144==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000038800 at pc 0x7fb1c808f650 bp 0x7ffdd1b40990 sp 0x7ffdd1b40988,	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,			zip->entry_names = malloc(ll);
\307q\005\bo\002\244\201\350\003\350\003libarchive/archive_read_support_format_tar.c:612:10: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type 'long'.,        p->remaining = remaining;
Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.,"+      if (rar->dictionary_size == 0) {
+	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                          ""Invalid zero dictionary size"");
+	      return (ARCHIVE_FATAL);
+      }"
This means that in some cases is not enough do few hours of fuzzing and believe that there aren?????t more bugs????? A crafted file causes a stack-buffer overflow write.,			outbuff[i] = '\0';
"This means that if you specify an invalid content length, it will just reprint the same data over and over and over again until it hits the desired length.","+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
"Issue #582: reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks.","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
The archive_read_format_cpio_read_header function in archive_read_support_format_cpio.c in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a CPIO archive with a large symlink.,"h = __archive_read_ahead(a,
			(size_t)cpio->entry_bytes_remaining, NULL);"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
array subscript is above array bounds,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
Limit write requests to at most INT_MAX.,+	const size_t max_write = INT_MAX;
==2650==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x607000000298 at pc 0x5586b16c5082 bp 0x7ffc3d24a950 sp 0x7ffc3d24a940.,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    ""Mac metadata is too large: %jd > 4M bytes"",
+		    (intmax_t)rsrc->compressed_size);
+		return (ARCHIVE_WARN);
+	}"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","	rab = __archive_read_ahead(a, 1U, &nrd);"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
array subscript is above array bounds,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
"libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c.",	while (char_cnt-- > 0) {
consume data once read.,"+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,			outbuff[i] = '\0';
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,-		if (i > (sizeof(outbuff) - 20)) {
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.",	if (nrd < 0) {
Crash Type: Heap-buffer-overflow READ {*} Crash Address: 0x6140000009f8 Crash State: read_header archive_read_format_rar_read_header _archive_read_next_header2 Sanitizer: address (ASAN) Recommended Security Severity: Medium Package: libarchive13 Version: 3.2.2-3.1 $ valgrind --quiet -- bsdtar -xf oob.rar ==1880== Invalid read of size 1 ==1880== at 0x4832FF0: memcpy (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B5E0: memcpy (string3.h:53) ==1880== by 0x489B5E0: read_header (archive_read_support_format_rar.c:1577) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== Address 0x6ca726a is 0 bytes after a block of size 98 alloc'd ==1880== at 0x482E1FC: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x4830520: realloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B451: read_header (archive_read_support_format_rar.c:1423) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== bsdtar: Unknown file attributes from RAR file's host OS bsdtar: Error exit delayed from previous errors.,      filename[filename_size++] = '\0';
"When we grow the archive_string buffer, we have to make sure it fits at least one maximum-sized multibyte character in the current locale and the null character.","			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
Avoid a double-free when a window size of 0 is specified.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
7zip: fix crash when parsing certain archives.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"A simple cast suffices to fix this since the base location is always 32 bits for ISO, so multiplying by the sector size will never overflow a 64-bit integer.",+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Fix integer overflow when computing location of volume descriptor.,		skipsize -= iso9660->current_position;
archive_strncat_l(): allocate and do not convert if length == 0.,-       if (length == 0) {
Avoid a read off-by-one error for UTF16 names in RAR archives.,      filename[filename_size++] = '\0';
Crash Type: Heap-buffer-overflow READ {*},      filename[filename_size++] = '\0';
==27792==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010800 at pc 0x6169dd bp 0x7ffff41b2ef0 sp 0x7ffff41b2ee0.,        zip->entry_compressed_bytes_read += ENC_HEADER_SIZE;
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->antiBools != NULL)
+				return (-1);"
> Undefined behavior / signed integer overflow in TAR parser.,        p->remaining = remaining;
Crash Type: Heap-buffer-overflow READ {*} Crash Address: 0x6140000009f8 Crash State: read_header archive_read_format_rar_read_header _archive_read_next_header2 Sanitizer: address (ASAN) Recommended Security Severity: Medium Package: libarchive13 Version: 3.2.2-3.1 $ valgrind --quiet -- bsdtar -xf oob.rar ==1880== Invalid read of size 1 ==1880== at 0x4832FF0: memcpy (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B5E0: memcpy (string3.h:53) ==1880== by 0x489B5E0: read_header (archive_read_support_format_rar.c:1577) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== Address 0x6ca726a is 0 bytes after a block of size 98 alloc'd ==1880== at 0x482E1FC: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x4830520: realloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B451: read_header (archive_read_support_format_rar.c:1423) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== bsdtar: Unknown file attributes from RAR file's host OS bsdtar: Error exit delayed from previous errors.,-      filename[filename_size++] = '\0';
"A simple cast suffices to fix this since the base location is always 32 bits for ISO, so multiplying by the sector size will never overflow a 64-bit integer.",-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,			zip->entry_names = malloc(ll);
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,"-               else
-                       length = mbsnbytes(_p, n);"
Do something sensible for empty strings to make fuzzers happy.,"+	if (char_cnt == 0)
+		return (0);"
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,"			fprintf(f, ""%s"", outbuff);"
Memory leak when decoding LZMA #1165.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
Avoid a double-free when a window size of 0 is specified.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
"libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service). This attack appears to be exploitable via the victim opening a specially crafted 7zip file.",*buff = zip->uncompressed_buffer_pointer;
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->emptyStreamBools != NULL)
+				return (-1);"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
==27792==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010800 at pc 0x6169dd bp 0x7ffff41b2ef0 sp 0x7ffff41b2ee0.,-       zip->entry_bytes_remaining -= ENC_HEADER_SIZE;
Fix libarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds.,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
7zip: fix crash when parsing certain archives.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"Integer overflow in the read_SubStreamsInfo function in archive_read_support_format_7zip.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a 7zip file with a large number of substreams, which triggers a heap-based buffer overflow.","+			if (unpack_streams > SIZE_MAX - UMAX_ENTRY) {
+				return (-1);
+			}"
Signed integer overflows are undefined in C.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.",-       zip->entry_bytes_remaining -= ENC_HEADER_SIZE;
==15753==ERROR: LeakSanitizer: detected memory leaks.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.","	rab = __archive_read_ahead(a, 1U, &nrd);"
Signed integer overflows are undefined in C.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
7zip: fix crash when parsing certain archives.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
This prevents a certain common programming error (passing -1 to write) from leading to other problems deeper in the library.,+	const size_t max_write = INT_MAX;
Stop this by checking that the length is not zero before beginning the switch statement.,"+			if (len == 0) {
+				ret = ARCHIVE_WARN;
+				continue;
+			}"
detected memory leaks,-#if HAVA_LZMA_H && HAVE_LIBLZMA
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,-		if (i > (sizeof(outbuff) - 20)) {
Fail if entry is too small for encryption header.,"+       if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)
+           && zip->entry_bytes_remaining < ENC_HEADER_SIZE) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                   ""Truncated Zip encrypted body: only %jd bytes available"",
+                   (intmax_t)zip->entry_bytes_remaining);
+               return (ARCHIVE_FATAL);
+       }"
==13144==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000038800 at pc 0x7fb1c808f650 bp 0x7ffdd1b40990 sp 0x7ffdd1b40988,	while (char_cnt-- > 0) {
"Crash analysis : In archive_string_append_from_wcs() (archive_string.c), upon execution of the crashing input (crash-file): archive_string_append_from_wcs(){ .... // Allocated heap memory for as->s is 72 bytes in range (0x607000000250,0x607000000298) p = as->s + as->length; ... while (*w != L'\0' && len > 0) { ... #if HAVE_WCRTOMB n = wcrtomb(p, *w++, &shift_state); // p = 0x611000000628 --> 0x00, wcrtomb() returns 3, n = 3 #else n = wctomb(p, *w++); #endif if (n == -1) { if (errno == EILSEQ) { ... } else p += n; // p = 0x611000000628 --> 0x00 len--; } as->length = p - as->s; // as->length = 72. as->s[as->length] = '\0'; // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.","			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
"but only a few hundred bytes of data, causes a quasi-infinite loop.",		*bsz = 0U;
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,-		if (i > (sizeof(outbuff) - 20)) {
This is a simple NULL dereference leading to a crash.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
"libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file.",		*bsz = 0U;
warc: consume data once read.,"+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
Avoid a read off-by-one error for UTF16 names in RAR archives.,+      filename[filename_size] = '\0';
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,-       if (_p != NULL && n > 0) {
"While here, also reject headers with multiple EmptyFile, AntiFile, Name, or Attributes markers.","+			if (h->attrBools != NULL)
+				return (-1);"
"The first (patch 1) is a double-free via a realloc(area, 0).","  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
"read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",-      filename[filename_size++] = '\0';
libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-416: Use After Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c that can result in Crash/DoS - it is unknown if RCE is possible.,"  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
as->s[as->length] = '\0';    // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.,			as->s[as->length] = '\0';
"but only a few hundred bytes of data, causes a quasi-infinite loop.","	rab = __archive_read_ahead(a, 1U, &nrd);"
ibarchive: heap-based buffer overflow in xml_data (archive_read_support_format_xar.c).,	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
Skip 0-length ACL fields.,"+			if (len == 0) {
+				ret = ARCHIVE_WARN;
+				continue;
+			}"
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->emptyFileBools != NULL)
+				return (-1);"
Signed integer overflows are undefined in C.,        p->remaining = remaining;
"Issue #582: reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks.","+       if (remaining < 0 || offset < 0) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, ""Malformed sparse map data"");
+               return (ARCHIVE_FATAL);
+       }"
"That would check the new file name against the old file name, and if they didn't match up it would free the ppmd7 buffer and allocate a new one.","+  else if (rar->filename_must_match)
+  {
+    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+      ""Mismatch of file parts split across multi-volume archive"");
+    return (ARCHIVE_FATAL);
+  }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,			len = field[n].end - field[n].start;
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file.,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"    new_window = realloc(rar->lzss.window, new_size);"
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,			outbuff[i] = '\0';
Reject cpio symlinks that exceed 1MB.,"+		if (cpio->entry_bytes_remaining > 1024 * 1024) {
+			archive_set_error(&a->archive, ENOMEM,
+			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
+			return (ARCHIVE_FATAL);
+		}"
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
"libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service).","-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"While here, change a number of ar format issues from WARN to FATAL.","+       if (p < filename) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+                   ""Found entry with empty filename"");
+               return (ARCHIVE_FATAL);
+       }"
Do something sensible for empty strings to make fuzzers happy.,"+	if (char_cnt == 0)
+		return (0);"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,"			fprintf(f, ""%s"", outbuff);"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,			zip->entry_names = malloc(ll);
Resolves possible null-pointer dereference reported by OSS-Fuzz.,-       if (_p != NULL && n > 0) {
\307q\005\bo\002\244\201\350\003\350\003libarchive/archive_read_support_format_tar.c:612:10: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type 'long'.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,+			numbers[argc++] = (unsigned long)mtree_atol(&p);
bsdtar in libarchive before 3.2.0 allows remote attackers to cause a denial of service (infinite loop) via an ISO with a directory that is a member of itself.,-	file->offset = iso9660->logical_block_size * (uint64_t)location;
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,			st = field[n].start + 1;
Issue 403: Buffer underflow parsing 'ar' header.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.",		*bsz = 0U;
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.",	if (nrd < 0) {
Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.,		skipsize -= iso9660->current_position;
"bsdtar: An error in archive_string_append_from_wcs() (archive_string.c) triggers an out-of-bounds write in heap memory that results into a crash, via a specially crafted archive file.",			as->s[as->length] = '\0';
"reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","    new_window = realloc(rar->lzss.window, new_size);"
as->s[as->length] = '\0'; // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.,"			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,-       if (length == 0) {
This prevents a certain common programming error (passing -1 to write) from leading to other problems deeper in the library.,"+	if (s > max_write)
+		s = max_write;"
Integer overflow in the archive_read_format_tar_skip function in archive_read_support_format_tar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (crash) via a crafted tar file.,        p->remaining = remaining;
Fixes a heap buffer overflow reported in Secunia SA74169.,	lha->compsize -= extdsize - 2;
Resolves possible null-pointer dereference reported by OSS-Fuzz.,-       if (length == 0) {
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-		set1->nodeMax *= 2;
The functions xmlParserEntityCheck() and xmlParseAttValueComplex() used to call xmlStringDecodeEntities() in a recursive context without incrementing the 'depth' counter in the parser context.,+        ++ctxt->depth;
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-		set1->nodeMax *= 2;
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
Global buffer-overflow in the htmlParseTryOrFinish function.," 	ctxt->input->cur = BAD_CAST"""";"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
Heap-based buffer overread in xmlDictAddString. ,        if ((*in > 0) && (*in < 0x80)) {
A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case.,-            arg1->boolval |= arg2->boolval;
Buffer overead with HTML parser in push mode. ,"-					    ctxt->userData, &cur, 1);"
Fix inappropriate fetch of entities content.,"-		    xmlLoadEntityContent(ctxt, ent);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
"Store start position instead of a pointer to the name since the underlying buffer may change, resulting in a stale pointer being used.",+    startPosition = CUR_PTR - BASE_PTR;
A NULL pointer dereference vulnerability exists in the xpath,-            arg1->boolval |= arg2->boolval;
The xmlSAX2TextNode function in SAX2.c in the push interface in the HTML parser in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (stack-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.,"-					    ctxt->userData, &cur, 1);"
"Multiple use-after-free vulnerabilities in libxml2 2.9.0 and possibly other versions might allow context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to the (1) htmlParseChunk and (2) xmldecl_done functions, as demonstrated by a buffer overflow in the xmlBufGetInputBase function.", 	if (res < 0) {
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"A flaw in libxml2 allows remote XML entity inclusion with default parser flags (i.e., when the caller did not request entity substitution, DTD validation, external DTD subset loading, or default DTD attributes).","+	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+		(ctxt->replaceEntities == 0) &&
+		(ctxt->validate == 0))
+		return;"
Limit available memory to 100MB to avoid exhaustive memory consumption by malicious files.,             xmlFree(state->out);
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for entity references replacement (--noent option) was requested / enabled during the XML file parsing.",+    if (replacement != 0) {
"A remote attacker could provide a specially-crafted XML file containing an external entity expansion, when processed would lead to excessive CPU consumption (denial of service).",-    if (ent->checked == 0) {
"There are times, like on unterminated entities that it's preferable to stop parsing, even if that means less error reporting.",+	xmlStopParser(ctxt);
Avoid an out of bound access when serializing malformed strings.,+            } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {
Fix some potential problems on reallocation failures.,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
Check that the XPath stack isn't empty and optimize the logic operators slightly.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
Bug 763071: heap-buffer-overflow in xmlStrncat.,     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
The attached document will cause an out of bounds heap read access in the function xmlParseXMLDecl.,            encoding = xmlParseEncName(ctxt);
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-        cur->nodeMax *= 2;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
handle properly the case where we popped out of the current entity while processing a start tag.,"+    if (inputNr != ctxt->inputNr) {
+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
+		    ""Start tag doesn't start and stop in the same entity\n"");
+	return(NULL);
+    }"
Fix inappropriate fetch of entities content For https://bugzilla.gnome.org/show_bug.cgi?id=761430.,"+		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+			(ctxt->validate != 0)) {
+			xmlLoadEntityContent(ctxt, ent);
+		    } else {
+			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
+		  ""not validating will not read content for PE entity %s\n"",
+		                      ent->name, NULL);
+		    }"
Fix the semantic of XPath axis for namespace/attribute context nodes. ,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
Then xmlSchemaVStart->xmlSchemaPreRun initialize vctxt->xsiAssemble to 0 again which cause the alloced schema can not be freed anymore.,-    vctxt->xsiAssemble = 0;
The count was incremented before the allocation and not fixed in case of failure.,+        cur->nodeMax *= 2;
Bug 758605: Heap-based buffer overread in xmlDictAddString.," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
"If the option --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file.",while (strm->avail_out && ret != LZMA_STREAM_END);
The count was incremented before the allocation and not fixed in case of failure.," 		temp = (xmlNodePtr *) xmlRealloc(
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));"
Fix potential out of bound access.,+        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
Only advance to the next character if there is no error.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
Heap-based buffer-underreads due to xmlParseName.,         name = xmlParseName(ctxt);
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects.,-	    blen += 6;
"Hey, There appears to be an out-of-bounds read in libxml2 (2.9.2)."," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
Approvement in LZMA error handling which prevents an infinite loop.,"+        if ((state->how != GZIP) &&
+            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {
+            xz_error(state, ret, ""lzma error"");
+            return -1;
+        }"
Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.,-            arg1->boolval |= arg2->boolval;
==2994== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60040000d5d3 at pc 0x73320a bp 0x7fffffffc1e0 sp 0x7fffffffc1d8,-            } else if (*cur < 0xF8) {
"Vulnerability class: Null deref, Denial of Service.","-            valuePush(ctxt, arg1);"
"Started by Chris Evans, I added a few more place where the error should have been set in the evaluation context.",+                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
Heap-based buffer overflow in the xmlDictComputeFastQKey function in dict.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service via unspecified vectors.,-        value += name[len - (plen + 1 + 1)];
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
Avoid an heap buffer overflow in xmlDictComputeFastQKey.,-        value += name[len - (plen + 1 + 1)];
"Double free vulnerability in libxml2, as used in Google Chrome before 14.0.835.163, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.","         if (tmp == NULL) {
             xmlGenericError(xmlGenericErrorContext, ""realloc failed !\n"");
+            ctxt->error = XPATH_MEMORY_ERROR;
             return (0);
         }"
It was possible to hit a negative offset in the name indexing used to randomize the dictionary key generation,-        value += name[len - (plen + 1 + 1)];
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,+            } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",     buf[len] = 0;
Limit available memory to 100MB to avoid exhaustive memory consumption by malicious files.,"+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
"The xz_head function in xzlib.c in libxml2 before 2.9.6 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.","+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
Check the liblzma error code more thoroughly to avoid infinite loops.,"+        if ((state->how != GZIP) &&
+            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {
+            xz_error(state, ret, ""lzma error"");
+            return -1;
+        }"
the current pointer to the input has to be between the base and end. ,"+    if ((ctxt->input->cur > ctxt->input->end) ||
+        (ctxt->input->cur < ctxt->input->base)) {
+        xmlHaltParser(ctxt);
+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, ""cur index out of bound"");
+	return;
+    }"
"A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference.","+        if (cur == NULL)
+            return(NULL);"
"The xz_head function in libxml2 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.","+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case.,"-            valuePush(ctxt, arg1);"
"XML external entity (XXE) vulnerability in the xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.4, when not in validating mode, allows context-dependent attackers to read arbitrary files or cause a denial of service (resource consumption) via unspecified vectors.","+		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+			(ctxt->validate != 0)) {
+			xmlLoadEntityContent(ctxt, ent);
+		    } else {
+			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
+		  ""not validating will not read content for PE entity %s\n"",
+		                      ent->name, NULL);
+		    }"
Fix some potential problems on reallocation failures.,"-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
"libxml2 2.9.8, if --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file that triggers LZMA_MEMLIMIT_ERROR, as demonstrated by xmllint, a different vulnerability than CVE-2015-8035 and CVE-2018-9251.",while (strm->avail_out && ret != LZMA_STREAM_END);
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application."," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
Fix user-after-free with `xmllint --xinclude --dropdtd`. ,-                   (cur->children->type != XML_XINCLUDE_END)) {
"(pushParseTest): The input for the new test case was so small (4 bytes) that htmlParseChunk() was never called after htmlCreatePushParserCtxt(), thereby creating a false positive test failure.","     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
Fix missing error status in XPath evaluation.,+    ctxt->error = XPATH_INVALID_OPERAND;
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-		set1->nodeMax *= 2;
Buffer overead with HTML parser in push mode. ,"-						ctxt->userData, &cur, 1);"
Add missing increments of recursion depth counter to XML parser.,+        ++ctxt->depth;
* HTMLparser.c: (htmlParseName): Add bounds check.,"+	if (in == ctxt->input->end)
+	    return(NULL);"
Fix a potential freeing error in XPath,-		valuePop(ctxt);
Fix potential out of bound access.,-        while (buf[len - 1] == 0x20) len--;
Avoid an out of bound access when serializing malformed strings.,-            } else if (*cur < 0xF8) {
"The xmlDictAddString function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.", 	if ((*in > 0) && (*in < 0x80)) {
"If the XPath stack is corrupted, for example by a misbehaving extension function, the ""and"" and ""or"" XPath operators could dereference NULL pointers.","-            valuePush(ctxt, arg1);"
The functions xmlParserEntityCheck() and xmlParseAttValueComplex() used to call xmlStringDecodeEntities() in a recursive context without incrementing the 'depth' counter in the parser context.,+			++ctxt->depth;
The comprehensive fix is to change the return type of xmlStrlen() to size_t so that it doesn't overflow.,"+    if (size < 0)
+        return(NULL)"
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						      XML_SUBSTITUTE_REF,
 						      0, 0, 0);"
when the end of the internal subset isn't properly detected xmlParseInternalSubset should just return instead of trying to process input further.,"     if (RAW != '>') {
 	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
+	return;
     }"
"When doc is NULL, namespace created in xmlTreeEnsureXMLDecl is bind to newDoc->oldNs, in this case, set newDoc->oldNs to NULL and free newDoc will cause a memory leak.","+    if(doc != NULL)
+	newDoc->oldNs = NULL;"
"There are times, like on unterminated entities that it's preferable to stop parsing, even if that means less error reporting.",+	    xmlStopParser(ctxt);
Fix missing error status in XPath evaluation. ,+    ctxt->error = XPATH_INVALID_OPERAND;
Fix an off by one pointer access.,-	    *cur++ = CUR;
"libxml2 2.9.0-rc1 and earlier, as used in Google Chrome before 21.0.1180.89, does not properly support a cast of an unspecified variable during handling of XSL transforms, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document, related to the _xmlNs data structure in include/libxml/tree.h.","+	if (node->type != XML_NAMESPACE_DECL)
+	    cur = node->children;
+	else
+	    cur = NULL;"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-	    val1->nodeMax *= 2;
The count was incremented before the allocation and not fixed in case of failure.,+		set1->nodeMax *= 2;
"A remote attacker could provide a specially-crafted XML file containing an external entity expansion, when processed would lead to excessive CPU consumption (denial of service).",} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
Make sure to set 'attvalue' to NULL after freeing it.,+		if ((attvalue != NULL) && (alloc != 0)) {
* parser.c: do not load external parsed entities unless needed.,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
"If an untrusted XML document was parsed in recovery mode and post-validated, the flaw could be used to crash the application."," 	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                           depth + 1);"
Fix memory access error due to incorrect entities boundaries.,-	if (ctxt->input->base != base) goto base_changed;
Fix default template processing on namespace nodes.,"+		case XML_NAMESPACE_DECL:
+		    break;"
"The xz_head function in libxml2 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.",             xmlFree(state->in);
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for external entity references replacement (--noent option) was requested / enabled during the XML file parsing.","+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
An attacker who is able to submit a crafted file to be processed by an application linked with libxml2 could trigger a use-after-free.,-                   (cur->children->type != XML_XINCLUDE_END)) {
Heap-based buffer overread in xmlDictAddString. ,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
libfuzzer regression testing exposed another case where the parser would fetch content of an external entity while not in validating mode.,"+		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+			(ctxt->validate != 0)) {
+			xmlLoadEntityContent(ctxt, ent);
+		    } else {
+			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
+		  ""not validating will not read content for PE entity %s\n"",
+		                      ent->name, NULL);
+		    }"
Fix some potential problems on reallocation failures.,-		set1->nodeMax *= 2;
Fix user-after-free with `xmllint --xinclude --dropdtd`.,-                   (cur->children->type != XML_ENTITY_DECL) &&
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
Fix memory access error due to incorrect entities boundaries.,-		if (ctxt->input->base != base) goto base_changed;
CVE-2015-7497 Avoid an heap buffer overflow in xmlDictComputeFastQKey.,-        value += name[len - (plen + 1 + 1)];
A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case.,-            arg1->boolval &= arg2->boolval;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
It was possible to hit a negative offset in the name indexing used to randomize the dictionary key generation.,-        value += name[len - (plen + 1 + 1)];
Fix some potential problems on reallocation failures.," 		temp = (xmlNodePtr *) xmlRealloc(
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));"
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for external entity references replacement (--noent option) was requested / enabled during the XML file parsing.",-    if (ent->checked == 0) {
Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.,"-            valuePush(ctxt, arg1);"
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
Fix default template processing on namespace nodes.,"+	if (node->type != XML_NAMESPACE_DECL)
+	    cur = node->children;
+	else
+	    cur = NULL;"
* xmlstring.c: (xmlStrncat): Return NULL if xmlStrlen returns a negative length.,"+    if (size < 0)
+        return(NULL);"
"libxml2 before 2.7.8, as used in Google Chrome before 7.0.517.44, Apple Safari 5.0.2 and earlier, and other products, reads from invalid memory locations during processing of malformed XPath expressions, which allows context-dependent attackers to cause a denial of service (application crash) via a crafted XML document.","     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
The pointers from the context input were not properly reset after that call which can do reallocations.,+	size_t current = ctxt->input->cur - ctxt->input->base;
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
"WebKitGTK+ recently bumped the libxml2 dependency to 2.9.0, and immediately buffer overflow errors started appearing, signalled by the following stderr output in some test cases: internal buffer error : No error message provided.", 	if (res < 0) {
Stop parsing on entities boundaries errors.,+	    xmlStopParser(ctxt);
A heap-buffer overflow was found in the way libxml2 decoded certain XML entitites.,     buf[len] = 0;
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"Vulnerability class: Null deref, Denial of Service.",-            arg1->boolval |= arg2->boolval;
==17901==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60300000ea56 at pc 0x46cfc5 bp 0x7fffffffc420 sp 0x7fffffffc400.B1+B39," 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,"
Heap-based buffer overflow in the xmlGROW function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to obtain sensitive process memory information via unspecified vectors.,"     if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&
         (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 	    xmlPopInput(ctxt);"
Fix the semantic of XPath axis for namespace/attribute context nodes. ,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
Make sure that truncated UTF-8 sequences don't cause an out-of-bounds array access.,"+    memset(&buffer[sizeof(buffer)-4], 0, 4);"
* HTMLparser.c: (htmlParseName): Add bounds check.,"+    if (ctxt->input->base > ctxt->input->cur - len)
+	return(NULL);"
"If an untrusted XML document was parsed in recovery mode and post-validated, the flaw could be used to crash the application.", 	    elem = xmlParseName(ctxt);
Limit available memory to 100MB to avoid exhaustive memory consumption by malicious files.,"-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {"
Do not fetch external parsed entities.,-    if (ent->checked == 0) {
A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case.,"-            valuePush(ctxt, arg1);"
The attached document will cause an out of bounds heap read access in the function xmlParseXMLDecl.,"            if (RAW != '\'') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-	    val1->nodeMax *= 2;
heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>.,"     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));"
Truncated UTF-8 input can cause out-of-bounds array access.,"snprintf(buf, sizeof(buf), ""&#%d;"", *cur);"
Fix nullptr deref with XPath logic ops.,-            arg1->boolval &= arg2->boolval;
Heap-based buffer overread in xmlParserPrintFileContextInternal.,-        if (ctxt->input->cur[tlen] == '>') {
Bug 758588: Heap-based buffer overread in xmlParserPrintFileContextInternal.,-        if (ctxt->input->cur[tlen] == '>') {
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-		if (ctxt->input->base != base) goto base_changed;
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	    xmlStopParser(ctxt);
Fix some buffer conversion issues.,"+		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);"
heap-buffer-overflow in xmlFAParsePosCharGroup.,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure., 	    ctxt->input->free = NULL;
The comprehensive fix is to change the return type of xmlStrlen() to size_t so that it doesn't overflow.,"+    if (size < 0)
+        return(NULL);"
Fix user-after-free with `xmllint --xinclude --dropdtd`. ,-                   (cur->children->type != XML_ENTITY_DECL) &&
Heap-based buffer overread in xmlDictAddString. ," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
An attacker who is able to submit a crafted file to be processed by an application linked with libxml2 could trigger a use-after-free.,-                   (cur->children->type != XML_XINCLUDE_START) &&
Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.,-            arg1->boolval &= arg2->boolval;
Stop parsing on entities boundaries errors.,+	    xmlStopParser(ctxt);
Stop parsing on entities boundaries errors.,+	    xmlStopParser(ctxt);
"It is possible to trigger a stack overflow using a carefully crafted invalid xml file, the stack overflow occurs before libxml2 determines the xml file is invalid."," 	rep = xmlStringDecodeEntities(ctxt, ent->content,
 				  XML_SUBSTITUTE_REF, 0, 0, 0);"
The pointers from the context input were not properly reset after that call which can do reallocations.,"+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);"
Error in the code pointing to the codepoint in the stack for the current char value instead of the pointer in the input that the SAX callback expects.,"+						ctxt->userData, &in->cur[0], 1);"
"The xmlParseElementDecl function in parser.c in libxml2 before 2.9.4 allows context-dependent attackers to cause a denial of service (heap-based buffer underread and application crash) via a crafted file, involving xmlParseName.",         name = xmlParseName(ctxt);
Do not fetch external parsed entities.,-    if (ent->checked == 0) {
The HTML parser was too optimistic when processing comments and didn't check for the end of the stream on the first 2 characters.,"-    if (!IS_CHAR(cur)) {
-       htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
-                    ""Comment not terminated \n<!--%.50s\n"", buf, NULL);
-       xmlFree(buf);
-    }"
Buffer overead with HTML parser in push mode.,"-						ctxt->userData, &cur, 1);"
"One place where ctxt->instate == XML_PARSER_EOF whic was set up by entity detection issues doesn't get noticed, and even overrided.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-	if (ctxt->input->base != base) goto base_changed;
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.","-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
* HTMLparser.c: (htmlParseName): Add bounds check.,"+       if (in == ctxt->input->end)
+           return(NULL);"
Global buffer-overflow in the htmlParseTryOrFinish function.,	    ctxt->input->free((xmlChar *) ctxt->input->base);
Check return value of recursive calls to xmlParseElementChildrenContentDeclPriv and return immediately in case of errors.,"+        if (cur == NULL)
+            return(NULL);"
"There are times, like on unterminated entities that it's preferable to stop parsing, even if that means less error reporting.",+	    xmlStopParser(ctxt);
Do not fetch external parameter entities.,"+                    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+		        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+			((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+			(ctxt->validate == 0))
+			return;"
Fix memory access error due to incorrect entities boundaries.,     ctxt->input->cur = ctxt->input->base + cur;
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-		set1->nodeMax *= 2;
* parser.c: do not load external parsed entities unless needed,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
Buffer overead with HTML parser in push mode.,"-					    ctxt->userData, &cur, 1);"
Error in the code pointing to the codepoint in the stack for the current char value instead of the pointer in the input that the SAX callback expects.,"+						ctxt->userData, &in->cur[0], 1);"
Fix some potential problems on reallocation failures.," 		temp = (xmlNodePtr *) xmlRealloc(
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));"
Avoid an heap buffer overflow in xmlDictComputeFastQKey.,+	value += name[offset];
Avoid an out of bound access when serializing malformed strings.,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
"Double free vulnerability in libxml2 2.7.8 and other versions, as used in Google Chrome before 8.0.552.215 and other products, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.",-		valuePop(ctxt);
* parser.c: do not load external parsed entities unless needed,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
Fix an off by one pointer access.,-	    *cur++ = CUR;
For php reproduction run the following (php needs the xml module for DOM): make sure the php files and .xsl files reside in same directory and run the following commands: php -f xpath_or.php php -f xpath_and.php -- Guy Inbar.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval |= arg2->boolval;"
"Off-by-one error in libxml2, as used in Google Chrome before 19.0.1084.46 and other products, allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via unknown vectors.","-	    if ((CUR == ')') || (CUR == '(') || (CUR == '^')) {
-		*cur++ = CUR;
-	    }"
xmlParseBalancedChunkMemoryRecover in parser.c in libxml2 before 2.9.10 has a memory leak related to newDoc->oldNs.,-    newDoc->oldNs = NULL;
Make sure to set 'attvalue' to NULL after freeing it.,+		    attvalue = NULL;
"WebKitGTK+ recently bumped the libxml2 dependency to 2.9.0, and immediately buffer overflow errors started appearing, signalled by the following stderr output in some test cases: internal buffer error : No error message provided.","     if ((end_in_lf == 1) && (ctxt->input != NULL) &&
         (ctxt->input->buf != NULL)) {"
libxml2 20904-GITv2.9.4-16-g0741801 is vulnerable to a heap-based buffer over-read in the xmlDictAddString function in dict.c.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-		set1->nodeMax *= 2;
Fix potential out of bound access.,+        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
* parserInternals.c: (xmlNextChar): Add an test to catch other issues on ctxt->input corruption proactively.,"+    if ((*ctxt->input->cur == 0) &&
+        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
"The xmlPArserPrintFileContextInternal function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.", 	    ctxt->input->cur += tlen + 1;
"This then causes an issue when the macro NEXT is called twice more, the first time it will read EOF, then the second time it will overread the buffer into global memory space, causing a crash in ASAN.", 	    xmlParsePI(ctxt);
Global buffer-overflow in the htmlParseTryOrFinish function., 	ctxt->input->base = ctxt->input->cur;
"The xmlDictAddString function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document."," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
Fix some potential problems on reallocation failures.,-        cur->nodeMax *= 2;
Fix the semantic of XPath axis for namespace/attribute context nodes. ,"+    if (cur != NULL) {
+        if ((cur->type == XML_ATTRIBUTE_NODE) ||
+            (cur->type == XML_NAMESPACE_DECL))
+            return(NULL);
+        if (cur->children != NULL)
+            return cur->children ;
+    }"
There appears to be an out-of-bounds read in libxml2 (2.9.2).," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
==26202==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x0000008073f9 bp 0x7ffd791c7f90 sp 0x7ffd791c7f88.,"-        if ((*ctxt->input->cur == 0) &&
-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0) &&
-            (ctxt->instate != XML_PARSER_COMMENT)) {"
heap-buffer-overflow in xmlFAParsePosCharGroup. ,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
* parser.c: do not load external parsed entities unless needed,-    if (ent->checked == 0) {
The processing of namespace and attributes nodes was not compliant to the XPath-1.0 specification.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
==19600==ERROR: AddressSanitizer: global-buffer-overflow on address 0x5608cd40a230 at pc 0x7f6705c1cdb4 bp 0x7ffced505890 sp 0x7ffced505880.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
"If the XPath stack is corrupted, for example by a misbehaving extension function, the ""and"" and ""or"" XPath operators could dereference NULL pointers.",-            arg1->boolval |= arg2->boolval;
Fix some potential problems on reallocation failures.,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"Vulnerability class: Null deref, Denial of Service.","-            valuePush(ctxt, arg1);"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-	if (ctxt->input->base != base) goto base_changed;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-        cur->nodeMax *= 2;
"Hey, There appears to be an out-of-bounds read in libxml2 (2.9.2)."," 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            ""xmlParseEntityDecl: entity %s not terminated\n"", name);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
Fix an off by one pointer access.,-	    *cur++ = CUR;
Avoid an out of bound access when serializing malformed strings.,+            } else if ((*cur < 0xF0) && (cur [2] != 0)) {
"For non-UTF-8 charsets, xmlNextChar() failed to check for the end of the input buffer and would continuing reading.","-        if ((*ctxt->input->cur == 0) &&
-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0) &&
-            (ctxt->instate != XML_PARSER_COMMENT)) {"
Bug 757711: heap-buffer-overflow in xmlFAParsePosCharGroup.,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
"When ctxt->instate == XML_PARSER_EOF,xmlParseStringEntityRef return NULL which cause a infinite loop in xmlStringLenDecodeEntities","     while ((c != 0) && (c != end) &&
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {"
The processing of namespace and attributes nodes was not compliant to the XPath-1.0 specification.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,"+        } else if ((*cur >= 0x80) && (cur[1] != 0) &&
+	           ((doc == NULL) || (doc->encoding == NULL))) {"
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
"The fix for this would be to check the instate in xmlParseMarkupDecl after it parses an entry, and if EOF is reached, then stop.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
Prevent unwanted external entity reference.,"+	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+		(ctxt->replaceEntities == 0) &&
+		(ctxt->validate == 0))
+		return;"
"When doc is NULL, namespace created in xmlTreeEnsureXMLDecl is bind to newDoc->oldNs, in this case, set newDoc->oldNs to NULL and free newDoc will cause a memory leak.",-    newDoc->oldNs = NULL;
Do not process encoding values if the declaration if broken.,"            if (RAW != '""') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
"The xz_head function in libxml2 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.","-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {"
Buffer overead with HTML parser in push mode.,"-						ctxt->userData, &cur, 1);"
"* parser.c: (xmlParseEndTag2): Add bounds checks before dereferencing ctxt->input->cur past the end of the buffer, or incrementing the pointer past the end of the buffer.","+    if ((tlen > 0) && (curLength >= (size_t)tlen) &&
+        (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+        if ((curLength >= (size_t)(tlen + 1)) &&
+	    (ctxt->input->cur[tlen] == '>')) {"
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects. ,-	    blen += 12;
"The xmlParserHandlePEReference function in parser.c in libxml2 before 2.9.2, as used in Web Listener in Oracle HTTP Server in Oracle Fusion Middleware 11.1.1.7.0, 12.1.2.0, and 12.1.3.0 and other products, loads external parameter entities regardless of whether entity substitution or validation is enabled, which allows remote attackers to cause a denial of service (resource consumption) via a crafted XML document.","input = xmlNewEntityInputStream(ctxt, entity);"
"Hi, we found a global-buffer-overflow in xmlEncodeEntitiesInternal at libxml2/entities.c:583.","    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
Global buffer-overflow in the htmlParseTryOrFinish function., 	    ctxt->input->free = NULL;
The count was incremented before the allocation and not fixed in case of failure.,"+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));"
"WebKitGTK+ recently bumped the libxml2 dependency to 2.9.0, and immediately buffer overflow errors started appearing, signalled by the following stderr output in some test cases: internal buffer error : No error message provided."," 	xmlParserInputBufferPush(ctxt->input->buf, 1, ""\r"");"
"A patch to do this is below: diff --git a/parser.c b/parser.c index a65e4cc..04b0e58 100644 --- a/parser.c +++ b/parser.c @@ -6970,6 +6970,15 @@ xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) { xmlParsePI(ctxt); } } + + /* + * If the parser eached end of file, then stop while we know it is failing.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
arg1->boolval |= arg2->boolval; //crashing here due to null deref.,-            arg1->boolval |= arg2->boolval;
"One place where ctxt->instate == XML_PARSER_EOF whic was set up by entity detection issues doesn't get noticed, and even overrided. ","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
"Add bounds checks before dereferencing ctxt->input->cur past the end of the buffer, or incrementing the pointer past the end of the buffer.","+    if ((tlen > 0) && (curLength >= (size_t)tlen) &&
+        (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+        if ((curLength >= (size_t)(tlen + 1)) &&
+	    (ctxt->input->cur[tlen] == '>')) {"
Fix infinite loop in xmlStringLenDecodeEntities.,"     while ((c != 0) && (c != end) &&
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {"
"Off-by-one error in libxml2, as used in Google Chrome before 19.0.1084.46 and other products, allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via unknown vectors.",-	    *cur++ = CUR;
==17901==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60300000ea56 at pc 0x46cfc5 bp 0x7fffffffc420 sp 0x7fffffffc400.B1+B39," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	    xmlStopParser(ctxt);
Avoid an heap buffer overflow in xmlDictComputeFastQKey. ,+	value += name[offset];
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-		if (ctxt->input->base != base) goto base_changed;
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,-            } else if (*cur < 0xF8) {
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	value += name[offset];
"Because of that omission, the parser failed to detect attribute recursions in certain documents before running out of stack space."," 	rep = xmlStringDecodeEntities(ctxt, ent->content,
 				  XML_SUBSTITUTE_REF, 0, 0, 0);"
"If entities expansion in the XML parser is asked for, it is possble to craft relatively small input document leading to excessive on-the-fly content generation.","+        if (replacement < XML_PARSER_NON_LINEAR * consumed)
+	    return(0);"
"Heap-based buffer overflow in the xmlStrncat function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.",     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
The count was incremented before the allocation and not fixed in case of failure.,"+	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *
 					     sizeof(xmlNodePtr));"
==35387==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eef7 at pc 0x7fa80a8da830 bp 0x7fff08c0f8f0 sp 0x7fff08c0f8e8,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
xmllint: global-buffer-overflow in xmlEncodeEntitiesInternal.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
The pointers from the context input were not properly reset after that call which can do reallocations.,"+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);"
"The htmlCurrentChar function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.","-        if ((*ctxt->input->cur == 0) &&
-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0) &&
-            (ctxt->instate != XML_PARSER_COMMENT)) {"
xmlStringLenDecodeEntities in parser.c in libxml2 2.9.10 has an infinite loop in a certain end-of-file situation.,"     while ((c != 0) && (c != end) &&
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {"
A NULL pointer dereference vulnerability exists in the xpath,"-            valuePush(ctxt, arg1);"
* parser.c: (xmlParseElementDecl): Return early on invalid input to fix non-minimized test case (759573-2.xml).," 	if (!IS_BLANK_CH(CUR)) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 		           ""Space required after 'ELEMENT'\n"");
+	    return(-1);
 	}"
"The xmlBufAttrSerializeTxtContent function in xmlsave.c in libxml2 allows context-dependent attackers to cause a denial of service (out-of-bounds read and application crash) via a non-UTF-8 attribute value, related to serialization.","-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,     ctxt->input->cur = ctxt->input->base + cur;
Fix memory access error due to incorrect entities boundaries.,-    if (ctxt->input->base != base) goto base_changed;
Avoid an out of bound access when serializing malformed strings.,-            } else if (*cur < 0xF0) {
Fix some potential problems on reallocation failures.,-	    val1->nodeMax *= 2;
==32024==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x000000599fb9 bp 0x7ffc797d1b80 sp 0x7ffc797d1b78.,            encoding = xmlParseEncName(ctxt);
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","-            valuePush(ctxt, arg1);"
handle properly the case here we popped out of the current entity while processing a start tag.,"+    if (inputNr != ctxt->inputNr) {
+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
+		    ""Start tag doesn't start and stop in the same entity\n"");
+	return(NULL);
+    }"
Fix nullptr deref with XPath logic ops.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval |= arg2->boolval;"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-        cur->nodeMax *= 2;
"Because of that omission, the parser failed to detect attribute recursions in certain documents before running out of stack space."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						  XML_SUBSTITUTE_REF, 0, 0, 0);"
heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>. ,"     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));"
Fix potential out of bound access.,     buf[len] = 0;
Fix some potential problems on reallocation failures.,+		set1->nodeMax *= 2;
"libxml2 through 2.9.1 does not properly handle external entities expansion unless an application developer uses the xmlSAX2ResolveEntity or xmlSetExternalEntityLoader function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.","+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-	if (ctxt->input->base != base) {
"Hey, There appears to be an out-of-bounds read in libxml2 (2.9.2)."," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
There appears to be an out-of-bounds read in libxml2 (2.9.2).," 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            ""xmlParseEntityDecl: entity %s not terminated\n"", name);"
Fix out-of-bounds read with 'xmllint --htmlout'.,"+    memset(&buffer[sizeof(buffer)-4], 0, 4);"
"The xz_head function in xzlib.c in libxml2 before 2.9.6 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.",             xmlFree(state->in);
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	    xmlStopParser(ctxt);
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,"else if ((cur->children != NULL) &&
+                   ((cur->type == XML_DOCUMENT_NODE) ||
+                    (cur->type == XML_ELEMENT_NODE))) {"
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure., 	ctxt->input->base = ctxt->input->cur;
Fix an off by one pointer access.,"else {
-		*cur++ = '^';
-		*cur++ = CUR;
-	    }"
Bug 758605: Heap-based buffer overread in xmlDictAddString.,        if ((*in > 0) && (*in < 0x80)) {
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.",-            arg1 = valuePop(ctxt);
Unless explicitely asked for when validating or replacing entities with their value.,"+                    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+		        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+			((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+			(ctxt->validate == 0))
+			return;"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-	if (ctxt->input->base != base) {
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
Fixed by using a do-while loop so we always call htmlParseChunk() at least once.,+    } while (cur < size);
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
There appears to be an out-of-bounds read in libxml2 (2.9.2).," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,+	    xmlStopParser(ctxt);
arg1->boolval &= arg2->boolval; //and then the application is crashing here resulting in a Denial of Service condition.,-            arg1->boolval |= arg2->boolval;
GNOME project libxml2 v2.9.10 has a global buffer over-read vulnerability in xmlEncodeEntitiesInternal at libxml2/entities.c.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-    if (ctxt->input->base != base) goto base_changed;
"(pushParseTest): The input for the new test case was so small (4 bytes) that htmlParseChunk() was never called after htmlCreatePushParserCtxt(), thereby creating a false positive test failure.",        if ((*in > 0) && (*in < 0x80)) {
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,+	xmlStopParser(ctxt);
"Heap-based buffer overflow in the xmlFAParsePosCharGroup function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.","         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-        cur->nodeMax *= 2;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
"Heap-based buffer overflow in the xmlStrncat function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.","     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));"
Fix some buffer conversion issues.,"+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);"
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects. ,     bp = (char*)xmlMallocAtomic(blen);
Detect excessive entities expansion upon replacement.,"+	if (replacement < XML_MAX_TEXT_LENGTH)
+	    return(0);"
Stop parsing on entities boundaries errors.,+	xmlStopParser(ctxt);
Increase buffer space for port in HTTP redirect support.," 	if (proxy)
+	    blen += 17;"
CVE-2015-7497 Avoid an heap buffer overflow in xmlDictComputeFastQKey.,+	value += name[offset];
==32024==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x000000599fb9 bp 0x7ffc797d1b80 sp 0x7ffc797d1b78.,"            if (RAW != '\'') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
Detect excessive entities expansion upon replacement.,"+        if (replacement < XML_PARSER_NON_LINEAR * consumed)
+	    return(0);"
"Heap-based buffer underflow in the xmlParseAttValueComplex function in parser.c in libxml2 2.9.0 and earlier, as used in Google Chrome before 23.0.1271.91 and other products, allows remote attackers to cause a denial of service or possibly execute arbitrary code via crafted entities in an XML document.",     buf[len] = 0;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
"Double free vulnerability in libxml2 2.7.8 and other versions, as used in Google Chrome before 8.0.552.215 and other products, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.","-		xmlXPathReleaseObject(xpctxt, tmp);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-	    val1->nodeMax *= 2;
For php reproduction run the following (php needs the xml module for DOM): make sure the php files and .xsl files reside in same directory and run the following commands: php -f xpath_or.php php -f xpath_and.php -- Guy Inbar.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
Heap-based buffer overflow in the xmlParseXmlDecl function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service via unspecified vectors related to extracting errors after an encoding conversion failure.,-	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
Fix some buffer conversion issues.,+	size_t current = ctxt->input->cur - ctxt->input->base;
* xmlstring.c: (xmlStrncat): Return NULL if xmlStrlen returns a negative length.,"+        if (len < 0)
+            return(NULL);"
Add missing increments of recursion depth counter to XML parser.,+			++ctxt->depth;
"Without ASAN, there is potential to get input that could cause out of bounds memory to be returned to userspace through the use of libxml2, which could be used to cause denial of service attacks, or gain sensitive information.", 	    xmlParsePI(ctxt);
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,-	    val1->nodeMax *= 2;
Fixed by using a do-while loop so we always call htmlParseChunk() at least once.,+    do {
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,     ctxt->input->cur = ctxt->input->base + cur;
heap-buffer-overflow in xmlFAParsePosCharGroup. ,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
Heap-based buffer overread in xmlDictAddString. , 	if ((*in > 0) && (*in < 0x80)) {
Limit available memory to 100MB to avoid exhaustive memory consumption by malicious files.,             xmlFree(state->in);
Approvement in LZMA error handling which prevents an infinite loop.,while (strm->avail_out && ret != LZMA_STREAM_END);
Bug 758605: Heap-based buffer overread in xmlDictAddString.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
Fix user-after-free with `xmllint --xinclude --dropdtd`.,-                   (cur->children->type != XML_XINCLUDE_END)) {
Fix some buffer conversion issues.,		size_t current = ctxt->input->cur - ctxt->input->base;
if not stop everything we have an internal state error.,"     if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&
         (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 	    xmlPopInput(ctxt);"
Advancing to the next character in case of an error while parsing regexp leads to an out of bounds access.,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
Bug 758605: Heap-based buffer overread in xmlDictAddString.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
Avoid an out of bound access when serializing malformed strings.,"+        } else if ((*cur >= 0x80) && (cur[1] != 0) &&
+	           ((doc == NULL) || (doc->encoding == NULL))) {"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
Fix the semantic of XPath axis for namespace/attribute context nodes.,"+    if (cur != NULL) {
+        if ((cur->type == XML_ATTRIBUTE_NODE) ||
+            (cur->type == XML_NAMESPACE_DECL))
+            return(NULL);
+        if (cur->children != NULL)
+            return cur->children ;
+    }"
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,+            } else if ((*cur < 0xF0) && (cur [2] != 0)) {
"It is one case where the code in place to detect entities expansions failed to exit when the situation was detected, leading to DoS. ","+		if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
+		    (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
+		    goto int_error;"
arg1->boolval |= arg2->boolval; //crashing here due to null deref.,"-            valuePush(ctxt, arg1);"
"It is possible to trigger a stack overflow using a carefully crafted invalid xml file, the stack overflow occurs before libxml2 determines the xml file is invalid."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						      XML_SUBSTITUTE_REF,
 						      0, 0, 0);"
The comprehensive fix is to change the return type of xmlStrlen() to size_t so that it doesn't overflow.,"+        if (len < 0)
+            return(NULL);"
arg1->boolval |= arg2->boolval; //crashing here due to null deref.,"-            valuePush(ctxt, arg1);"
"The xmlNextChar function in libxml2 2.9.2 does not properly check the state, which allows context-dependent attackers to cause a denial of service (heap-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.", 	    xmlParsePI(ctxt);
Check the liblzma error code more thoroughly to avoid infinite loops.,while (strm->avail_out && ret != LZMA_STREAM_END);
"A remote attacker could provide a specially-crafted XML file that, when processed would lead to excessive CPU consumption (denial of service).","+        if (replacement < XML_PARSER_NON_LINEAR * consumed)
+	    return(0);"
==4210==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6290000051ff at pc 0x000000533c8f bp 0x7ffdb38c4830 sp 0x7ffdb38c4828., 	    ctxt->input->cur += tlen + 1;
Buffer overflow errors originating from xmlBufGetInputBase in 2.9.0., 	if (res < 0) {
Make sure that truncated UTF-8 sequences don't cause an out-of-bounds array access.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,-                   (cur->children->type != XML_ENTITY_DECL) &&
Fix the semantic of XPath axis for namespace/attribute context nodes.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
Buffer overead with HTML parser in push mode. ,"-						ctxt->userData, &cur, 1);"
Heap-based buffer overread in xmlDictAddString.," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
* parser.c: do not load external parsed entities unless needed,-    if (ent->checked == 0) {
"Fix this by pulling out the check for the end of the input buffer into common code, and return if we reach the end of the input buffer prematurely.","+    if ((*ctxt->input->cur == 0) &&
+        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {"
Fix infinite loop in LZMA decompression. ,while (strm->avail_out && ret != LZMA_STREAM_END);
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure.," 	ctxt->input->cur = BAD_CAST"""";"
Avoid an out of bound access when serializing malformed strings.,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
Heap-based buffer-underreads due to xmlParseName. ,         name = xmlParseName(ctxt);
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for external entity references replacement (--noent option) was requested / enabled during the XML file parsing.",} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"The htmlParseComment function in HTMLparser.c in libxml2 allows attackers to obtain sensitive information, cause a denial of service (out-of-bounds heap memory access and application crash), or possibly have unspecified other impact via an unclosed HTML comment.",     buf[len] = 0;
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	xmlStopParser(ctxt);
Error in the code pointing to the codepoint in the stack for the current char value instead of the pointer in the input that the SAX callback expects.,"+					    ctxt->userData, &in->cur[0], 1);"
"According to the xz man page, files compressed with `xz -9` currently require 65 MB to decompress, so set the limit to 100 MB.","+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
heap-buffer-overflow in xmlFAParsePosCharGroup.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
"The xmlNextChar function in libxml2 2.9.2 does not properly check the state, which allows context-dependent attackers to cause a denial of service (heap-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,-		set1->nodeMax *= 2;
"When we hit a convwersion failure when switching encoding it is bestter to stop parsing there, this was treated as a fatal error but the parser was continuing to process to extract more errors, unfortunately that makes little sense as the data is obviously corrupt and can potentially lead to unexpected behaviour.",+    return(ret);
Fix memory access error due to incorrect entities boundaries.,-	if (ctxt->input->base != base) {
Fix nullptr deref with XPath logic ops.,-            arg1->boolval |= arg2->boolval;
Fixed by using a do-while loop so we always call htmlParseChunk() at least once.,"+    do {
         if (cur + 1024 >= size) {"
Fix an off by one pointer access.,"-	    if ((CUR == ')') || (CUR == '(') || (CUR == '^')) {
-		*cur++ = CUR;
-	    }"
Check the liblzma error code more thoroughly to avoid infinite loops.,"+        if ((state->how != GZIP) &&
+            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {
+            xz_error(state, ret, ""lzma error"");
+            return -1;
+        }"
Set memory limit for LZMA decompression.,"+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
==2994== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60040000d5d3 at pc 0x73320a bp 0x7fffffffc1e0 sp 0x7fffffffc1d8,-            } else if (*cur < 0xF0) {
"A remote attacker could provide a specially-crafted XML file containing an external entity expansion, when processed would lead to excessive CPU consumption (denial of service).","+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
The pointers from the context input were not properly reset after that call which can do reallocations.,"+		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);"
The xmlSAX2TextNode function in SAX2.c in the push interface in the HTML parser in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (stack-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.,"-						ctxt->userData, &cur, 1);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
"A remote attacker could provide a specially-crafted XML file containing an external entity expansion, when processed would lead to excessive CPU consumption (denial of service).",ent->checked = ctxt->nbentities - oldnbent;
Buffer overflow errors originating from xmlBufGetInputBase in 2.9.0.,"     if ((end_in_lf == 1) && (ctxt->input != NULL) &&
         (ctxt->input->buf != NULL)) {"
Avoid an out of bound access when serializing malformed strings.,-            } else if (*cur < 0xF0) {
Fix user-after-free with `xmllint --xinclude --dropdtd`.,-                   (cur->children->type != XML_XINCLUDE_START) &&
"XML external entity (XXE) vulnerability in the xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.4, when not in validating mode, allows context-dependent attackers to read arbitrary files or cause a denial of service (resource consumption) via unspecified vectors."," 		rep = xmlStringDecodeEntities(ctxt, ent->content, what,"
heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>.,     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-		set1->nodeMax *= 2;
==40644==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eef7 at pc 0x7ff28073d830 bp 0x7ffe05f5ec10 sp 0x7ffe05f5ec08.,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
An attacker who is able to submit a crafted file to be processed by an application linked with libxml2 could trigger a use-after-free.,-                   (cur->children->type != XML_ENTITY_DECL) &&
Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.,"-            valuePush(ctxt, arg1);"
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects. ,-	    blen += 6;
Fix missing error status in XPath evaluation.,"         if (tmp == NULL) {
             xmlGenericError(xmlGenericErrorContext, ""realloc failed !\n"");
+            ctxt->error = XPATH_MEMORY_ERROR;
             return (0);
         }"
Increase buffer space for port in HTTP redirect support," 	else
+	    blen += 11;"
Avoid extra processing of MarkupDecl when EOF.,"+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.",-            arg1->boolval &= arg2->boolval;
"One place where ctxt->instate == XML_PARSER_EOF whic was set up by entity detection issues doesn't get noticed, and even overrided.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects.,-	    blen += 12;
"The xz_head function in xzlib.c in libxml2 before 2.9.6 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.","-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {"
A NULL pointer dereference vulnerability exists in the xpath,-            arg1->boolval &= arg2->boolval;
Detect excessive entities expansion upon replacement.,+    if (replacement != 0) {
Increase buffer space for port in HTTP redirect support.," 	else
+	    blen += 11;"
"The htmlParseComment function in HTMLparser.c in libxml2 allows attackers to obtain sensitive information, cause a denial of service (out-of-bounds heap memory access and application crash), or possibly have unspecified other impact via an unclosed HTML comment.","-    if (!IS_CHAR(cur)) {
-       htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
-                    ""Comment not terminated \n<!--%.50s\n"", buf, NULL);
-       xmlFree(buf);
-    }"
bug report: Global buffer-overflow in the htmlParseTryOrFinish function.," 	ctxt->input->cur = BAD_CAST"""";"
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references.",+        ++ctxt->depth;
Heap-based buffer overflow in the xmlDictComputeFastQKey function in dict.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service via unspecified vectors.,+	value += name[offset];
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",-        value += name[len - (plen + 1 + 1)];
"The xz_head function in libxml2 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.",             xmlFree(state->out);
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,"+        } else if ((*cur >= 0x80) && (cur[1] != 0) &&
+	           ((doc == NULL) || (doc->encoding == NULL))) {"
Fix some potential problems on reallocation failures.,-		set1->nodeMax *= 2;
Fix nullptr deref with XPath logic ops.,"-            valuePush(ctxt, arg1);"
"A remote attacker could provide a specially-crafted XML file that, when processed would lead to excessive CPU consumption (denial of service).",+    if (replacement != 0) {
Fix memory access error due to incorrect entities boundaries.,-	if (ctxt->input->base != base) goto base_changed;
"Heap-based buffer overflow in the xmlFAParsePosCharGroup function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.","     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
The processing of namespace and attributes nodes was not compliant to the XPath-1.0 specification.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
libfuzzer regression testing exposed another case where the parser would fetch content of an external entity while not in validating mode.,"-		    xmlLoadEntityContent(ctxt, ent);"
* xmlregexp.c: (xmlFAParseCharRange): Only advance to the next character if there is no error.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
"When we hit a convwersion failure when switching encoding it is bestter to stop parsing there, this was treated as a fatal error but the parser was continuing to process to extract more errors, unfortunately that makes little sense as the data is obviously corrupt and can potentially lead to unexpected behaviour.","+    ret = xmlSwitchToEncodingInt(ctxt, handler, len);"
The functions xmlParserEntityCheck() and xmlParseAttValueComplex() used to call xmlStringDecodeEntities() in a recursive context without incrementing the 'depth' counter in the parser context.,+			++ctxt->depth;
"Vulnerability class: Null deref, Denial of Service.",-            arg1->boolval &= arg2->boolval;
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,-            } else if (*cur < 0xF0) {
"The xmlDictAddString function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.","     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
"Multiple use-after-free vulnerabilities in libxml2 2.9.0 and possibly other versions might allow context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to the (1) htmlParseChunk and (2) xmldecl_done functions, as demonstrated by a buffer overflow in the xmlBufGetInputBase function.","     if ((end_in_lf == 1) && (ctxt->input != NULL) &&
         (ctxt->input->buf != NULL)) {"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-        cur->nodeMax *= 2;
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-	if (ctxt->input->base != base) goto base_changed;
Avoid an heap buffer overflow in xmlDictComputeFastQKey. ,-        value += name[len - (plen + 1 + 1)];
Heap-based buffer overread in xmlDictAddString.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
Add xmlHaltParser() to stop the parser.,"+    if ((ctxt->input->cur > ctxt->input->end) ||
+        (ctxt->input->cur < ctxt->input->base)) {
+        xmlHaltParser(ctxt);
+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, ""cur index out of bound"");
+	return;
+    }"
Fix some potential problems on reallocation failures.,"+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));"
Bug 763071: heap-buffer-overflow in xmlStrncat.,"     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));"
This issue is related to the handling of external parameter entities.,"+                    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+		        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+			((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+			(ctxt->validate == 0))
+			return;"
"When ctxt->instate == XML_PARSER_EOF,xmlParseStringEntityRef return NULL which cause a infinite loop in xmlStringLenDecodeEntities Found with libFuzzer.","     while ((c != 0) && (c != end) &&
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {"
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						  XML_SUBSTITUTE_REF, 0, 0, 0);"
Fix some potential problems on reallocation failures.,+        cur->nodeMax *= 2;
* parser.c: do not load external parsed entities unless needed.,-    if (ent->checked == 0) {
"There are times, like on unterminated entities that it's preferable to stop parsing, even if that means less error reporting.",+	    xmlStopParser(ctxt);
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","-            valuePush(ctxt, arg1);"
==25920==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010810 at pc 0x0000004a2f25 bp 0x7ffc81805ae0 sp 0x7ffc81805290.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
"Multiple use-after-free vulnerabilities in libxml2 2.9.0 and possibly other versions might allow context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to the (1) htmlParseChunk and (2) xmldecl_done functions, as demonstrated by a buffer overflow in the xmlBufGetInputBase function."," 	xmlParserInputBufferPush(ctxt->input->buf, 1, ""\r"");"
"Attribute strings are only valid if the base does not change, so add another check where the base may change.",+		if ((attvalue != NULL) && (alloc != 0)) {
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
Fix the semantic of XPath axis for namespace/attribute context nodes.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","+            if (ctxt->value != NULL)
+                ctxt->value->boolval |= arg2->boolval;"
"The htmlParseComment function in HTMLparser.c in libxml2 allows attackers to obtain sensitive information, cause a denial of service (out-of-bounds heap memory access and application crash), or possibly have unspecified other impact via an unclosed HTML comment.","     while (IS_CHAR(cur) &&
            ((cur != '>') ||
            (r != '-') || (q != '-'))) {"
==32024==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x000000599fb9 bp 0x7ffc797d1b80 sp 0x7ffc797d1b78.,            encoding = xmlParseEncName(ctxt);
"A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference.", 	    elem = xmlParseName(ctxt);
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,-                   (cur->children->type != XML_XINCLUDE_END)) {
Add missing increments of recursion depth counter to XML parser.,+			++ctxt->depth;
"One place where ctxt->instate == XML_PARSER_EOF whic was set up by entity detection issues doesn't get noticed, and even overrided. ","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
Global buffer-overflow in the htmlParseTryOrFinish function.,         ctxt->input->end = ctxt->input->cur;
Heap-based buffer overflow in the xmlParseXmlDecl function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service via unspecified vectors related to extracting errors after an encoding conversion failure.,"-    return(xmlSwitchToEncodingInt(ctxt, handler, len));"
==8253== ERROR: AddressSanitizer: heap-use-after-free on address 0xb4c00137 at pc 0x8832928 bp 0xbfda6128 sp 0xbfda611c.,-		if (alloc != 0) xmlFree(attvalue);
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for entity references replacement (--noent option) was requested / enabled during the XML file parsing.","+	if (replacement < XML_MAX_TEXT_LENGTH)
+	    return(0);"
bug report: Global buffer-overflow in the htmlParseTryOrFinish function.,         ctxt->input->end = ctxt->input->cur;
"The xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.3 does not properly prevent entity expansion, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted XML data, a different vulnerability than CVE-2014-3660.","if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))"
Fix some potential problems on reallocation failures.,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
I've verified this bug is affecting latest PHP 5.6 with xml module which can cause a denial of service for applications accepting xpath/xslt.,-            arg1->boolval &= arg2->boolval;
bug report: Global buffer-overflow in the htmlParseTryOrFinish function.,	    ctxt->input->free((xmlChar *) ctxt->input->base);
"Double free vulnerability in libxml2, as used in Google Chrome before 14.0.835.163, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.",+                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references.",+			++ctxt->depth;
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.",-            arg1 = valuePop(ctxt);
Bug 757711: heap-buffer-overflow in xmlFAParsePosCharGroup.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
There appears to be an out-of-bounds read in libxml2 (2.9.2).," 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,"
==32024==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x000000599fb9 bp 0x7ffc797d1b80 sp 0x7ffc797d1b78.,"            if (RAW != '""') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
"libxml2 2.9.0-rc1 and earlier, as used in Google Chrome before 21.0.1180.89, does not properly support a cast of an unspecified variable during handling of XSL transforms, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document, related to the _xmlNs data structure in include/libxml/tree.h.",     if (cur->type == XML_DTD_NODE) {
"libxml2 2.9.0-rc1 and earlier, as used in Google Chrome before 21.0.1180.89, does not properly support a cast of an unspecified variable during handling of XSL transforms, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document, related to the _xmlNs data structure in include/libxml/tree.h.","+		case XML_NAMESPACE_DECL:
+		    break;"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
bug report: Global buffer-overflow in the htmlParseTryOrFinish function., 	ctxt->input->base = ctxt->input->cur;
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
Increase buffer space for port in HTTP redirect support," 	if (proxy)
+	    blen += 17;"
Do not fetch external parsed entities.,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
arg1->boolval &= arg2->boolval; //and then the application is crashing here resulting in a Denial of Service condition.,-            arg1->boolval &= arg2->boolval;
"A remote attacker could provide a specially-crafted XML file that, when processed, would lead to the exhaustion of CPU and memory resources or file descriptors.","input = xmlNewEntityInputStream(ctxt, entity);"
"A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference.","+            if (last == NULL) {
+		if (ret != NULL)
+		    xmlFreeDocElementContent(ctxt->myDoc, ret);
+		return(NULL);
+            }"
"READ of size 1 at 0x000000c136a1 thread T0 #0 0x45736f in xmlNextChar /root/libxml2/parserInternals.c:535 #1 0x4fd936 in xmlParseInternalSubset /root/libxml2/parser.c:8447 #2 0x52717b in xmlParseDocument /root/libxml2/parser.c:10836 #3 0x55b5b6 in xmlDoRead /root/libxml2/parser.c:15324 #4 0x55b5b6 in xmlReadFile /root/libxml2/parser.c:15386 #5 0x4183b7 in parseAndPrintFile /root/libxml2/xmllint.c:2401 #6 0x40de46 in main /root/libxml2/xmllint.c:3759 #7 0x7f920fcc7ec4 (/lib/x86_64-linux-gnu/libc.so.6+0x21ec4) #8 0x40fad9 in _start (/root/libxml2/xmllint+0x40fad9) I git bisected it back to the following commit, which is meant to stop the parser on an unterminated entity This shows that there the parser is running through xmlParseMarkupDecl, and then instate is set to XML_PARSER_EOF (in xmlStopParser), but looking at the source for xmlParseMarkupDecl, on line 6990, the instate is changed to XML_PARSER_DTD.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"Otherwise, struct xmlElementContent could contain unexpected null pointers, leading to a null deref when post-validating documents which aren't well-formed and parsed in recovery mode."," 	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                           depth + 1);"
Bug 758588: Heap-based buffer overread in xmlParserPrintFileContextInternal., 	    ctxt->input->cur += tlen + 1;
Truncated UTF-8 input can cause out-of-bounds array access.,-		if (*cur < 0xC0) {
==40644==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eef7 at pc 0x7ff28073d830 bp 0x7ffe05f5ec10 sp 0x7ffe05f5ec08.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
Free input buffer in xmlHaltParser.,"+        if (ctxt->input->buf != NULL) {
+            xmlFreeParserInputBuffer(ctxt->input->buf);
+            ctxt->input->buf = NULL;
+        }"
Heap-based buffer overread in xmlDictAddString. ,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
bug report: Global buffer-overflow in the htmlParseTryOrFinish function., 	    ctxt->input->free = NULL;
Make sure to set 'attvalue' to NULL after freeing it.,+		    xmlFree(attvalue);
"Use-after-free vulnerability in the xmlSAX2AttributeNs function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2 and OS X before 10.11.5, allows remote attackers to cause a denial of service via a crafted XML document.",-		if (alloc != 0) xmlFree(attvalue);
Advancing to the next character in case of an error while parsing regexp leads to an out of bounds access.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
Fix some potential problems on reallocation failures.,"+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));"
Heap use-after-free in xmlSAX2AttributeNs.,-		if (alloc != 0) xmlFree(attvalue);
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure.,         ctxt->input->end = ctxt->input->cur;
Fix nullptr deref with XPath logic ops.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
The pointers from the context input were not properly reset after that call which can do reallocations.,		size_t current = ctxt->input->cur - ctxt->input->base;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,-        cur->nodeMax *= 2;
The attached document will cause an out of bounds heap read access in the function xmlParseXMLDecl.,            encoding = xmlParseEncName(ctxt);
Avoid extra processing of MarkupDecl when EOF.,"+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"libxml2 before 2.7.8, as used in Google Chrome before 7.0.517.44, Apple Safari 5.0.2 and earlier, and other products, reads from invalid memory locations during processing of malformed XPath expressions, which allows context-dependent attackers to cause a denial of service (application crash) via a crafted XML document.",     if (cur == NULL) cur = ctxt->context->node;
"For https://bugzilla.gnome.org/show_bug.cgi?id=759020 * parser.c: (xmlParseStartTag2): Attribute strings are only valid if the base does not change, so add another check where the base may change.",+		if ((attvalue != NULL) && (alloc != 0)) {
Buffer overflow errors originating from xmlBufGetInputBase in 2.9.0.," 	xmlParserInputBufferPush(ctxt->input->buf, 1, ""\r"");"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-    if (ctxt->input->base != base) goto base_changed;
==25920==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010810 at pc 0x0000004a2f25 bp 0x7ffc81805ae0 sp 0x7ffc81805290.," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-        cur->nodeMax *= 2;
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-	    val1->nodeMax *= 2;
"The xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.3 does not properly prevent entity expansion, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted XML data, a different vulnerability than CVE-2014-3660.","+		if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
+		    (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
+		    goto int_error;"
"A remote attacker could provide a specially-crafted XML file that, when processed would lead to excessive CPU consumption (denial of service).","+	if (replacement < XML_MAX_TEXT_LENGTH)
+	    return(0);"
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for external entity references replacement (--noent option) was requested / enabled during the XML file parsing.",ent->checked = ctxt->nbentities - oldnbent;
Fix default template processing on namespace nodes.,"+    if (cur->type == XML_NAMESPACE_DECL)
+        return;"
The attached document will cause an out of bounds heap read access in the function xmlParseXMLDecl.,"            if (RAW != '""') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,-            } else if (*cur < 0xF8) {
heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>. ,     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
The pointers from the context input were not properly reset after that call which can do reallocations.,		size_t current = ctxt->input->cur - ctxt->input->base;
Fix infinite loop in LZMA decompression.,while (strm->avail_out && ret != LZMA_STREAM_END);
The pointers from the context input were not properly reset after that call which can do reallocations.,"+		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);"
The count was incremented before the allocation and not fixed in case of failure.,"+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));"
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for entity references replacement (--noent option) was requested / enabled during the XML file parsing.","+        if (replacement < XML_PARSER_NON_LINEAR * consumed)
+	    return(0);"
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,"+                   ((cur->type == XML_DOCUMENT_NODE) ||
+                    (cur->type == XML_ELEMENT_NODE))) {"
"Hey, There appears to be an out-of-bounds read in libxml2 (2.9.2)."," 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,"
"If entities expansion in the XML parser is asked for, it is possble to craft relatively small input document leading to excessive on-the-fly content generation.","+	if (replacement < XML_MAX_TEXT_LENGTH)
+	    return(0);"
A race condition in chown_one() of systemd allows an attacker to cause systemd to set arbitrary permissions on arbitrary files.,"-        if (name)
-                r = fchownat(fd, name, uid, gid, AT_SYMLINK_NOFOLLOW);"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
So let's follow suit and only accept numbers in decimal notation.,"+        r = safe_atou32_full(s, 10, &uid);"
don't accept arbitrarily sized journal data fields.,"+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                if (r == 0) 
+                        break;"
journal-remote: set a limit on the number of fields in a message.,"+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                r = read_line(f, LONG_LINE_MAX, &line);"
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,+        unit_add_to_gc_queue(u);
"In systemd 223 through 235, a remote DNS server can respond with a custom crafted DNS NSEC resource record to trigger an infinite loop in the dns_packet_read_type_window() function of the 'systemd-resolved' service and cause a DoS of the affected service. ","        if (p->question->n_keys != 1)
                return 0;"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
journal: do not remove multiple spaces after identifier in syslog message.,"+        e += strspn(p + e, WHITESPACE);"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g.","+                r = read_line(f, LONG_LINE_MAX, &line);"
let's rework the recursive logic to use O_PATH.,"+        xsprintf(procfs_path, ""/proc/self/fd/%i"", fd);"
journal: do not remove multiple spaces after identifier in syslog message.,"+        if (p[e] != '\0' && strchr(WHITESPACE, p[e]))
+                e++;"
"When executing the udevadm trigger command, a memory leak may occur.","         r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);"
nss-mymachines: do not allow overlong machine names.,"+        if (e - p > HOST_NAME_MAX - 1) 
+                goto not_found;"
systemd-resolved through 233 allows remote attackers to cause a denial of service (daemon crash) via a crafted DNS response with an empty question section.,"        if (p->question->n_keys != 1)
                return 0;"
Units that failed to load were never cleaned up.,+        unit_add_to_gc_queue(u);
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,         unit_add_to_dbus_queue(u);
resolved: fix loop on packets with pseudo dns types.,"+                for (; bitmask; bit++, bitmask >>= 1)"
"A malicious DNS server can exploit this via a response with a specially crafted TCP payload to trick systemd-resolved into allocating a buffer that's too small, and subsequently write arbitrary data beyond the end of it.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
"This behaviour is definitely not expected by users, since tools generally only accept decimal numbers (e.g.","+        r = safe_atou32_full(s, 10, &uid);"
journald: don't accept arbitrarily sized journal data fields.,"+                        if (l > DATA_SIZE_MAX) {
+                                log_debug(""Received binary data block too large, ignoring."");
+                                break;
+                        }"
"Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.",-#define ENTRY_SIZE_MAX (1024*1024*32)
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","-                        if (r == -E2BIG)
-                                log_warning_errno(r, ""Entry is too above maximum of %u, aborting connection %p."","
nss-mymachines: do not allow overlong machine names.,"+        if (e - p > HOST_NAME_MAX - 1)
+                goto not_found;"
journal-remote: set a limit on the number of fields in a message.,"+                        if (r == -ENOBUFS)
+                                log_warning_errno(r, ""Entry is above the maximum of %u, aborting connection %p."",
                                                  DATA_SIZE_MAX, connection);"
"systemd 37-1 does not properly handle non-existent services, which causes a denial of service (failure of login procedure).",+        unit_add_to_gc_queue(u);
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
garbage collect units with load error.,+        unit_add_to_gc_queue(u);
So it seems that it's not uncommon for dhcp6-client to get the length wrong.,"+        if (*buflen < offsetof(DHCP6Option, data) + len)"
A race condition in chown_one() of systemd allows an attacker to cause systemd to set arbitrary permissions on arbitrary files.,"-                if (!S_ISLNK(st->st_mode))
-                        r = fchmodat(fd, name, st->st_mode, 0);"
A stack-based buffer overflow vulnerability was found in getpwnam()/getgrnam() functions of NSS module nss-mymachines provided by systemd.,"        r = parse_uid(e + 1, &uid);"
basic/user-util: always use base 10 for user/group numbers.,         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
bus_open leak sd_event_source when udevadm trigger.,+        b->io_event_source = sd_event_source_unref(b->io_event_source);
An out-of-bounds read when parsing a crafted syslog message that could lead to information disclosure.,         *buf = p + e;
journald: don't accept arbitrarily sized journal data fields.,+#define DATA_SIZE_MAX (1024*1024*64)
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        if (r == -ENOBUFS)
+                                log_warning_errno(r, ""Entry is above the maximum of %u, aborting connection %p."",
                                                  DATA_SIZE_MAX, connection);"
"An integer overflow, leading to heap-based buffer overflow flaw was found in the way journald functionality of systemd, a system and service manager, processed native messages.","+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
So let's follow suit and only accept numbers in decimal notation.,         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
journal: do not remove multiple spaces after identifier in syslog message.,"-        e += strspn(p + e, WHITESPACE);"
An out-of-bounds read when parsing a crafted syslog message that could lead to information disclosure.,"-        e += strspn(p + e, WHITESPACE);"
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,-                        return -errno;
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,+        unit_add_to_gc_queue(u);
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g.","+                if (r < 0)
+                        return log_error_errno(r, ""Failed to read serialization line: %m"");"
This can lead to a denial of service attack or arbitrary code execution in some cases.,"-                        if (r == -E2BIG)
-                                log_warning_errno(r, ""Entry is too above maximum of %u, aborting connection %p."","
"An integer overflow, leading to heap-based buffer overflow flaw was found in the way journald functionality of systemd, a system and service manager, processed native messages.",-#define ENTRY_SIZE_MAX (1024*1024*32)
Stack-based buffer overflow in the getpwnam and getgrnam functions of the NSS module nss-mymachines in systemd.,"        r = parse_uid(e + 1, &uid);"
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,"-               if (!fgets(line, sizeof(line), f)) {"
dhcp6 packet size calculation fixes.,"+        if (*buflen < offsetof(DHCP6Option, data) + len)"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                if (r < 0)
+                        return log_error_errno(r, ""Failed to read serialization line: %m"");"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
"This behaviour is definitely not expected by users, since tools generally only accept decimal numbers (e.g.",         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
resolved: simplify alloc size calculation.,"+        a = MAX(mtu, DNS_PACKET_HEADER_SIZE);"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
A buffer overflow vulnerability in the dhcp6 client of systemd allows a malicious dhcp6 server to overwrite heap memory in systemd-networkd.,        *buflen -= sizeof(DHCP6Option);
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,"-                        if (feof(f))
-                                return 0;"
fix loop on packets with pseudo dns types.,"+        if (!p->question)
+                return 0;"
"Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.","+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"A malicious DNS server can exploit this via a response with a specially crafted TCP payload to trick systemd-resolved into allocating a buffer that's too small, and subsequently write arbitrary data beyond the end of it.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
journald: don't accept arbitrarily sized journal data fields.,"+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
basic/user-util: always use base 10 for user/group numbers.,"+        r = safe_atou32_full(s, 10, &uid);"
