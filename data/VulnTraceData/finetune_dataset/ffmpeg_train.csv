text,code
"The aarch64_ext_ldst_reglist function in opcodes/aarch64-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+  if (value >= ARRAY_SIZE (data))
+    return 0;"
Fix seg-faults in objdump when disassembling a corrupt versados binary.,-         int offsetlen = flag & 0x7;
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
x86: Check for valid PLT section size Update x86 get_synthetic_symtab to check for valid PLT section size before examining PLT section contents.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-         int offsetlen = flag & 0x7;
Check for the index exceeding OP_BUF_LEN.,+#define GETBYTE() (ld->rl78->n_bytes < (OP_BUF_LEN - 1) ? ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr): 0)
Handle archives with corrupt extended name tables.,"+      if (amt > (bfd_size_type) bfd_get_size (abfd))
+       goto byebye;"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-         char hdr[8];
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347, rloc + reloc_size will cause integer overflow in line 13348.", 	  rloc = start + rp->r_offset;
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  size = bfd_get_section_size (sect);
Fix handling of corrupt STABS enum type strings.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
"The disassemble_bytes function in objdump.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of rae insns printing for this file during ""objdump -D"" execution.","-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
Fix address violation when disassembling a corrupt binary.,"-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
Fix a seg-fault triggered by reading a mal-formed archive.,"       if (amt + 1 == 0)
        goto byebye;"
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
Check for corrupt NAME:VALUE pairs.,"+      while (*p != ':' && *p != 0)
        ++p;"
Fix null pointer dereference when parsing a corrupt ELF binary.,          idx = (Elf_Internal_Group *) shdr->contents;
(alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix handling of corrupt STABS enum type strings.,"+      while (*p != ':' && *p != 0)
        ++p;"
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,-                 char datum = * ((char *) eopt + offset + len);
Check for corrupt NAME:VALUE pairs.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-             ent = print_mips_got_entry (data, pltgot, ent, data_end);"
Add sentinel.,"static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
Fix seg-fault reading malformed archive.,+         bfd_ardata (abfd)->extended_names = NULL;
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
But it does not forbid directory traversal in the paths.,+         bfd_ardata (abfd)->extended_names_size = 0;
Pass num_syms to target_specific_reloc_handling.," static bfd_boolean
 target_specific_reloc_handling (Elf_Internal_Rela * reloc,
                                unsigned char *     start,
                                unsigned char *     end,
+                               Elf_Internal_Sym *  symtab,
+                               unsigned long       num_syms)"
Fix address violation when disassembling a corrupt binary.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
I have checked in a small patch that adds a check for a NULL buffer pointer and then repsonds appropriately.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".","-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-         if (byte_get (data + ent - pltgot, addr_size)
-             >> (addr_size * 8 - 1) != 0)"
Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.,   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
Fix address violations when atempting to parse fuzzed binaries.,-  if (bfd_get_section_size (sect) < 0x24)
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
Exit early if passed an empty string.,"+  if (*orig == 0)
+    return (bfd_vma) 0;"
PR 21933 * elf.c (elf_read_notes): Check for a note size of -1.,-  if (size <= 0)
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+           if (start + reloc->r_offset + 4 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);
+           else
+             byte_put (start + reloc->r_offset, value, 4);"
Clip index to prevent overflow.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
Fix seg-fault reading malformed archive.,"+      if (amt > (bfd_size_type) bfd_get_size (abfd))
+       goto byebye;"
Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[300];
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
readelf: Fix overlarge memory allocation when reading a binary with an excessive number of program headers.,"+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
Fix seg-fault reading malformed archive.,+         bfd_ardata (abfd)->extended_names_size = 0;
Detect over large section offsets in the DT_SYMTAB entry.,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Pass num_syms to target_specific_reloc_handling.,"+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.",-      if (plt == NULL)
Update check for invalid word offsets in ARM unwind information.,"+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
(alpha_vms_object_p): Check for a truncated record.,+       (alpha_vms_object_p): Check for a truncated record.
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+         if (res == res_base)
+           return FALSE;"
Clip index to prevent overflow.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
Check valid bnd register.,"+      if (reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
The elf_read_notesfunction in bfd/elf.c in GNU Binutils 2.29 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Fix stack buffer overflows when parsing corrupt ihex files.,-      char hdr[8];
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
PR binutils/21591 * versados.c (versados_mkobject): Zero the allocated tdata structure.,"+      tdata_type *tdata = bfd_zalloc (abfd, amt);"
(alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
PR binutils/21157 * stabs.c (parse_stab_enum_type): Check for corrupt NAME:VALUE pairs.,"+      while (*p != ':' && *p != 0)
        ++p;"
Fix a seg-fault triggered by reading a mal-formed archive.,       bfd_ardata (abfd)->extended_names_size = amt;
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347, rloc + reloc_size will cause integer overflow in line 13348.",-	  if ((rloc + reloc_size) > end || (rloc < start))
Fix out of bounds memory access when trying to allocate space for a note of size -1.,-  if (size <= 0)
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"Date: Wed, 29 Aug 2012 20:11:50 +0200 From: Florian Weimer <fw@...eb.enyo.de> To: oss-security@...ts.openwall.com Subject: CVE-2012-3509: objalloc_alloc integer overflows in libiberty Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.","+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
"GNU Binutils 2017-04-03 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash), related to the process_mips_specific function in readelf.c, via a crafted ELF file that triggers a large memory-allocation attempt.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
Pass num_syms to target_specific_reloc_handling.,"+  if (reloc)
+    {
+      reloc_type = get_reloc_type (reloc->r_info);
+      sym_index = get_reloc_symindex (reloc->r_info);
+    }"
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt_entry_size
+                           + lazy_plt->plt_entry_size)))"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-                 char datum = * ((char *) eopt + offset + len);
"Error in ""OP_G"": global-buffer-overflow",       oappend (names64[modrm.reg + add]);
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+      if (modrm.reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
Check for the source pointer exceeding the end pointer before the first byte is read.,"+  if (src >= endp)
+    return FALSE;"
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,-                 char datum = * ((char *) eopt + offset + len);
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
Check for symbol table overflow before accessing symbol value.,"+           if (sym_index >= num_syms)
+             error (_(""MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             saved_sym = symtab + sym_index;
            return TRUE;"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix handling of corrupt STABS enum type strings.,"       name = savestring (*pp, p - *pp);"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
ld * testsuite/ld-nds32/diff.d: Adjust expected output.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, non_lazy_plt->plt_entry,"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
But it does not forbid directory traversal in the paths.,+         bfd_ardata (abfd)->extended_names = NULL;
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+         if (res == res_base)
+           return FALSE;"
Check for buffer overrun when printing out rae insns.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
"Fix read-after-free error in readelf when processing multiple, relocated sections in an MSP430 binary.","-         if (target_specific_reloc_handling (rp, start, end, symtab))"
(rl78_decode_opcode): Use OP_BUF_LEN as the length of the op_buf array.,+  unsigned char op_buf[OP_BUF_LEN] = {0};
Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[512];
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plt == NULL || plt->size == 0)
        continue;"
"readelf.c in GNU Binutils 2017-04-12 has a ""shift exponent too large for type unsigned long"" issue, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted ELF file.",-       unsigned long  val = 0;
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+         if (srcp + esdids + offsetlen >= endp)
+           return;"
"fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.",-  if (saved_file == NULL || file != saved_file)
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (memory consumption) via a crafted ELF file with many program headers, related to the get_program_headers function in readelf.c.","+  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
+                                        sizeof (Elf_Internal_Phdr));"
"readelf: fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  if (size < 0x24)
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-                 char datum = * ((char *) eopt + offset + len);
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-         char hdr[8];
"Unavailable data is handled gracefully in MIPS GOT processing done by `print_mips_got_entry', so all that is needed in special GOT[1] handling is to verify whether data can be retrieved for the purpose of the GNU marker check done with `byte_get'.","+      if (data
+         && data + ent - pltgot + addr_size <= data_end
+         && (byte_get (data + ent - pltgot, addr_size)
+             >> (addr_size * 8 - 1)) != 0)"
Use to check for corrupt pair relocs.,"+         if (res == res_base)
+           return FALSE;"
PR other/54411: integer overflow in objalloc_alloc 2012-09-18 Florian Weimer <fweimer@redhat.com> PR other/54411 * objalloc.h (objalloc_alloc): Do not use fast path on wraparound.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-      char hdr[8];
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,"   inote.namesz = H_GET_32 (abfd, enote->namesz);"
PR binutils/21157 * stabs.c (parse_stab_enum_type): Check for corrupt NAME:VALUE pairs.,"+      if (*p == 0)
+       {
+         bad_stab (orig);
+         free (names);
+         free (values);
+         return DEBUG_TYPE_NULL;
+       }"
Prevent address violation problem when disassembling corrupt aarch64 binary.,"+  if (value >= ARRAY_SIZE (data))
+    return 0;"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
"Multiple integer overflows in the (1) _objalloc_alloc function in objalloc.c and (2) objalloc_alloc macro in include/objalloc.h in GNU libiberty, as used by binutils 2.22, allow remote attackers to cause a denial of service (crash) via vectors related to the ""addition of CHUNK_HEADER_SIZE to the length,"" which triggers a heap-based buffer overflow.",   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
PR binutils/20892 * aoutx.h (find_nearest_line): Handle the case where the function name is empty.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"opcodes/rl78-decode.opc in GNU Binutils 2.28 has an unbounded GETBYTE macro, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-#define GETBYTE() (ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr))
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",       oappend (names_bnd[modrm.reg]);
"Error in ""OP_G"": global-buffer-overflow",       oappend (names_bnd[modrm.reg]);
"The ieee_object_p function in bfd/ieee.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, might allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  unsigned char buffer[300];
Check for the index exceeding OP_BUF_LEN.,+#define GETBYTE() (ld->rl78->n_bytes < (OP_BUF_LEN - 1) ? ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr): 0)
"GNU assembler in GNU Binutils 2.28 is vulnerable to a global buffer overflow (of size 1) while attempting to unget an EOF character from the input stream, potentially leading to a program crash.","+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
"The _bfd_vms_slurp_etir function in bfd/vms-alpha.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",+      if (cmd_length < 4 || (ptr + cmd_length > maxptr + 4))
Clip index to prevent overflow.,"+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
"The ieee_archive_p function in bfd/ieee.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, might allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  unsigned char buffer[512];
"Remove the extra error reporting code then, introduced with commit 75ec1fdbb797 (""Fix runtime seg-fault in readelf when parsing a corrupt MIPS binary."")",-         if (data + ent - pltgot > data_end - addr_size)
PR gas/20898 * app.c (do_scrub_chars): Do not attempt to unget EOF.,"+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,+  size = bfd_get_section_size (sect);
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,-                 char datum = * ((char *) eopt + offset + len);
readelf: Update check for invalid word offsets in ARM unwind information.,"+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","-                 && (memcmp (plt_contents + lazy_ibt_plt->plt_entry_size,"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"Error in ""sh_elf_set_mach_from_flags"": global-buffer-overflow",-  if (flags >= sizeof(sh_ef_bfd_table))
PR binutils/21379 * readelf.c (process_dynamic_section): Detect over large section offsets in the DT_SYMTAB entry.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
PR 21957 * elf.c (setup_group): Check for an empty or very small group section.,"+         if (idx == NULL || shdr->sh_size < 4)
+           {
+             _bfd_error_handler (_(""%B: group section '%A' has no contents""),
+                                 abfd, shdr->bfd_section);
+             elf_tdata (abfd)->group_sect_ptr[i] = NULL;
+             bfd_set_error (bfd_error_bad_value);
+             return FALSE;
+           }"
Fix a seg-fault disassembling a corrupt binary.,"+      if (buf == NULL)
+       {
+         return TRUE;
+       }"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt0_entry_size
+                           + lazy_plt->plt_entry_size)))"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.","-             error (_(""Invalid got entry - %#lx - overflows GOT table\n""),
-                    (long) ent);"
Pass num_syms to target_specific_reloc_handling.,"+                   if (start + reloc->r_offset + reloc_size >= end)
+                     error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                            start + reloc->r_offset + reloc_size, end);"
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,+  size = bfd_get_section_size (sect);
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MN10300 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
Fix shift overflow when parsing an overlarge note value.,"+       if (bytes > sizeof (val))
+         {
+           error (_(""corrupt name field: namesz of %lu is too large for a numeric value\n""),
+                  pnote->namesz);
+           return FALSE;
+         }"
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,+  size = bfd_get_section_size (sect);
"The setup_group function in elf.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a group section that is too small.","+         if (idx == NULL || shdr->sh_size < 4)
+           {
+             _bfd_error_handler (_(""%B: group section '%A' has no contents""),
+                                 abfd, shdr->bfd_section);
+             elf_tdata (abfd)->group_sect_ptr[i] = NULL;
+             bfd_set_error (bfd_error_bad_value);
+             return FALSE;
+           }"
(alpha_vms_object_p): Check for a truncated record.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
"Error in ""rl78_decode_opcode"": stack-buffer-overflow",-#define GETBYTE() (ld->op [ld->rl78->n_bytes++] = ld->getbyte (ld->ptr))
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
"The getsym function in tekhex.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (stack-based buffer over-read and application crash) via a malformed tekhex binary.",   *srcp = src + i;
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt_entry_size
+                           + lazy_plt->plt_entry_size)))"
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  size = bfd_get_section_size (sect);
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
"Multiple integer overflows in the (1) _objalloc_alloc function in objalloc.c and (2) objalloc_alloc macro in include/objalloc.h in GNU libiberty, as used by binutils 2.22, allow remote attackers to cause a denial of service (crash) via vectors related to the ""addition of CHUNK_HEADER_SIZE to the length,"" which triggers a heap-based buffer overflow.","+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
bfd * mach-o.c (bfd_mach_o_canonicalize_relocs): Pass the base address of the relocs to the canonicalize_one_reloc routine.,"+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
* readelf.c (process_mips_specific): Fix incorrect escape sequence handling.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
Check for an invalid offset in the otr structure.,"+         if (srcp + esdids + offsetlen >= endp)
+           return;"
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,+                 if (j + bpc <= stop_offset * opb)
PR binutils/21582 * ieee.c (ieee_object_p): Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[300];
Subject: CVE-2012-3509: objalloc_alloc integer overflows in libiberty.,   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-         char hdr[8];
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Fix null pointer dereference when parsing a corrupt ELF binary.,"          if (shdr == NULL)
            continue;"
"If reloc pointer is NULL, discard all saved state.","+       if (reloc == NULL)
+         {
+           saved_sym1 = saved_sym2 = 0;
+           return TRUE;
+         }"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents,
                      non_lazy_ibt_plt->plt_entry,"
Check for an out of range value.,"+  if (value >= ARRAY_SIZE (data))
+    return 0;"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
readelf: Fix overlarge memory allocation when reading a binary with an excessive number of program headers.,"+  if (elf_header.e_phnum
+      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
+      >= current_file_size)
+    {
+      error (_(""Too many program headers - %#x - the file is not that big\n""),
+            elf_header.e_phnum);
+      return FALSE;
+    }"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+         if (res == res_base)
+           return FALSE;"
Add num_syms parameter.," static bfd_boolean
 target_specific_reloc_handling (Elf_Internal_Rela * reloc,
                                unsigned char *     start,
                                unsigned char *     end,
+                               Elf_Internal_Sym *  symtab,
+                               unsigned long       num_syms)"
Check for buffer overflow before writing relocated values.,"+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MSP430 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  if (section_headers != NULL
+      && (saved_file == NULL || file != saved_file))"
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
"When ""uvalue"" is a specific value,  ""block_start + uvalue"" will cause integer overflow.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"+                     if (inf->display_endian == BFD_ENDIAN_LITTLE)
+                       {
+                         for (k = bpc - 1; k >= 0; k--)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }
+                     else
+                       {
+                         for (k = 0; k < bpc; k++)
+                           printf (""%02x"", (unsigned) data[j + k]);
+                       }"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.",-             goto got_print_fail;
binutils/ * readelf.c (process_mips_specific): Remove error reporting from GOT[1] processing.,-         if (data + ent - pltgot > data_end - addr_size)
Sang Kil Cha discovered that _objalloc_alloc does not guard the addition of CHUNK_HEADER_SIZE to the length against overflow.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
Check for buffer overrun when printing out rae insns.,"-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
"Error in ""print_insn_score16"": global-buffer-overflow","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
Pass num_syms to target_specific_reloc_handling.,"+         if (target_specific_reloc_handling (rp, start, end, symtab, num_syms))
            continue;"
Fix a seg-fault triggered by reading a mal-formed archive.,"       bfd_ardata (abfd)->extended_names = (char *) bfd_zalloc (abfd, amt + 1);"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
"readelf.c in GNU Binutils 2017-04-12 has a ""cannot be represented in type long"" issue, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted ELF file.","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
PR 24829 * readelf.c (apply_relocations): Catch potential integer overflow whilst checking reloc location against section size.,+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",+         unsigned int offsetlen = flag & 0x7;
Pass num_syms to target_specific_reloc_handling.,"+           if (sym_index >= num_syms)
+             error (_(""RL78_SYM reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             {
+               saved_sym2 = symtab[sym_index].st_value;
+               saved_sym2 += reloc->r_addend;
+             }
            return TRUE;"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,+  if (size < 0x24)
(alpha_vms_object_p): Check for a truncated record.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,+       (alpha_vms_object_p): Check for a truncated record.
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,+  if (size < 0x24)
"The disassemble_bytes function in objdump.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of rae insns printing for this file during ""objdump -D"" execution.","-                     for (k = 0; k < bpc; k++)
-                       printf (""%02x"", (unsigned) data[j + k]);"
Fix incorrect escape sequence on platform with signed char.,"       if (! ISPRINT (c))
+       sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);"
"readelf in GNU Binutils 2.28 writes to illegal addresses while processing corrupt input files containing symbol-difference relocations, leading to a heap-based buffer overflow.","+           if (start + reloc->r_offset + 2 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);"
ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.,-                 char datum = * ((char *) eopt + offset + len);
The elf_read_notesfunction in bfd/elf.c in GNU Binutils 2.29 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file.,-  if (size <= 0)
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
Fix seg-fault when trying to disassemble a corrupt score binary.,"static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
PR binutils/21578 * elf32-sh.c (sh_elf_set_mach_from_flags): Fix check for invalid flag value.,"+  if (flags >= ARRAY_SIZE (sh_ef_bfd_table))
     return FALSE;"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+  if (section_headers != NULL
+      && (saved_file == NULL || file != saved_file))"
PR binutils/21345 * readelf.c (process_mips_specific): Catch an unfeasible memory allocation before it happens and print a suitable error message.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
"When ""uvalue"" is a specific value, ""block_start + uvalue"" will cause integer overflow.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names = NULL;
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+         if (res == res_base)
+           return FALSE;"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to the byte_get_little_endian function in elfcomm.c, the get_unwind_section_word function in readelf.c, and ARM unwind information that contains invalid word offsets.","+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
"Maybe it can fix like this:
   if ((rloc + reloc_size) > end || (rloc < start) || (rloc + reloc_size) < start)



Triggering the bug requires accurate input. I'm not sure the poc file can trigger a crash in your environment.",+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
Check for buffer overflow before writing relocated values.,"+           if (start + reloc->r_offset + 2 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);"
"The get_build_id function in opncls.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted file in which a certain size field is larger than a corresponding data field, as demonstrated by mishandling within the objdump program.",       oappend (names64[modrm.reg + add]);
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,-         char hdr[8];
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
"PR binutils/18750 * ihex.c (ihex_scan): Fixes incorrect escape sequence in error message and stack overflow when char is signed and \\200-\\376 was in place of hex digit; also fixes \\377 was handled as EOF instead of ""incorrect character"".",-      char hdr[8];
"The aarch64_ext_ldst_reglist function in opcodes/aarch64-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",   info->reglist.num_regs = data[value].num_regs;
"The *regs* macros in opcodes/bfin-dis.c in GNU Binutils 2.28 allow remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, non_lazy_plt->plt_entry,"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define gregs(x, i) REGNAME (decode_gregs[(((i) << 3) | (x)) & 15])"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
"Which in turn will reset uvalue to a sane number, and so allow the rest of the code to continue.",+	  if (rloc >= end || (rloc + reloc_size) > end || (rloc < start))
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  if (size < 0x24)
Fix out of bounds memory access when trying to allocate space for a note of size -1.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Pass num_syms to target_specific_reloc_handling.,"+               if (sym_index >= num_syms)
+                 error (_(""MN10300 reloc contains invalid symbol index %lu\n""),
+                        sym_index);"
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
PR gas/20898 * app.c (do_scrub_chars): Do not attempt to unget EOF.,"+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plt == NULL || plt->size == 0)
        continue;"
 > * compress.c (bfd_get_full_section_contents): Check for and reject > a section whoes size is greater than the size of the entire file.,+  if (size < 0x24)
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
PR 21933 * elf.c (elf_read_notes): Check for a note size of -1.,"   if (bfd_seek (abfd, offset, SEEK_SET) != 0)"
Check for symbol table overflow before accessing symbol value.,"+           if (sym_index >= num_syms)
+             error (_(""MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             saved_sym = symtab + sym_index;
            return TRUE;"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
Fix buffer overrun when parsing a corrupt tekhex binary.,   *srcp = src + i;
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
2012-09-18 Florian Weimer <fweimer@redhat.com> PR other/54411 * objalloc.h (objalloc_alloc): Do not use fast path on wraparound.,"+  if (len + CHUNK_HEADER_SIZE < original_len)
+    return NULL;"
Check for buffer overflow before writing relocated values.,"+         if (target_specific_reloc_handling (rp, start, end, symtab))
            continue;"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.",-      if (plts[j].type == plt_unknown)
(rl78_decode_opcode): Use OP_BUF_LEN as the length of the op_buf array.,+  unsigned char op_buf[OP_BUF_LEN] = {0};
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,"   inote.type = H_GET_32 (abfd, enote->type);"
PR binutils/21378 * readelf.c (print_gnu_build_attribute_name): Check for an overlarge name field.,"+       if (bytes > sizeof (val))
+         {
+           error (_(""corrupt name field: namesz of %lu is too large for a numeric value\n""),
+                  pnote->namesz);
+           return FALSE;
+         }"
"The score_opcodes function in opcodes/score7-dis.c in GNU Binutils 2.28 allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","static struct score_opcode score_opcodes[] =
   {0x00000d05, 0x00007f0f, ""tvc!""},
   {0x00000026, 0x3e0003ff, ""xor\t\t%20-24r, %15-19r, %10-14r""},
   {0x00000027, 0x3e0003ff, ""xor.c\t\t%20-24r, %15-19r, %10-14r""},
-  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""}
+  {0x00002007, 0x0000700f, ""xor!\t\t%8-11r, %4-7r""},
+  { 0, 0, NULL }
 };"
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",       oappend (names64[modrm.reg + add]);
"Error in ""bfd_get_string"": stack-buffer-overflow.",-  unsigned char buffer[512];
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,-      char hdr[8];
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
"I have investigated alpha-heap-overflow, and there the fix is to check that `PRIV (recrd.rec_size) > test_len` before reading the remaining record.","+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Check valid bnd register.,"+      if (modrm.reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,+  size = bfd_get_section_size (sect);
"When (rloc = start + rp->r_offset) == 0xFFFFFFFF in line 13347,  rloc + reloc_size will cause integer overflow in line 13348. ",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
PR binutils/21591 * versados.c (versados_mkobject): Zero the allocated tdata structure.,+         unsigned int offsetlen = flag & 0x7;
Use to check for corrupt pair relocs.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
PR 21813 binutils* rddbg.c (read_symbol_stabs_debugging_info): Check for an empty string whilst concatenating symbol names.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,-      char hdr[8];
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,-         char hdr[8];
PR binutils/17533 * archive.c (_bfd_slurp_extended_name_table): Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names_size = 0;
PR binutils/21580 binutils * objdump.c (disassemble_bytes): Check for buffer overrun when printing out rae insns.,"-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
PR binutils/21586 * bfin-dis.c (gregs): Clip index to prevent overflow.,"+#define regs_lo(x, i) REGNAME (decode_regs_lo[(((i) << 3) | (x)) & 31])"
Check for buffer overflow before writing relocated values.,"+           if (start + reloc->r_offset + 4 >= end)
+             error (_(""RL78 sym diff reloc writes past end of section (%p vs %p)\n""),
+                    start + reloc->r_offset + 2, end);
+           else
+             byte_put (start + reloc->r_offset, value, 4);"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
"fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.","       iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));"
asan: arm-darwin: buffer overflow.,"+         if (res == res_base)
+           return FALSE;"
"The sh_elf_set_mach_from_flags function in bfd/elf32-sh.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-  if (flags >= sizeof(sh_ef_bfd_table))
Avoid a possible compiler bug by using a static buffer instead of a stack local buffer.,+  static unsigned char buffer[300];
Detect over large section offsets in the DT_SYMTAB entry. ,"+         if ((bfd_size_type) section.sh_offset > current_file_size)
+           {
+             /* See PR 21379 for a reproducer.  */
+             error (_(""Invalid DT_SYMTAB entry: %lx""), (long) section.sh_offset);
+             return FALSE;
+           }"
Clip index to prevent overflow.,"+#define regs(x, i) REGNAME (decode_regs[(((i) << 3) | (x)) & 31])"
Pass num_syms to target_specific_reloc_handling.,"+       if (reloc == NULL)
+         {
+           saved_sym = NULL;
+           return TRUE;
+         }"
Pass end to target_specific_reloc_handling.,"+         if (target_specific_reloc_handling (rp, start, end, symtab))
            continue;"
"The versados_mkobject function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not initialize a certain data structure, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","-      tdata_type *tdata = bfd_alloc (abfd, amt);"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+  if (elf_header.e_phnum
+      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
+      >= current_file_size)
+    {
+      error (_(""Too many program headers - %#x - the file is not that big\n""),
+            elf_header.e_phnum);
+      return FALSE;
+    }"
"When integer overflow, these two statements have different judgment results.",-	  if ((rloc + reloc_size) > end || (rloc < start))
PR binutils/17533 * archive.c (_bfd_slurp_extended_name_table): Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names = NULL;
PR binutils/21665 * objdump.c (disassemble_section): Move check for an overlarge section to just before the allocation of memory.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
Fix check for source pointer walking off the end of the input buffer.,"+  for (i = 0; i < len && (src + i) < endp; i++)
     dstp[i] = src[i];"
Pass num_syms to target_specific_reloc_handling.,"+               if (sym_index >= num_syms)
+                 error (_(""MSP430 reloc contains invalid symbol index %lu\n""),
+                        sym_index);"
==12394==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000000f1 at pc 0x000000433332 bp 0x7ffda722aff0 sp 0x7ffda722a780,"          if (memcmp (plt_contents, lazy_plt->plt0_entry,"
==14591==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4c00bf4 at pc 0xf72e3c75 bp 0xffa3a548 sp 0xffa3a11c.,   enote = (Elf_External_Note *) contents;
Pass num_syms to target_specific_reloc_handling.,+  unsigned long sym_index = 0;
"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS.",      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS.",			len = field[n].end - field[n].start;
Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file.,			as->s[as->length] = '\0';
> Undefined behavior / signed integer overflow in TAR parser.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.",        zip->entry_compressed_bytes_read += ENC_HEADER_SIZE;
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
"Using this malformed tar file with ""bsdtar -tf [input]"" will cause a signed integer overflow.","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS.","+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
The _ar_read_header function in archive_read_support_format_ar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds stack read) via a crafted ar file.,"                if (ar->strtab == NULL || number > ar->strtab_size) {
                        archive_set_error(&a->archive, EINVAL,
+                           ""Can't find long filename for GNU/SVR4 archive entry"");
                        archive_entry_copy_pathname(entry, filename);
                        ar_parse_common_header(ar, entry, h);
+                       return (ARCHIVE_FATAL);
                }"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
Issue #767: Buffer overflow printing a filename.,-		if (i > (sizeof(outbuff) - 20)) {
Fix integer overflow when computing location of volume descriptor,		skipsize -= iso9660->current_position;
Fuzzing with CRCs disabled revealed that a call to get_uncompressed_data() would sometimes fail to return at least 'minimum' bytes.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file.",	if (nrd < 0) {
Fuzzing with CRCs disabled revealed that a call to get_uncompressed_data() would sometimes fail to return at least 'minimum' bytes.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"	rab = __archive_read_ahead(a, 1U, &nrd);"
Fix typo in preprocessor macro in archive_read_format_zip_cleanup().,+#if HAVE_LZMA_H && HAVE_LIBLZMA
Resolves possible null-pointer dereference reported by OSS-Fuzz.,"-               else
-                       length = mbsnbytes(_p, n);"
==2650==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x607000000298 at pc 0x5586b16c5082 bp 0x7ffc3d24a950 sp 0x7ffc3d24a940.,			as->s[as->length] = '\0';
"read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",      filename[filename_size++] = '\0';
Heap-based buffer overflow in the zip_read_mac_metadata function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to execute arbitrary code via crafted entry-size values in a ZIP archive.,	metadata = malloc((size_t)rsrc->uncompressed_size);
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+			if ((size_t)bytes_avail > metadata_bytes)
+				bytes_avail = metadata_bytes;"
Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.,"      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,
        rar->dictionary_size, &g_szalloc))"
A memory leak in archive_read_format_zip_cleanup in archive_read_support_format_zip.c in libarchive 3.3.4-dev allows remote attackers to cause a denial of service via a crafted ZIP file because of a HAVE_LZMA_H typo.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Avoid a double-free when a window size of 0 is specified.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
Fix a possible heap-buffer-overflow in archive_string_append_from_wcs().,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
"Using this malformed tar file with ""bsdtar -tf [input]"" will cause a signed integer overflow.",        p->remaining = remaining;
7zip: fix crash when parsing certain archives.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
This is a simple NULL dereference leading to a crash.,"    new_window = realloc(rar->lzss.window, new_size);"
"libarchive version commit 379867ecb330b3a952fb7bfa7bffb7bbd5547205 onwards (release v3.3.0 onwards) contains a CWE-476: NULL Pointer Dereference vulnerability in ACL parser - libarchive/archive_acl.c, archive_acl_from_text_l() that can result in Crash/DoS.",			st = field[n].start + 1;
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
"When copying data into the allocated buffer, check the copy size against both the compressed entry size and uncompressed entry size.","+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Malformed OS X metadata entry: inconsistent size"");
+			return (ARCHIVE_FATAL);
+		}"
Limit write requests to at most INT_MAX.,"+	if (s > max_write)
+		s = max_write;"
"A RAR file with an invalid zero dictionary size was not being rejected, leading to a zero-sized allocation for the dictionary storage which was then overwritten during the dictionary initialization.","+      if (rar->dictionary_size == 0) {
+	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                          ""Invalid zero dictionary size"");
+	      return (ARCHIVE_FATAL);
+      }"
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Malformed OS X metadata entry: inconsistent size"");
+			return (ARCHIVE_FATAL);
+		}"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,-			numbers[argc++] = (unsigned long)mtree_atol(&p);
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,			outbuff[i] = '\0';
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
"While here, also reject headers with multiple EmptyFile, AntiFile, Name, or Attributes markers.","+			if (zip->entry_names != NULL)
+				return (-1);"
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,"			fprintf(f, ""%s"", outbuff);"
This is a simple NULL dereference leading to a crash.,			st = field[n].start + 1;
Stack out of bounds read in ar parser.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,"-               if (sc != NULL && (sc->flag & SCONV_FROM_UTF16))
-                       length = utf16nbytes(_p, n);"
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
The _ar_read_header function in archive_read_support_format_ar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds stack read) via a crafted ar file.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
This means that in some cases is not enough do few hours of fuzzing and believe that there aren?????t more bugs????? A crafted file causes a stack-buffer overflow write.,"			fprintf(f, ""%s"", outbuff);"
"When sanity-checking the size of an OS X metadata entry, abort this entry if either the compressed or uncompressed size is larger than 4MB.","+	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    ""Mac metadata is too large: %jd > 4M bytes"",
+		    (intmax_t)rsrc->compressed_size);
+		return (ARCHIVE_WARN);
+	}"
Fix a possible heap-buffer-overflow in archive_string_append_from_wcs().,			as->s[as->length] = '\0';
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
Avoid a read off-by-one error for UTF16 names in RAR archives.,-      filename[filename_size++] = '\0';
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
"While pruning trailing text from ar filenames, we did not check for an empty filename.","+       if (p < filename) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+                   ""Found entry with empty filename"");
+               return (ARCHIVE_FATAL);
+       }"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
Stack out of bounds read in ar parser.,"                if (ar->strtab == NULL || number > ar->strtab_size) {
                        archive_set_error(&a->archive, EINVAL,
+                           ""Can't find long filename for GNU/SVR4 archive entry"");
                        archive_entry_copy_pathname(entry, filename);
                        ar_parse_common_header(ar, entry, h);
+                       return (ARCHIVE_FATAL);
                }"
"The safe_fprintf function attempts to ensure clean output for an arbitrary sequence of bytes by doing a trial conversion of the multibyte characters to wide characters -- if the resulting wide character is printable then we pass through the corresponding bytes unaltered, otherwise, we convert them to C-style ASCII escapes.",+		if (i > (sizeof(outbuff) - 128)) {
Resolves possible null-pointer dereference reported by OSS-Fuzz.,"-               if (sc != NULL && (sc->flag & SCONV_FROM_UTF16))
-                       length = utf16nbytes(_p, n);"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,			zip->entry_names = malloc(ll);
Issue 761: Heap overflow reading corrupted 7Zip files.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
This is a simple NULL dereference leading to a crash.,			len = field[n].end - field[n].start;
Signed integer overflows are undefined in C.,        p->remaining = remaining;
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.","        p = __archive_read_ahead(a, ENC_HEADER_SIZE, NULL);"
==13144==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000038800 at pc 0x7fb1c808f650 bp 0x7ffdd1b40990 sp 0x7ffdd1b40988,	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,			zip->entry_names = malloc(ll);
\307q\005\bo\002\244\201\350\003\350\003libarchive/archive_read_support_format_tar.c:612:10: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type 'long'.,        p->remaining = remaining;
Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.,"+      if (rar->dictionary_size == 0) {
+	      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                          ""Invalid zero dictionary size"");
+	      return (ARCHIVE_FATAL);
+      }"
This means that in some cases is not enough do few hours of fuzzing and believe that there aren?????t more bugs????? A crafted file causes a stack-buffer overflow write.,			outbuff[i] = '\0';
"This means that if you specify an invalid content length, it will just reprint the same data over and over and over again until it hits the desired length.","+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
"Issue #582: reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks.","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
The archive_read_format_cpio_read_header function in archive_read_support_format_cpio.c in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a CPIO archive with a large symlink.,"h = __archive_read_ahead(a,
			(size_t)cpio->entry_bytes_remaining, NULL);"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
array subscript is above array bounds,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
Limit write requests to at most INT_MAX.,+	const size_t max_write = INT_MAX;
==2650==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x607000000298 at pc 0x5586b16c5082 bp 0x7ffc3d24a950 sp 0x7ffc3d24a940.,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
This fix provides three new checks to guard against such manipulation and to make libarchive generally more robust when handling this type of entry.,"+	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
+		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+		    ""Mac metadata is too large: %jd > 4M bytes"",
+		    (intmax_t)rsrc->compressed_size);
+		return (ARCHIVE_WARN);
+	}"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","	rab = __archive_read_ahead(a, 1U, &nrd);"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
array subscript is above array bounds,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
"libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c.",	while (char_cnt-- > 0) {
consume data once read.,"+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,			outbuff[i] = '\0';
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,-		if (i > (sizeof(outbuff) - 20)) {
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.",	if (nrd < 0) {
Crash Type: Heap-buffer-overflow READ {*} Crash Address: 0x6140000009f8 Crash State: read_header archive_read_format_rar_read_header _archive_read_next_header2 Sanitizer: address (ASAN) Recommended Security Severity: Medium Package: libarchive13 Version: 3.2.2-3.1 $ valgrind --quiet -- bsdtar -xf oob.rar ==1880== Invalid read of size 1 ==1880== at 0x4832FF0: memcpy (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B5E0: memcpy (string3.h:53) ==1880== by 0x489B5E0: read_header (archive_read_support_format_rar.c:1577) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== Address 0x6ca726a is 0 bytes after a block of size 98 alloc'd ==1880== at 0x482E1FC: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x4830520: realloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B451: read_header (archive_read_support_format_rar.c:1423) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== bsdtar: Unknown file attributes from RAR file's host OS bsdtar: Error exit delayed from previous errors.,      filename[filename_size++] = '\0';
"When we grow the archive_string buffer, we have to make sure it fits at least one maximum-sized multibyte character in the current locale and the null character.","			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
Avoid a double-free when a window size of 0 is specified.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
7zip: fix crash when parsing certain archives.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"A simple cast suffices to fix this since the base location is always 32 bits for ISO, so multiplying by the sector size will never overflow a 64-bit integer.",+	skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
Fix integer overflow when computing location of volume descriptor.,		skipsize -= iso9660->current_position;
archive_strncat_l(): allocate and do not convert if length == 0.,-       if (length == 0) {
Avoid a read off-by-one error for UTF16 names in RAR archives.,      filename[filename_size++] = '\0';
Crash Type: Heap-buffer-overflow READ {*},      filename[filename_size++] = '\0';
==27792==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010800 at pc 0x6169dd bp 0x7ffff41b2ef0 sp 0x7ffff41b2ee0.,        zip->entry_compressed_bytes_read += ENC_HEADER_SIZE;
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->antiBools != NULL)
+				return (-1);"
> Undefined behavior / signed integer overflow in TAR parser.,        p->remaining = remaining;
Crash Type: Heap-buffer-overflow READ {*} Crash Address: 0x6140000009f8 Crash State: read_header archive_read_format_rar_read_header _archive_read_next_header2 Sanitizer: address (ASAN) Recommended Security Severity: Medium Package: libarchive13 Version: 3.2.2-3.1 $ valgrind --quiet -- bsdtar -xf oob.rar ==1880== Invalid read of size 1 ==1880== at 0x4832FF0: memcpy (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B5E0: memcpy (string3.h:53) ==1880== by 0x489B5E0: read_header (archive_read_support_format_rar.c:1577) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== Address 0x6ca726a is 0 bytes after a block of size 98 alloc'd ==1880== at 0x482E1FC: malloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x4830520: realloc (in /usr/lib/valgrind/vgpreload_memcheck-x86-linux.so) ==1880== by 0x489B451: read_header (archive_read_support_format_rar.c:1423) ==1880== by 0x489C347: archive_read_format_rar_read_header (archive_read_support_format_rar.c:932) ==1880== by 0x4873A54: _archive_read_next_header2 (archive_read.c:649) ==1880== by 0x4873B5B: _archive_read_next_header (archive_read.c:687) ==1880== by 0x10D384: read_archive (read.c:261) ==1880== by 0x10DCAC: tar_mode_x (read.c:112) ==1880== by 0x10C2BB: main (bsdtar.c:809) ==1880== bsdtar: Unknown file attributes from RAR file's host OS bsdtar: Error exit delayed from previous errors.,-      filename[filename_size++] = '\0';
"A simple cast suffices to fix this since the base location is always 32 bits for ISO, so multiplying by the sector size will never overflow a 64-bit integer.",-		skipsize = LOGICAL_BLOCK_SIZE * vd->location;
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,			zip->entry_names = malloc(ll);
The multiplication here defaulted to 'int' but calculations of file positions should always use int64_t.,+		skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,"-               else
-                       length = mbsnbytes(_p, n);"
Do something sensible for empty strings to make fuzzers happy.,"+	if (char_cnt == 0)
+		return (0);"
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,"			fprintf(f, ""%s"", outbuff);"
Memory leak when decoding LZMA #1165.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
Avoid a double-free when a window size of 0 is specified.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
"libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service). This attack appears to be exploitable via the victim opening a specially crafted 7zip file.",*buff = zip->uncompressed_buffer_pointer;
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->emptyStreamBools != NULL)
+				return (-1);"
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
==27792==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010800 at pc 0x6169dd bp 0x7ffff41b2ef0 sp 0x7ffff41b2ee0.,-       zip->entry_bytes_remaining -= ENC_HEADER_SIZE;
Fix libarchive/archive_read_support_format_mtree.c:1388:11: error: array subscript is above array bounds.,"+			if (argc >= MAX_PACK_ARGS) {
				archive_set_error(a, ARCHIVE_ERRNO_FILE_FORMAT,
				    ""Too many arguments"");
				return ARCHIVE_WARN;
			}"
7zip: fix crash when parsing certain archives.,"-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"Integer overflow in the read_SubStreamsInfo function in archive_read_support_format_7zip.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a 7zip file with a large number of substreams, which triggers a heap-based buffer overflow.","+			if (unpack_streams > SIZE_MAX - UMAX_ENTRY) {
+				return (-1);
+			}"
Signed integer overflows are undefined in C.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
"The trad_enc_decrypt_update function in archive_read_support_format_zip.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (out-of-bounds heap read and crash) via a crafted zip file, related to reading the password.",-       zip->entry_bytes_remaining -= ENC_HEADER_SIZE;
==15753==ERROR: LeakSanitizer: detected memory leaks.,-#if HAVA_LZMA_H && HAVE_LIBLZMA
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.","	rab = __archive_read_ahead(a, 1U, &nrd);"
Signed integer overflows are undefined in C.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
7zip: fix crash when parsing certain archives.,"+		*buff = __archive_read_ahead(a, minimum, &bytes_avail);"
This prevents a certain common programming error (passing -1 to write) from leading to other problems deeper in the library.,+	const size_t max_write = INT_MAX;
Stop this by checking that the length is not zero before beginning the switch statement.,"+			if (len == 0) {
+				ret = ARCHIVE_WARN;
+				continue;
+			}"
detected memory leaks,-#if HAVA_LZMA_H && HAVE_LIBLZMA
libarchive: bsdtar: stack-based buffer overflow in bsdtar_expand_char (util.c).,-		if (i > (sizeof(outbuff) - 20)) {
Fail if entry is too small for encryption header.,"+       if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)
+           && zip->entry_bytes_remaining < ENC_HEADER_SIZE) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                   ""Truncated Zip encrypted body: only %jd bytes available"",
+                   (intmax_t)zip->entry_bytes_remaining);
+               return (ARCHIVE_FATAL);
+       }"
==13144==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000038800 at pc 0x7fb1c808f650 bp 0x7ffdd1b40990 sp 0x7ffdd1b40988,	while (char_cnt-- > 0) {
"Crash analysis : In archive_string_append_from_wcs() (archive_string.c), upon execution of the crashing input (crash-file): archive_string_append_from_wcs(){ .... // Allocated heap memory for as->s is 72 bytes in range (0x607000000250,0x607000000298) p = as->s + as->length; ... while (*w != L'\0' && len > 0) { ... #if HAVE_WCRTOMB n = wcrtomb(p, *w++, &shift_state); // p = 0x611000000628 --> 0x00, wcrtomb() returns 3, n = 3 #else n = wctomb(p, *w++); #endif if (n == -1) { if (errno == EILSEQ) { ... } else p += n; // p = 0x611000000628 --> 0x00 len--; } as->length = p - as->s; // as->length = 72. as->s[as->length] = '\0'; // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.","			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
"but only a few hundred bytes of data, causes a quasi-infinite loop.",		*bsz = 0U;
==6259==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7fae139bf660 at pc 0x0000004957dc bp 0x7ffc9de91a90 sp 0x7ffc9de91240.,-		if (i > (sizeof(outbuff) - 20)) {
This is a simple NULL dereference leading to a crash.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
"libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file.",		*bsz = 0U;
warc: consume data once read.,"+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
Avoid a read off-by-one error for UTF16 names in RAR archives.,+      filename[filename_size] = '\0';
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,-       if (_p != NULL && n > 0) {
"While here, also reject headers with multiple EmptyFile, AntiFile, Name, or Attributes markers.","+			if (h->attrBools != NULL)
+				return (-1);"
"The first (patch 1) is a double-free via a realloc(area, 0).","  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
"read_header in archive_read_support_format_rar.c in libarchive 3.3.2 suffers from an off-by-one error for UTF-16 names in RAR archives, leading to an out-of-bounds read in archive_read_format_rar_read_header.",-      filename[filename_size++] = '\0';
libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-416: Use After Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c that can result in Crash/DoS - it is unknown if RCE is possible.,"  rar->filename_save = (char*)realloc(rar->filename_save,
                                      filename_size + 1);"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
as->s[as->length] = '\0';    // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.,			as->s[as->length] = '\0';
"but only a few hundred bytes of data, causes a quasi-infinite loop.","	rab = __archive_read_ahead(a, 1U, &nrd);"
ibarchive: heap-based buffer overflow in xml_data (archive_read_support_format_xar.c).,	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
Skip 0-length ACL fields.,"+			if (len == 0) {
+				ret = ARCHIVE_WARN;
+				continue;
+			}"
The fix here is to reject any header with multiple EmptyStream attributes.,"+			if (h->emptyFileBools != NULL)
+				return (-1);"
Signed integer overflows are undefined in C.,        p->remaining = remaining;
"Issue #582: reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks.","+       if (remaining < 0 || offset < 0) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, ""Malformed sparse map data"");
+               return (ARCHIVE_FATAL);
+       }"
"That would check the new file name against the old file name, and if they didn't match up it would free the ppmd7 buffer and allocate a new one.","+  else if (rar->filename_must_match)
+  {
+    archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+      ""Mismatch of file parts split across multi-volume archive"");
+    return (ARCHIVE_FATAL);
+  }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,			len = field[n].end - field[n].start;
The read_Header function in archive_read_support_format_7zip.c in libarchive 3.2.1 allows remote attackers to cause a denial of service (out-of-bounds read) via multiple EmptyStream attributes in a header in a 7zip archive.,"			h->antiBools = calloc(empty_streams,
			    sizeof(*h->antiBools));"
Heap-based buffer overflow in archive_string_append_from_wcs() (archive_string.c) in libarchive-3.4.1dev allows remote attackers to cause a denial of service (out-of-bounds write in heap memory resulting into a crash) via a crafted archive file.,			end = as->s + as->buffer_length - MB_CUR_MAX -1;
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,"    new_window = realloc(rar->lzss.window, new_size);"
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,			outbuff[i] = '\0';
Reject cpio symlinks that exceed 1MB.,"+		if (cpio->entry_bytes_remaining > 1024 * 1024) {
+			archive_set_error(&a->archive, ENOMEM,
+			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
+			return (ARCHIVE_FATAL);
+		}"
==27481==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000ecbb at pc 0x7f01eb0e55fc bp 0x7fff63005ad0 sp 0x7fff63005ac8.,"			h->emptyStreamBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->emptyStreamBools));"
"libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service).","-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
"While here, change a number of ar format issues from WARN to FATAL.","+       if (p < filename) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+                   ""Found entry with empty filename"");
+               return (ARCHIVE_FATAL);
+       }"
Do something sensible for empty strings to make fuzzers happy.,"+	if (char_cnt == 0)
+		return (0);"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->emptyFileBools = calloc(empty_streams,
			    sizeof(*h->emptyFileBools));"
Stack-based buffer overflow in the safe_fprintf function in tar/util.c in libarchive 3.2.1 allows remote attackers to cause a denial of service via a crafted non-printable multibyte character in a filename.,"			fprintf(f, ""%s"", outbuff);"
A crafted file causes an heap overflow in the read_Header function in the 7zip parser.,			zip->entry_names = malloc(ll);
Resolves possible null-pointer dereference reported by OSS-Fuzz.,-       if (_p != NULL && n > 0) {
\307q\005\bo\002\244\201\350\003\350\003libarchive/archive_read_support_format_tar.c:612:10: runtime error: signed integer overflow: 9223372036854775807 + 1 cannot be represented in type 'long'.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,+			numbers[argc++] = (unsigned long)mtree_atol(&p);
bsdtar in libarchive before 3.2.0 allows remote attackers to cause a denial of service (infinite loop) via an ISO with a directory that is a member of itself.,-	file->offset = iso9660->logical_block_size * (uint64_t)location;
The code can be made to read and write to a previously freed ppmd buffer by tricking the read-ahead code around multi-part archives.,			st = field[n].start + 1;
Issue 403: Buffer underflow parsing 'ar' header.,"                if (ar->strtab != NULL) {
                        archive_set_error(&a->archive, EINVAL,
                            ""More than one string tables exist"");
+                       return (ARCHIVE_FATAL);
                }"
"Content-Length: 666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666665 but only a few hundred bytes of data, causes a quasi-infinite loop.",		*bsz = 0U;
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.",	if (nrd < 0) {
Integer overflow in the ISO parser in libarchive before 3.2.1 allows remote attackers to cause a denial of service (application crash) via a crafted ISO file.,		skipsize -= iso9660->current_position;
"bsdtar: An error in archive_string_append_from_wcs() (archive_string.c) triggers an out-of-bounds write in heap memory that results into a crash, via a specially crafted archive file.",			as->s[as->length] = '\0';
"reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks","+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.","    new_window = realloc(rar->lzss.window, new_size);"
as->s[as->length] = '\0'; // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.,"			if (archive_string_ensure(as,
+			    as->length + max(len * 2,
+			    (size_t)MB_CUR_MAX) + 1) == NULL)
				return (-1);"
The archive_wstring_append_from_mbs function in archive_string.c in libarchive 3.2.2 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via a crafted archive file.,-       if (length == 0) {
This prevents a certain common programming error (passing -1 to write) from leading to other problems deeper in the library.,"+	if (s > max_write)
+		s = max_write;"
Integer overflow in the archive_read_format_tar_skip function in archive_read_support_format_tar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (crash) via a crafted tar file.,        p->remaining = remaining;
Fixes a heap buffer overflow reported in Secunia SA74169.,	lha->compsize -= extdsize - 2;
Resolves possible null-pointer dereference reported by OSS-Fuzz.,-       if (length == 0) {
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-		set1->nodeMax *= 2;
The functions xmlParserEntityCheck() and xmlParseAttValueComplex() used to call xmlStringDecodeEntities() in a recursive context without incrementing the 'depth' counter in the parser context.,+        ++ctxt->depth;
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-		set1->nodeMax *= 2;
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
Global buffer-overflow in the htmlParseTryOrFinish function.," 	ctxt->input->cur = BAD_CAST"""";"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
Heap-based buffer overread in xmlDictAddString. ,        if ((*in > 0) && (*in < 0x80)) {
A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case.,-            arg1->boolval |= arg2->boolval;
Buffer overead with HTML parser in push mode. ,"-					    ctxt->userData, &cur, 1);"
Fix inappropriate fetch of entities content.,"-		    xmlLoadEntityContent(ctxt, ent);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
"Store start position instead of a pointer to the name since the underlying buffer may change, resulting in a stale pointer being used.",+    startPosition = CUR_PTR - BASE_PTR;
A NULL pointer dereference vulnerability exists in the xpath,-            arg1->boolval |= arg2->boolval;
The xmlSAX2TextNode function in SAX2.c in the push interface in the HTML parser in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (stack-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.,"-					    ctxt->userData, &cur, 1);"
"Multiple use-after-free vulnerabilities in libxml2 2.9.0 and possibly other versions might allow context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to the (1) htmlParseChunk and (2) xmldecl_done functions, as demonstrated by a buffer overflow in the xmlBufGetInputBase function.", 	if (res < 0) {
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"A flaw in libxml2 allows remote XML entity inclusion with default parser flags (i.e., when the caller did not request entity substitution, DTD validation, external DTD subset loading, or default DTD attributes).","+	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+		(ctxt->replaceEntities == 0) &&
+		(ctxt->validate == 0))
+		return;"
Limit available memory to 100MB to avoid exhaustive memory consumption by malicious files.,             xmlFree(state->out);
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for entity references replacement (--noent option) was requested / enabled during the XML file parsing.",+    if (replacement != 0) {
"A remote attacker could provide a specially-crafted XML file containing an external entity expansion, when processed would lead to excessive CPU consumption (denial of service).",-    if (ent->checked == 0) {
"There are times, like on unterminated entities that it's preferable to stop parsing, even if that means less error reporting.",+	xmlStopParser(ctxt);
Avoid an out of bound access when serializing malformed strings.,+            } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {
Fix some potential problems on reallocation failures.,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
Check that the XPath stack isn't empty and optimize the logic operators slightly.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
Bug 763071: heap-buffer-overflow in xmlStrncat.,     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
The attached document will cause an out of bounds heap read access in the function xmlParseXMLDecl.,            encoding = xmlParseEncName(ctxt);
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-        cur->nodeMax *= 2;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
handle properly the case where we popped out of the current entity while processing a start tag.,"+    if (inputNr != ctxt->inputNr) {
+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
+		    ""Start tag doesn't start and stop in the same entity\n"");
+	return(NULL);
+    }"
Fix inappropriate fetch of entities content For https://bugzilla.gnome.org/show_bug.cgi?id=761430.,"+		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+			(ctxt->validate != 0)) {
+			xmlLoadEntityContent(ctxt, ent);
+		    } else {
+			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
+		  ""not validating will not read content for PE entity %s\n"",
+		                      ent->name, NULL);
+		    }"
Fix the semantic of XPath axis for namespace/attribute context nodes. ,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
Then xmlSchemaVStart->xmlSchemaPreRun initialize vctxt->xsiAssemble to 0 again which cause the alloced schema can not be freed anymore.,-    vctxt->xsiAssemble = 0;
The count was incremented before the allocation and not fixed in case of failure.,+        cur->nodeMax *= 2;
Bug 758605: Heap-based buffer overread in xmlDictAddString.," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
"If the option --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file.",while (strm->avail_out && ret != LZMA_STREAM_END);
The count was incremented before the allocation and not fixed in case of failure.," 		temp = (xmlNodePtr *) xmlRealloc(
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));"
Fix potential out of bound access.,+        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
Only advance to the next character if there is no error.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
Heap-based buffer-underreads due to xmlParseName.,         name = xmlParseName(ctxt);
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects.,-	    blen += 6;
"Hey, There appears to be an out-of-bounds read in libxml2 (2.9.2)."," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
Approvement in LZMA error handling which prevents an infinite loop.,"+        if ((state->how != GZIP) &&
+            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {
+            xz_error(state, ret, ""lzma error"");
+            return -1;
+        }"
Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.,-            arg1->boolval |= arg2->boolval;
==2994== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60040000d5d3 at pc 0x73320a bp 0x7fffffffc1e0 sp 0x7fffffffc1d8,-            } else if (*cur < 0xF8) {
"Vulnerability class: Null deref, Denial of Service.","-            valuePush(ctxt, arg1);"
"Started by Chris Evans, I added a few more place where the error should have been set in the evaluation context.",+                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
Heap-based buffer overflow in the xmlDictComputeFastQKey function in dict.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service via unspecified vectors.,-        value += name[len - (plen + 1 + 1)];
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
Avoid an heap buffer overflow in xmlDictComputeFastQKey.,-        value += name[len - (plen + 1 + 1)];
"Double free vulnerability in libxml2, as used in Google Chrome before 14.0.835.163, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.","         if (tmp == NULL) {
             xmlGenericError(xmlGenericErrorContext, ""realloc failed !\n"");
+            ctxt->error = XPATH_MEMORY_ERROR;
             return (0);
         }"
It was possible to hit a negative offset in the name indexing used to randomize the dictionary key generation,-        value += name[len - (plen + 1 + 1)];
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,+            } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",     buf[len] = 0;
Limit available memory to 100MB to avoid exhaustive memory consumption by malicious files.,"+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
"The xz_head function in xzlib.c in libxml2 before 2.9.6 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.","+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
Check the liblzma error code more thoroughly to avoid infinite loops.,"+        if ((state->how != GZIP) &&
+            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {
+            xz_error(state, ret, ""lzma error"");
+            return -1;
+        }"
the current pointer to the input has to be between the base and end. ,"+    if ((ctxt->input->cur > ctxt->input->end) ||
+        (ctxt->input->cur < ctxt->input->base)) {
+        xmlHaltParser(ctxt);
+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, ""cur index out of bound"");
+	return;
+    }"
"A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference.","+        if (cur == NULL)
+            return(NULL);"
"The xz_head function in libxml2 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.","+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case.,"-            valuePush(ctxt, arg1);"
"XML external entity (XXE) vulnerability in the xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.4, when not in validating mode, allows context-dependent attackers to read arbitrary files or cause a denial of service (resource consumption) via unspecified vectors.","+		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+			(ctxt->validate != 0)) {
+			xmlLoadEntityContent(ctxt, ent);
+		    } else {
+			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
+		  ""not validating will not read content for PE entity %s\n"",
+		                      ent->name, NULL);
+		    }"
Fix some potential problems on reallocation failures.,"-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
"libxml2 2.9.8, if --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file that triggers LZMA_MEMLIMIT_ERROR, as demonstrated by xmllint, a different vulnerability than CVE-2015-8035 and CVE-2018-9251.",while (strm->avail_out && ret != LZMA_STREAM_END);
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application."," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
Fix user-after-free with `xmllint --xinclude --dropdtd`. ,-                   (cur->children->type != XML_XINCLUDE_END)) {
"(pushParseTest): The input for the new test case was so small (4 bytes) that htmlParseChunk() was never called after htmlCreatePushParserCtxt(), thereby creating a false positive test failure.","     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
Fix missing error status in XPath evaluation.,+    ctxt->error = XPATH_INVALID_OPERAND;
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-		set1->nodeMax *= 2;
Buffer overead with HTML parser in push mode. ,"-						ctxt->userData, &cur, 1);"
Add missing increments of recursion depth counter to XML parser.,+        ++ctxt->depth;
* HTMLparser.c: (htmlParseName): Add bounds check.,"+	if (in == ctxt->input->end)
+	    return(NULL);"
Fix a potential freeing error in XPath,-		valuePop(ctxt);
Fix potential out of bound access.,-        while (buf[len - 1] == 0x20) len--;
Avoid an out of bound access when serializing malformed strings.,-            } else if (*cur < 0xF8) {
"The xmlDictAddString function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.", 	if ((*in > 0) && (*in < 0x80)) {
"If the XPath stack is corrupted, for example by a misbehaving extension function, the ""and"" and ""or"" XPath operators could dereference NULL pointers.","-            valuePush(ctxt, arg1);"
The functions xmlParserEntityCheck() and xmlParseAttValueComplex() used to call xmlStringDecodeEntities() in a recursive context without incrementing the 'depth' counter in the parser context.,+			++ctxt->depth;
The comprehensive fix is to change the return type of xmlStrlen() to size_t so that it doesn't overflow.,"+    if (size < 0)
+        return(NULL)"
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						      XML_SUBSTITUTE_REF,
 						      0, 0, 0);"
when the end of the internal subset isn't properly detected xmlParseInternalSubset should just return instead of trying to process input further.,"     if (RAW != '>') {
 	xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);
+	return;
     }"
"When doc is NULL, namespace created in xmlTreeEnsureXMLDecl is bind to newDoc->oldNs, in this case, set newDoc->oldNs to NULL and free newDoc will cause a memory leak.","+    if(doc != NULL)
+	newDoc->oldNs = NULL;"
"There are times, like on unterminated entities that it's preferable to stop parsing, even if that means less error reporting.",+	    xmlStopParser(ctxt);
Fix missing error status in XPath evaluation. ,+    ctxt->error = XPATH_INVALID_OPERAND;
Fix an off by one pointer access.,-	    *cur++ = CUR;
"libxml2 2.9.0-rc1 and earlier, as used in Google Chrome before 21.0.1180.89, does not properly support a cast of an unspecified variable during handling of XSL transforms, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document, related to the _xmlNs data structure in include/libxml/tree.h.","+	if (node->type != XML_NAMESPACE_DECL)
+	    cur = node->children;
+	else
+	    cur = NULL;"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-	    val1->nodeMax *= 2;
The count was incremented before the allocation and not fixed in case of failure.,+		set1->nodeMax *= 2;
"A remote attacker could provide a specially-crafted XML file containing an external entity expansion, when processed would lead to excessive CPU consumption (denial of service).",} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
Make sure to set 'attvalue' to NULL after freeing it.,+		if ((attvalue != NULL) && (alloc != 0)) {
* parser.c: do not load external parsed entities unless needed.,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
"If an untrusted XML document was parsed in recovery mode and post-validated, the flaw could be used to crash the application."," 	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                           depth + 1);"
Fix memory access error due to incorrect entities boundaries.,-	if (ctxt->input->base != base) goto base_changed;
Fix default template processing on namespace nodes.,"+		case XML_NAMESPACE_DECL:
+		    break;"
"The xz_head function in libxml2 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.",             xmlFree(state->in);
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for external entity references replacement (--noent option) was requested / enabled during the XML file parsing.","+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
An attacker who is able to submit a crafted file to be processed by an application linked with libxml2 could trigger a use-after-free.,-                   (cur->children->type != XML_XINCLUDE_END)) {
Heap-based buffer overread in xmlDictAddString. ,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
libfuzzer regression testing exposed another case where the parser would fetch content of an external entity while not in validating mode.,"+		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+			(ctxt->validate != 0)) {
+			xmlLoadEntityContent(ctxt, ent);
+		    } else {
+			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
+		  ""not validating will not read content for PE entity %s\n"",
+		                      ent->name, NULL);
+		    }"
Fix some potential problems on reallocation failures.,-		set1->nodeMax *= 2;
Fix user-after-free with `xmllint --xinclude --dropdtd`.,-                   (cur->children->type != XML_ENTITY_DECL) &&
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
Fix memory access error due to incorrect entities boundaries.,-		if (ctxt->input->base != base) goto base_changed;
CVE-2015-7497 Avoid an heap buffer overflow in xmlDictComputeFastQKey.,-        value += name[len - (plen + 1 + 1)];
A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case.,-            arg1->boolval &= arg2->boolval;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
It was possible to hit a negative offset in the name indexing used to randomize the dictionary key generation.,-        value += name[len - (plen + 1 + 1)];
Fix some potential problems on reallocation failures.," 		temp = (xmlNodePtr *) xmlRealloc(
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));"
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for external entity references replacement (--noent option) was requested / enabled during the XML file parsing.",-    if (ent->checked == 0) {
Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.,"-            valuePush(ctxt, arg1);"
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
Fix default template processing on namespace nodes.,"+	if (node->type != XML_NAMESPACE_DECL)
+	    cur = node->children;
+	else
+	    cur = NULL;"
* xmlstring.c: (xmlStrncat): Return NULL if xmlStrlen returns a negative length.,"+    if (size < 0)
+        return(NULL);"
"libxml2 before 2.7.8, as used in Google Chrome before 7.0.517.44, Apple Safari 5.0.2 and earlier, and other products, reads from invalid memory locations during processing of malformed XPath expressions, which allows context-dependent attackers to cause a denial of service (application crash) via a crafted XML document.","     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
The pointers from the context input were not properly reset after that call which can do reallocations.,+	size_t current = ctxt->input->cur - ctxt->input->base;
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
"WebKitGTK+ recently bumped the libxml2 dependency to 2.9.0, and immediately buffer overflow errors started appearing, signalled by the following stderr output in some test cases: internal buffer error : No error message provided.", 	if (res < 0) {
Stop parsing on entities boundaries errors.,+	    xmlStopParser(ctxt);
A heap-buffer overflow was found in the way libxml2 decoded certain XML entitites.,     buf[len] = 0;
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"Vulnerability class: Null deref, Denial of Service.",-            arg1->boolval |= arg2->boolval;
==17901==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60300000ea56 at pc 0x46cfc5 bp 0x7fffffffc420 sp 0x7fffffffc400.B1+B39," 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,"
Heap-based buffer overflow in the xmlGROW function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to obtain sensitive process memory information via unspecified vectors.,"     if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&
         (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 	    xmlPopInput(ctxt);"
Fix the semantic of XPath axis for namespace/attribute context nodes. ,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
Make sure that truncated UTF-8 sequences don't cause an out-of-bounds array access.,"+    memset(&buffer[sizeof(buffer)-4], 0, 4);"
* HTMLparser.c: (htmlParseName): Add bounds check.,"+    if (ctxt->input->base > ctxt->input->cur - len)
+	return(NULL);"
"If an untrusted XML document was parsed in recovery mode and post-validated, the flaw could be used to crash the application.", 	    elem = xmlParseName(ctxt);
Limit available memory to 100MB to avoid exhaustive memory consumption by malicious files.,"-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {"
Do not fetch external parsed entities.,-    if (ent->checked == 0) {
A NULL pointer dereference vulnerability exists in the xpath.c:xmlXPathCompOpEval() function of libxml2 through 2.9.8 when parsing an invalid XPath expression in the XPATH_OP_AND or XPATH_OP_OR case.,"-            valuePush(ctxt, arg1);"
The attached document will cause an out of bounds heap read access in the function xmlParseXMLDecl.,"            if (RAW != '\'') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-	    val1->nodeMax *= 2;
heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>.,"     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));"
Truncated UTF-8 input can cause out-of-bounds array access.,"snprintf(buf, sizeof(buf), ""&#%d;"", *cur);"
Fix nullptr deref with XPath logic ops.,-            arg1->boolval &= arg2->boolval;
Heap-based buffer overread in xmlParserPrintFileContextInternal.,-        if (ctxt->input->cur[tlen] == '>') {
Bug 758588: Heap-based buffer overread in xmlParserPrintFileContextInternal.,-        if (ctxt->input->cur[tlen] == '>') {
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-		if (ctxt->input->base != base) goto base_changed;
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	    xmlStopParser(ctxt);
Fix some buffer conversion issues.,"+		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);"
heap-buffer-overflow in xmlFAParsePosCharGroup.,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure., 	    ctxt->input->free = NULL;
The comprehensive fix is to change the return type of xmlStrlen() to size_t so that it doesn't overflow.,"+    if (size < 0)
+        return(NULL);"
Fix user-after-free with `xmllint --xinclude --dropdtd`. ,-                   (cur->children->type != XML_ENTITY_DECL) &&
Heap-based buffer overread in xmlDictAddString. ," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
An attacker who is able to submit a crafted file to be processed by an application linked with libxml2 could trigger a use-after-free.,-                   (cur->children->type != XML_XINCLUDE_START) &&
Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.,-            arg1->boolval &= arg2->boolval;
Stop parsing on entities boundaries errors.,+	    xmlStopParser(ctxt);
Stop parsing on entities boundaries errors.,+	    xmlStopParser(ctxt);
"It is possible to trigger a stack overflow using a carefully crafted invalid xml file, the stack overflow occurs before libxml2 determines the xml file is invalid."," 	rep = xmlStringDecodeEntities(ctxt, ent->content,
 				  XML_SUBSTITUTE_REF, 0, 0, 0);"
The pointers from the context input were not properly reset after that call which can do reallocations.,"+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);"
Error in the code pointing to the codepoint in the stack for the current char value instead of the pointer in the input that the SAX callback expects.,"+						ctxt->userData, &in->cur[0], 1);"
"The xmlParseElementDecl function in parser.c in libxml2 before 2.9.4 allows context-dependent attackers to cause a denial of service (heap-based buffer underread and application crash) via a crafted file, involving xmlParseName.",         name = xmlParseName(ctxt);
Do not fetch external parsed entities.,-    if (ent->checked == 0) {
The HTML parser was too optimistic when processing comments and didn't check for the end of the stream on the first 2 characters.,"-    if (!IS_CHAR(cur)) {
-       htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
-                    ""Comment not terminated \n<!--%.50s\n"", buf, NULL);
-       xmlFree(buf);
-    }"
Buffer overead with HTML parser in push mode.,"-						ctxt->userData, &cur, 1);"
"One place where ctxt->instate == XML_PARSER_EOF whic was set up by entity detection issues doesn't get noticed, and even overrided.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-	if (ctxt->input->base != base) goto base_changed;
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.","-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
* HTMLparser.c: (htmlParseName): Add bounds check.,"+       if (in == ctxt->input->end)
+           return(NULL);"
Global buffer-overflow in the htmlParseTryOrFinish function.,	    ctxt->input->free((xmlChar *) ctxt->input->base);
Check return value of recursive calls to xmlParseElementChildrenContentDeclPriv and return immediately in case of errors.,"+        if (cur == NULL)
+            return(NULL);"
"There are times, like on unterminated entities that it's preferable to stop parsing, even if that means less error reporting.",+	    xmlStopParser(ctxt);
Do not fetch external parameter entities.,"+                    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+		        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+			((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+			(ctxt->validate == 0))
+			return;"
Fix memory access error due to incorrect entities boundaries.,     ctxt->input->cur = ctxt->input->base + cur;
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-		set1->nodeMax *= 2;
* parser.c: do not load external parsed entities unless needed,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
Buffer overead with HTML parser in push mode.,"-					    ctxt->userData, &cur, 1);"
Error in the code pointing to the codepoint in the stack for the current char value instead of the pointer in the input that the SAX callback expects.,"+						ctxt->userData, &in->cur[0], 1);"
Fix some potential problems on reallocation failures.," 		temp = (xmlNodePtr *) xmlRealloc(
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));"
Avoid an heap buffer overflow in xmlDictComputeFastQKey.,+	value += name[offset];
Avoid an out of bound access when serializing malformed strings.,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
"Double free vulnerability in libxml2 2.7.8 and other versions, as used in Google Chrome before 8.0.552.215 and other products, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.",-		valuePop(ctxt);
* parser.c: do not load external parsed entities unless needed,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
Fix an off by one pointer access.,-	    *cur++ = CUR;
For php reproduction run the following (php needs the xml module for DOM): make sure the php files and .xsl files reside in same directory and run the following commands: php -f xpath_or.php php -f xpath_and.php -- Guy Inbar.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval |= arg2->boolval;"
"Off-by-one error in libxml2, as used in Google Chrome before 19.0.1084.46 and other products, allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via unknown vectors.","-	    if ((CUR == ')') || (CUR == '(') || (CUR == '^')) {
-		*cur++ = CUR;
-	    }"
xmlParseBalancedChunkMemoryRecover in parser.c in libxml2 before 2.9.10 has a memory leak related to newDoc->oldNs.,-    newDoc->oldNs = NULL;
Make sure to set 'attvalue' to NULL after freeing it.,+		    attvalue = NULL;
"WebKitGTK+ recently bumped the libxml2 dependency to 2.9.0, and immediately buffer overflow errors started appearing, signalled by the following stderr output in some test cases: internal buffer error : No error message provided.","     if ((end_in_lf == 1) && (ctxt->input != NULL) &&
         (ctxt->input->buf != NULL)) {"
libxml2 20904-GITv2.9.4-16-g0741801 is vulnerable to a heap-based buffer over-read in the xmlDictAddString function in dict.c.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-		set1->nodeMax *= 2;
Fix potential out of bound access.,+        while ((len > 0) && (buf[len - 1] == 0x20)) len--;
* parserInternals.c: (xmlNextChar): Add an test to catch other issues on ctxt->input corruption proactively.,"+    if ((*ctxt->input->cur == 0) &&
+        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
"The xmlPArserPrintFileContextInternal function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.", 	    ctxt->input->cur += tlen + 1;
"This then causes an issue when the macro NEXT is called twice more, the first time it will read EOF, then the second time it will overread the buffer into global memory space, causing a crash in ASAN.", 	    xmlParsePI(ctxt);
Global buffer-overflow in the htmlParseTryOrFinish function., 	ctxt->input->base = ctxt->input->cur;
"The xmlDictAddString function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document."," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
Fix some potential problems on reallocation failures.,-        cur->nodeMax *= 2;
Fix the semantic of XPath axis for namespace/attribute context nodes. ,"+    if (cur != NULL) {
+        if ((cur->type == XML_ATTRIBUTE_NODE) ||
+            (cur->type == XML_NAMESPACE_DECL))
+            return(NULL);
+        if (cur->children != NULL)
+            return cur->children ;
+    }"
There appears to be an out-of-bounds read in libxml2 (2.9.2).," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
==26202==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x0000008073f9 bp 0x7ffd791c7f90 sp 0x7ffd791c7f88.,"-        if ((*ctxt->input->cur == 0) &&
-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0) &&
-            (ctxt->instate != XML_PARSER_COMMENT)) {"
heap-buffer-overflow in xmlFAParsePosCharGroup. ,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
* parser.c: do not load external parsed entities unless needed,-    if (ent->checked == 0) {
The processing of namespace and attributes nodes was not compliant to the XPath-1.0 specification.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
==19600==ERROR: AddressSanitizer: global-buffer-overflow on address 0x5608cd40a230 at pc 0x7f6705c1cdb4 bp 0x7ffced505890 sp 0x7ffced505880.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
"If the XPath stack is corrupted, for example by a misbehaving extension function, the ""and"" and ""or"" XPath operators could dereference NULL pointers.",-            arg1->boolval |= arg2->boolval;
Fix some potential problems on reallocation failures.,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"Vulnerability class: Null deref, Denial of Service.","-            valuePush(ctxt, arg1);"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-	if (ctxt->input->base != base) goto base_changed;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-        cur->nodeMax *= 2;
"Hey, There appears to be an out-of-bounds read in libxml2 (2.9.2)."," 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            ""xmlParseEntityDecl: entity %s not terminated\n"", name);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
Fix an off by one pointer access.,-	    *cur++ = CUR;
Avoid an out of bound access when serializing malformed strings.,+            } else if ((*cur < 0xF0) && (cur [2] != 0)) {
"For non-UTF-8 charsets, xmlNextChar() failed to check for the end of the input buffer and would continuing reading.","-        if ((*ctxt->input->cur == 0) &&
-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0) &&
-            (ctxt->instate != XML_PARSER_COMMENT)) {"
Bug 757711: heap-buffer-overflow in xmlFAParsePosCharGroup.,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
"When ctxt->instate == XML_PARSER_EOF,xmlParseStringEntityRef return NULL which cause a infinite loop in xmlStringLenDecodeEntities","     while ((c != 0) && (c != end) &&
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {"
The processing of namespace and attributes nodes was not compliant to the XPath-1.0 specification.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,"+        } else if ((*cur >= 0x80) && (cur[1] != 0) &&
+	           ((doc == NULL) || (doc->encoding == NULL))) {"
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
"The fix for this would be to check the instate in xmlParseMarkupDecl after it parses an entry, and if EOF is reached, then stop.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
Prevent unwanted external entity reference.,"+	    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+	        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+		((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+		((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&
+		((ctxt->options & XML_PARSE_DTDATTR) == 0) &&
+		(ctxt->replaceEntities == 0) &&
+		(ctxt->validate == 0))
+		return;"
"When doc is NULL, namespace created in xmlTreeEnsureXMLDecl is bind to newDoc->oldNs, in this case, set newDoc->oldNs to NULL and free newDoc will cause a memory leak.",-    newDoc->oldNs = NULL;
Do not process encoding values if the declaration if broken.,"            if (RAW != '""') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
"The xz_head function in libxml2 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.","-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {"
Buffer overead with HTML parser in push mode.,"-						ctxt->userData, &cur, 1);"
"* parser.c: (xmlParseEndTag2): Add bounds checks before dereferencing ctxt->input->cur past the end of the buffer, or incrementing the pointer past the end of the buffer.","+    if ((tlen > 0) && (curLength >= (size_t)tlen) &&
+        (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+        if ((curLength >= (size_t)(tlen + 1)) &&
+	    (ctxt->input->cur[tlen] == '>')) {"
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects. ,-	    blen += 12;
"The xmlParserHandlePEReference function in parser.c in libxml2 before 2.9.2, as used in Web Listener in Oracle HTTP Server in Oracle Fusion Middleware 11.1.1.7.0, 12.1.2.0, and 12.1.3.0 and other products, loads external parameter entities regardless of whether entity substitution or validation is enabled, which allows remote attackers to cause a denial of service (resource consumption) via a crafted XML document.","input = xmlNewEntityInputStream(ctxt, entity);"
"Hi, we found a global-buffer-overflow in xmlEncodeEntitiesInternal at libxml2/entities.c:583.","    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
Global buffer-overflow in the htmlParseTryOrFinish function., 	    ctxt->input->free = NULL;
The count was incremented before the allocation and not fixed in case of failure.,"+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));"
"WebKitGTK+ recently bumped the libxml2 dependency to 2.9.0, and immediately buffer overflow errors started appearing, signalled by the following stderr output in some test cases: internal buffer error : No error message provided."," 	xmlParserInputBufferPush(ctxt->input->buf, 1, ""\r"");"
"A patch to do this is below: diff --git a/parser.c b/parser.c index a65e4cc..04b0e58 100644 --- a/parser.c +++ b/parser.c @@ -6970,6 +6970,15 @@ xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) { xmlParsePI(ctxt); } } + + /* + * If the parser eached end of file, then stop while we know it is failing.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
arg1->boolval |= arg2->boolval; //crashing here due to null deref.,-            arg1->boolval |= arg2->boolval;
"One place where ctxt->instate == XML_PARSER_EOF whic was set up by entity detection issues doesn't get noticed, and even overrided. ","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
"Add bounds checks before dereferencing ctxt->input->cur past the end of the buffer, or incrementing the pointer past the end of the buffer.","+    if ((tlen > 0) && (curLength >= (size_t)tlen) &&
+        (xmlStrncmp(ctxt->input->cur, ctxt->name, tlen) == 0)) {
+        if ((curLength >= (size_t)(tlen + 1)) &&
+	    (ctxt->input->cur[tlen] == '>')) {"
Fix infinite loop in xmlStringLenDecodeEntities.,"     while ((c != 0) && (c != end) &&
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {"
"Off-by-one error in libxml2, as used in Google Chrome before 19.0.1084.46 and other products, allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via unknown vectors.",-	    *cur++ = CUR;
==17901==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60300000ea56 at pc 0x46cfc5 bp 0x7fffffffc420 sp 0x7fffffffc400.B1+B39," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	    xmlStopParser(ctxt);
Avoid an heap buffer overflow in xmlDictComputeFastQKey. ,+	value += name[offset];
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-		if (ctxt->input->base != base) goto base_changed;
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,-            } else if (*cur < 0xF8) {
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	value += name[offset];
"Because of that omission, the parser failed to detect attribute recursions in certain documents before running out of stack space."," 	rep = xmlStringDecodeEntities(ctxt, ent->content,
 				  XML_SUBSTITUTE_REF, 0, 0, 0);"
"If entities expansion in the XML parser is asked for, it is possble to craft relatively small input document leading to excessive on-the-fly content generation.","+        if (replacement < XML_PARSER_NON_LINEAR * consumed)
+	    return(0);"
"Heap-based buffer overflow in the xmlStrncat function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.",     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
The count was incremented before the allocation and not fixed in case of failure.,"+	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *
 					     sizeof(xmlNodePtr));"
==35387==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eef7 at pc 0x7fa80a8da830 bp 0x7fff08c0f8f0 sp 0x7fff08c0f8e8,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
xmllint: global-buffer-overflow in xmlEncodeEntitiesInternal.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
The pointers from the context input were not properly reset after that call which can do reallocations.,"+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);"
"The htmlCurrentChar function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.","-        if ((*ctxt->input->cur == 0) &&
-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0) &&
-            (ctxt->instate != XML_PARSER_COMMENT)) {"
xmlStringLenDecodeEntities in parser.c in libxml2 2.9.10 has an infinite loop in a certain end-of-file situation.,"     while ((c != 0) && (c != end) &&
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {"
A NULL pointer dereference vulnerability exists in the xpath,"-            valuePush(ctxt, arg1);"
* parser.c: (xmlParseElementDecl): Return early on invalid input to fix non-minimized test case (759573-2.xml).," 	if (!IS_BLANK_CH(CUR)) {
 	    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,
 		           ""Space required after 'ELEMENT'\n"");
+	    return(-1);
 	}"
"The xmlBufAttrSerializeTxtContent function in xmlsave.c in libxml2 allows context-dependent attackers to cause a denial of service (out-of-bounds read and application crash) via a non-UTF-8 attribute value, related to serialization.","-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,     ctxt->input->cur = ctxt->input->base + cur;
Fix memory access error due to incorrect entities boundaries.,-    if (ctxt->input->base != base) goto base_changed;
Avoid an out of bound access when serializing malformed strings.,-            } else if (*cur < 0xF0) {
Fix some potential problems on reallocation failures.,-	    val1->nodeMax *= 2;
==32024==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x000000599fb9 bp 0x7ffc797d1b80 sp 0x7ffc797d1b78.,            encoding = xmlParseEncName(ctxt);
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","-            valuePush(ctxt, arg1);"
handle properly the case here we popped out of the current entity while processing a start tag.,"+    if (inputNr != ctxt->inputNr) {
+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,
+		    ""Start tag doesn't start and stop in the same entity\n"");
+	return(NULL);
+    }"
Fix nullptr deref with XPath logic ops.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval |= arg2->boolval;"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-        cur->nodeMax *= 2;
"Because of that omission, the parser failed to detect attribute recursions in certain documents before running out of stack space."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						  XML_SUBSTITUTE_REF, 0, 0, 0);"
heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>. ,"     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));"
Fix potential out of bound access.,     buf[len] = 0;
Fix some potential problems on reallocation failures.,+		set1->nodeMax *= 2;
"libxml2 through 2.9.1 does not properly handle external entities expansion unless an application developer uses the xmlSAX2ResolveEntity or xmlSetExternalEntityLoader function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.","+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-	if (ctxt->input->base != base) {
"Hey, There appears to be an out-of-bounds read in libxml2 (2.9.2)."," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
There appears to be an out-of-bounds read in libxml2 (2.9.2).," 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            ""xmlParseEntityDecl: entity %s not terminated\n"", name);"
Fix out-of-bounds read with 'xmllint --htmlout'.,"+    memset(&buffer[sizeof(buffer)-4], 0, 4);"
"The xz_head function in xzlib.c in libxml2 before 2.9.6 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.",             xmlFree(state->in);
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	    xmlStopParser(ctxt);
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,"else if ((cur->children != NULL) &&
+                   ((cur->type == XML_DOCUMENT_NODE) ||
+                    (cur->type == XML_ELEMENT_NODE))) {"
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure., 	ctxt->input->base = ctxt->input->cur;
Fix an off by one pointer access.,"else {
-		*cur++ = '^';
-		*cur++ = CUR;
-	    }"
Bug 758605: Heap-based buffer overread in xmlDictAddString.,        if ((*in > 0) && (*in < 0x80)) {
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.",-            arg1 = valuePop(ctxt);
Unless explicitely asked for when validating or replacing entities with their value.,"+                    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+		        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+			((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+			(ctxt->validate == 0))
+			return;"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-	if (ctxt->input->base != base) {
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
Fixed by using a do-while loop so we always call htmlParseChunk() at least once.,+    } while (cur < size);
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
There appears to be an out-of-bounds read in libxml2 (2.9.2).," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,+	    xmlStopParser(ctxt);
arg1->boolval &= arg2->boolval; //and then the application is crashing here resulting in a Denial of Service condition.,-            arg1->boolval |= arg2->boolval;
GNOME project libxml2 v2.9.10 has a global buffer over-read vulnerability in xmlEncodeEntitiesInternal at libxml2/entities.c.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-    if (ctxt->input->base != base) goto base_changed;
"(pushParseTest): The input for the new test case was so small (4 bytes) that htmlParseChunk() was never called after htmlCreatePushParserCtxt(), thereby creating a false positive test failure.",        if ((*in > 0) && (*in < 0x80)) {
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,+	xmlStopParser(ctxt);
"Heap-based buffer overflow in the xmlFAParsePosCharGroup function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.","         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-        cur->nodeMax *= 2;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
"Heap-based buffer overflow in the xmlStrncat function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.","     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));"
Fix some buffer conversion issues.,"+		xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);"
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects. ,     bp = (char*)xmlMallocAtomic(blen);
Detect excessive entities expansion upon replacement.,"+	if (replacement < XML_MAX_TEXT_LENGTH)
+	    return(0);"
Stop parsing on entities boundaries errors.,+	xmlStopParser(ctxt);
Increase buffer space for port in HTTP redirect support.," 	if (proxy)
+	    blen += 17;"
CVE-2015-7497 Avoid an heap buffer overflow in xmlDictComputeFastQKey.,+	value += name[offset];
==32024==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x000000599fb9 bp 0x7ffc797d1b80 sp 0x7ffc797d1b78.,"            if (RAW != '\'') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
Detect excessive entities expansion upon replacement.,"+        if (replacement < XML_PARSER_NON_LINEAR * consumed)
+	    return(0);"
"Heap-based buffer underflow in the xmlParseAttValueComplex function in parser.c in libxml2 2.9.0 and earlier, as used in Google Chrome before 23.0.1271.91 and other products, allows remote attackers to cause a denial of service or possibly execute arbitrary code via crafted entities in an XML document.",     buf[len] = 0;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
"Double free vulnerability in libxml2 2.7.8 and other versions, as used in Google Chrome before 8.0.552.215 and other products, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.","-		xmlXPathReleaseObject(xpctxt, tmp);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-	    val1->nodeMax *= 2;
For php reproduction run the following (php needs the xml module for DOM): make sure the php files and .xsl files reside in same directory and run the following commands: php -f xpath_or.php php -f xpath_and.php -- Guy Inbar.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
Heap-based buffer overflow in the xmlParseXmlDecl function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service via unspecified vectors related to extracting errors after an encoding conversion failure.,-	if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {
Fix some buffer conversion issues.,+	size_t current = ctxt->input->cur - ctxt->input->base;
* xmlstring.c: (xmlStrncat): Return NULL if xmlStrlen returns a negative length.,"+        if (len < 0)
+            return(NULL);"
Add missing increments of recursion depth counter to XML parser.,+			++ctxt->depth;
"Without ASAN, there is potential to get input that could cause out of bounds memory to be returned to userspace through the use of libxml2, which could be used to cause denial of service attacks, or gain sensitive information.", 	    xmlParsePI(ctxt);
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,-	    val1->nodeMax *= 2;
Fixed by using a do-while loop so we always call htmlParseChunk() at least once.,+    do {
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,     ctxt->input->cur = ctxt->input->base + cur;
heap-buffer-overflow in xmlFAParsePosCharGroup. ,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
Heap-based buffer overread in xmlDictAddString. , 	if ((*in > 0) && (*in < 0x80)) {
Limit available memory to 100MB to avoid exhaustive memory consumption by malicious files.,             xmlFree(state->in);
Approvement in LZMA error handling which prevents an infinite loop.,while (strm->avail_out && ret != LZMA_STREAM_END);
Bug 758605: Heap-based buffer overread in xmlDictAddString.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
Fix user-after-free with `xmllint --xinclude --dropdtd`.,-                   (cur->children->type != XML_XINCLUDE_END)) {
Fix some buffer conversion issues.,		size_t current = ctxt->input->cur - ctxt->input->base;
if not stop everything we have an internal state error.,"     if ((ctxt->input->cur != NULL) && (*ctxt->input->cur == 0) &&
         (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0))
 	    xmlPopInput(ctxt);"
Advancing to the next character in case of an error while parsing regexp leads to an out of bounds access.,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
Bug 758605: Heap-based buffer overread in xmlDictAddString.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
Avoid an out of bound access when serializing malformed strings.,"+        } else if ((*cur >= 0x80) && (cur[1] != 0) &&
+	           ((doc == NULL) || (doc->encoding == NULL))) {"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
Fix the semantic of XPath axis for namespace/attribute context nodes.,"+    if (cur != NULL) {
+        if ((cur->type == XML_ATTRIBUTE_NODE) ||
+            (cur->type == XML_NAMESPACE_DECL))
+            return(NULL);
+        if (cur->children != NULL)
+            return cur->children ;
+    }"
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,+            } else if ((*cur < 0xF0) && (cur [2] != 0)) {
"It is one case where the code in place to detect entities expansions failed to exit when the situation was detected, leading to DoS. ","+		if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
+		    (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
+		    goto int_error;"
arg1->boolval |= arg2->boolval; //crashing here due to null deref.,"-            valuePush(ctxt, arg1);"
"It is possible to trigger a stack overflow using a carefully crafted invalid xml file, the stack overflow occurs before libxml2 determines the xml file is invalid."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						      XML_SUBSTITUTE_REF,
 						      0, 0, 0);"
The comprehensive fix is to change the return type of xmlStrlen() to size_t so that it doesn't overflow.,"+        if (len < 0)
+            return(NULL);"
arg1->boolval |= arg2->boolval; //crashing here due to null deref.,"-            valuePush(ctxt, arg1);"
"The xmlNextChar function in libxml2 2.9.2 does not properly check the state, which allows context-dependent attackers to cause a denial of service (heap-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.", 	    xmlParsePI(ctxt);
Check the liblzma error code more thoroughly to avoid infinite loops.,while (strm->avail_out && ret != LZMA_STREAM_END);
"A remote attacker could provide a specially-crafted XML file that, when processed would lead to excessive CPU consumption (denial of service).","+        if (replacement < XML_PARSER_NON_LINEAR * consumed)
+	    return(0);"
==4210==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6290000051ff at pc 0x000000533c8f bp 0x7ffdb38c4830 sp 0x7ffdb38c4828., 	    ctxt->input->cur += tlen + 1;
Buffer overflow errors originating from xmlBufGetInputBase in 2.9.0., 	if (res < 0) {
Make sure that truncated UTF-8 sequences don't cause an out-of-bounds array access.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,-                   (cur->children->type != XML_ENTITY_DECL) &&
Fix the semantic of XPath axis for namespace/attribute context nodes.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
Buffer overead with HTML parser in push mode. ,"-						ctxt->userData, &cur, 1);"
Heap-based buffer overread in xmlDictAddString.," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
* parser.c: do not load external parsed entities unless needed,-    if (ent->checked == 0) {
"Fix this by pulling out the check for the end of the input buffer into common code, and return if we reach the end of the input buffer prematurely.","+    if ((*ctxt->input->cur == 0) &&
+        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {"
Fix infinite loop in LZMA decompression. ,while (strm->avail_out && ret != LZMA_STREAM_END);
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure.," 	ctxt->input->cur = BAD_CAST"""";"
Avoid an out of bound access when serializing malformed strings.,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
Heap-based buffer-underreads due to xmlParseName. ,         name = xmlParseName(ctxt);
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for external entity references replacement (--noent option) was requested / enabled during the XML file parsing.",} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
"The htmlParseComment function in HTMLparser.c in libxml2 allows attackers to obtain sensitive information, cause a denial of service (out-of-bounds heap memory access and application crash), or possibly have unspecified other impact via an unclosed HTML comment.",     buf[len] = 0;
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",+	xmlStopParser(ctxt);
Error in the code pointing to the codepoint in the stack for the current char value instead of the pointer in the input that the SAX callback expects.,"+					    ctxt->userData, &in->cur[0], 1);"
"According to the xz man page, files compressed with `xz -9` currently require 65 MB to decompress, so set the limit to 100 MB.","+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
heap-buffer-overflow in xmlFAParsePosCharGroup.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
"The xmlNextChar function in libxml2 2.9.2 does not properly check the state, which allows context-dependent attackers to cause a denial of service (heap-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,-		set1->nodeMax *= 2;
"When we hit a convwersion failure when switching encoding it is bestter to stop parsing there, this was treated as a fatal error but the parser was continuing to process to extract more errors, unfortunately that makes little sense as the data is obviously corrupt and can potentially lead to unexpected behaviour.",+    return(ret);
Fix memory access error due to incorrect entities boundaries.,-	if (ctxt->input->base != base) {
Fix nullptr deref with XPath logic ops.,-            arg1->boolval |= arg2->boolval;
Fixed by using a do-while loop so we always call htmlParseChunk() at least once.,"+    do {
         if (cur + 1024 >= size) {"
Fix an off by one pointer access.,"-	    if ((CUR == ')') || (CUR == '(') || (CUR == '^')) {
-		*cur++ = CUR;
-	    }"
Check the liblzma error code more thoroughly to avoid infinite loops.,"+        if ((state->how != GZIP) &&
+            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {
+            xz_error(state, ret, ""lzma error"");
+            return -1;
+        }"
Set memory limit for LZMA decompression.,"+        if (lzma_auto_decoder(&state->strm, 100000000, 0) != LZMA_OK) {"
==2994== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60040000d5d3 at pc 0x73320a bp 0x7fffffffc1e0 sp 0x7fffffffc1d8,-            } else if (*cur < 0xF0) {
"A remote attacker could provide a specially-crafted XML file containing an external entity expansion, when processed would lead to excessive CPU consumption (denial of service).","+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
The pointers from the context input were not properly reset after that call which can do reallocations.,"+		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);"
The xmlSAX2TextNode function in SAX2.c in the push interface in the HTML parser in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (stack-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.,"-						ctxt->userData, &cur, 1);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
"A remote attacker could provide a specially-crafted XML file containing an external entity expansion, when processed would lead to excessive CPU consumption (denial of service).",ent->checked = ctxt->nbentities - oldnbent;
Buffer overflow errors originating from xmlBufGetInputBase in 2.9.0.,"     if ((end_in_lf == 1) && (ctxt->input != NULL) &&
         (ctxt->input->buf != NULL)) {"
Avoid an out of bound access when serializing malformed strings.,-            } else if (*cur < 0xF0) {
Fix user-after-free with `xmllint --xinclude --dropdtd`.,-                   (cur->children->type != XML_XINCLUDE_START) &&
"XML external entity (XXE) vulnerability in the xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.4, when not in validating mode, allows context-dependent attackers to read arbitrary files or cause a denial of service (resource consumption) via unspecified vectors."," 		rep = xmlStringDecodeEntities(ctxt, ent->content, what,"
heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>.,     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-		set1->nodeMax *= 2;
==40644==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eef7 at pc 0x7ff28073d830 bp 0x7ffe05f5ec10 sp 0x7ffe05f5ec08.,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
An attacker who is able to submit a crafted file to be processed by an application linked with libxml2 could trigger a use-after-free.,-                   (cur->children->type != XML_ENTITY_DECL) &&
Applications processing untrusted XSL format inputs with the use of the libxml2 library may be vulnerable to a denial of service attack due to a crash of the application.,"-            valuePush(ctxt, arg1);"
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects. ,-	    blen += 6;
Fix missing error status in XPath evaluation.,"         if (tmp == NULL) {
             xmlGenericError(xmlGenericErrorContext, ""realloc failed !\n"");
+            ctxt->error = XPATH_MEMORY_ERROR;
             return (0);
         }"
Increase buffer space for port in HTTP redirect support," 	else
+	    blen += 11;"
Avoid extra processing of MarkupDecl when EOF.,"+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.",-            arg1->boolval &= arg2->boolval;
"One place where ctxt->instate == XML_PARSER_EOF whic was set up by entity detection issues doesn't get noticed, and even overrided.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects.,-	    blen += 12;
"The xz_head function in xzlib.c in libxml2 before 2.9.6 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.","-        if (lzma_auto_decoder(&state->strm, UINT64_MAX, 0) != LZMA_OK) {"
A NULL pointer dereference vulnerability exists in the xpath,-            arg1->boolval &= arg2->boolval;
Detect excessive entities expansion upon replacement.,+    if (replacement != 0) {
Increase buffer space for port in HTTP redirect support.," 	else
+	    blen += 11;"
"The htmlParseComment function in HTMLparser.c in libxml2 allows attackers to obtain sensitive information, cause a denial of service (out-of-bounds heap memory access and application crash), or possibly have unspecified other impact via an unclosed HTML comment.","-    if (!IS_CHAR(cur)) {
-       htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
-                    ""Comment not terminated \n<!--%.50s\n"", buf, NULL);
-       xmlFree(buf);
-    }"
bug report: Global buffer-overflow in the htmlParseTryOrFinish function.," 	ctxt->input->cur = BAD_CAST"""";"
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references.",+        ++ctxt->depth;
Heap-based buffer overflow in the xmlDictComputeFastQKey function in dict.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service via unspecified vectors.,+	value += name[offset];
"ibxml2 2.9.2 does not properly stop parsing invalid input, which allows context-dependent attackers to cause a denial of service (out-of-bounds read and libxml2 crash) via crafted XML data to the (1) xmlParseEntityDecl or (2) xmlParseConditionalSections function in parser.c, as demonstrated by non-terminated entities.",-        value += name[len - (plen + 1 + 1)];
"The xz_head function in libxml2 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.",             xmlFree(state->out);
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,"+        } else if ((*cur >= 0x80) && (cur[1] != 0) &&
+	           ((doc == NULL) || (doc->encoding == NULL))) {"
Fix some potential problems on reallocation failures.,-		set1->nodeMax *= 2;
Fix nullptr deref with XPath logic ops.,"-            valuePush(ctxt, arg1);"
"A remote attacker could provide a specially-crafted XML file that, when processed would lead to excessive CPU consumption (denial of service).",+    if (replacement != 0) {
Fix memory access error due to incorrect entities boundaries.,-	if (ctxt->input->base != base) goto base_changed;
"Heap-based buffer overflow in the xmlFAParsePosCharGroup function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted XML document.","     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
The processing of namespace and attributes nodes was not compliant to the XPath-1.0 specification.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
libfuzzer regression testing exposed another case where the parser would fetch content of an external entity while not in validating mode.,"-		    xmlLoadEntityContent(ctxt, ent);"
* xmlregexp.c: (xmlFAParseCharRange): Only advance to the next character if there is no error.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
"When we hit a convwersion failure when switching encoding it is bestter to stop parsing there, this was treated as a fatal error but the parser was continuing to process to extract more errors, unfortunately that makes little sense as the data is obviously corrupt and can potentially lead to unexpected behaviour.","+    ret = xmlSwitchToEncodingInt(ctxt, handler, len);"
The functions xmlParserEntityCheck() and xmlParseAttValueComplex() used to call xmlStringDecodeEntities() in a recursive context without incrementing the 'depth' counter in the parser context.,+			++ctxt->depth;
"Vulnerability class: Null deref, Denial of Service.",-            arg1->boolval &= arg2->boolval;
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,-            } else if (*cur < 0xF0) {
"The xmlDictAddString function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.","     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
"Multiple use-after-free vulnerabilities in libxml2 2.9.0 and possibly other versions might allow context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to the (1) htmlParseChunk and (2) xmldecl_done functions, as demonstrated by a buffer overflow in the xmlBufGetInputBase function.","     if ((end_in_lf == 1) && (ctxt->input != NULL) &&
         (ctxt->input->buf != NULL)) {"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-        cur->nodeMax *= 2;
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-	if (ctxt->input->base != base) goto base_changed;
Avoid an heap buffer overflow in xmlDictComputeFastQKey. ,-        value += name[len - (plen + 1 + 1)];
Heap-based buffer overread in xmlDictAddString.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
Add xmlHaltParser() to stop the parser.,"+    if ((ctxt->input->cur > ctxt->input->end) ||
+        (ctxt->input->cur < ctxt->input->base)) {
+        xmlHaltParser(ctxt);
+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, ""cur index out of bound"");
+	return;
+    }"
Fix some potential problems on reallocation failures.,"+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));"
Bug 763071: heap-buffer-overflow in xmlStrncat.,"     ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));"
This issue is related to the handling of external parameter entities.,"+                    if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&
+		        ((ctxt->options & XML_PARSE_NOENT) == 0) &&
+			((ctxt->options & XML_PARSE_DTDVALID) == 0) &&
+			(ctxt->validate == 0))
+			return;"
"When ctxt->instate == XML_PARSER_EOF,xmlParseStringEntityRef return NULL which cause a infinite loop in xmlStringLenDecodeEntities Found with libFuzzer.","     while ((c != 0) && (c != end) &&
+           (c != end2) && (c != end3) &&
+           (ctxt->instate != XML_PARSER_EOF)) {"
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						  XML_SUBSTITUTE_REF, 0, 0, 0);"
Fix some potential problems on reallocation failures.,+        cur->nodeMax *= 2;
* parser.c: do not load external parsed entities unless needed.,-    if (ent->checked == 0) {
"There are times, like on unterminated entities that it's preferable to stop parsing, even if that means less error reporting.",+	    xmlStopParser(ctxt);
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","-            valuePush(ctxt, arg1);"
==25920==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010810 at pc 0x0000004a2f25 bp 0x7ffc81805ae0 sp 0x7ffc81805290.,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
"Multiple use-after-free vulnerabilities in libxml2 2.9.0 and possibly other versions might allow context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via vectors related to the (1) htmlParseChunk and (2) xmldecl_done functions, as demonstrated by a buffer overflow in the xmlBufGetInputBase function."," 	xmlParserInputBufferPush(ctxt->input->buf, 1, ""\r"");"
"Attribute strings are only valid if the base does not change, so add another check where the base may change.",+		if ((attvalue != NULL) && (alloc != 0)) {
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
Fix the semantic of XPath axis for namespace/attribute context nodes.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","+            if (ctxt->value != NULL)
+                ctxt->value->boolval |= arg2->boolval;"
"The htmlParseComment function in HTMLparser.c in libxml2 allows attackers to obtain sensitive information, cause a denial of service (out-of-bounds heap memory access and application crash), or possibly have unspecified other impact via an unclosed HTML comment.","     while (IS_CHAR(cur) &&
            ((cur != '>') ||
            (r != '-') || (q != '-'))) {"
==32024==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x000000599fb9 bp 0x7ffc797d1b80 sp 0x7ffc797d1b78.,            encoding = xmlParseEncName(ctxt);
"A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference.", 	    elem = xmlParseName(ctxt);
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,-                   (cur->children->type != XML_XINCLUDE_END)) {
Add missing increments of recursion depth counter to XML parser.,+			++ctxt->depth;
"One place where ctxt->instate == XML_PARSER_EOF whic was set up by entity detection issues doesn't get noticed, and even overrided. ","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
Global buffer-overflow in the htmlParseTryOrFinish function.,         ctxt->input->end = ctxt->input->cur;
Heap-based buffer overflow in the xmlParseXmlDecl function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service via unspecified vectors related to extracting errors after an encoding conversion failure.,"-    return(xmlSwitchToEncodingInt(ctxt, handler, len));"
==8253== ERROR: AddressSanitizer: heap-use-after-free on address 0xb4c00137 at pc 0x8832928 bp 0xbfda6128 sp 0xbfda611c.,-		if (alloc != 0) xmlFree(attvalue);
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for entity references replacement (--noent option) was requested / enabled during the XML file parsing.","+	if (replacement < XML_MAX_TEXT_LENGTH)
+	    return(0);"
bug report: Global buffer-overflow in the htmlParseTryOrFinish function.,         ctxt->input->end = ctxt->input->cur;
"The xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.3 does not properly prevent entity expansion, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted XML data, a different vulnerability than CVE-2014-3660.","if (xmlParserEntityCheck(ctxt, nbchars, ent, 0))"
Fix some potential problems on reallocation failures.,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
I've verified this bug is affecting latest PHP 5.6 with xml module which can cause a denial of service for applications accepting xpath/xslt.,-            arg1->boolval &= arg2->boolval;
bug report: Global buffer-overflow in the htmlParseTryOrFinish function.,	    ctxt->input->free((xmlChar *) ctxt->input->base);
"Double free vulnerability in libxml2, as used in Google Chrome before 14.0.835.163, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.",+                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references.",+			++ctxt->depth;
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.",-            arg1 = valuePop(ctxt);
Bug 757711: heap-buffer-overflow in xmlFAParsePosCharGroup.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
There appears to be an out-of-bounds read in libxml2 (2.9.2).," 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,"
==32024==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x62100001c900 at pc 0x000000599fb9 bp 0x7ffc797d1b80 sp 0x7ffc797d1b78.,"            if (RAW != '""') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
"libxml2 2.9.0-rc1 and earlier, as used in Google Chrome before 21.0.1180.89, does not properly support a cast of an unspecified variable during handling of XSL transforms, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document, related to the _xmlNs data structure in include/libxml/tree.h.",     if (cur->type == XML_DTD_NODE) {
"libxml2 2.9.0-rc1 and earlier, as used in Google Chrome before 21.0.1180.89, does not properly support a cast of an unspecified variable during handling of XSL transforms, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document, related to the _xmlNs data structure in include/libxml/tree.h.","+		case XML_NAMESPACE_DECL:
+		    break;"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax *"
bug report: Global buffer-overflow in the htmlParseTryOrFinish function., 	ctxt->input->base = ctxt->input->cur;
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
Increase buffer space for port in HTTP redirect support," 	if (proxy)
+	    blen += 17;"
Do not fetch external parsed entities.,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
arg1->boolval &= arg2->boolval; //and then the application is crashing here resulting in a Denial of Service condition.,-            arg1->boolval &= arg2->boolval;
"A remote attacker could provide a specially-crafted XML file that, when processed, would lead to the exhaustion of CPU and memory resources or file descriptors.","input = xmlNewEntityInputStream(ctxt, entity);"
"A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference.","+            if (last == NULL) {
+		if (ret != NULL)
+		    xmlFreeDocElementContent(ctxt->myDoc, ret);
+		return(NULL);
+            }"
"READ of size 1 at 0x000000c136a1 thread T0 #0 0x45736f in xmlNextChar /root/libxml2/parserInternals.c:535 #1 0x4fd936 in xmlParseInternalSubset /root/libxml2/parser.c:8447 #2 0x52717b in xmlParseDocument /root/libxml2/parser.c:10836 #3 0x55b5b6 in xmlDoRead /root/libxml2/parser.c:15324 #4 0x55b5b6 in xmlReadFile /root/libxml2/parser.c:15386 #5 0x4183b7 in parseAndPrintFile /root/libxml2/xmllint.c:2401 #6 0x40de46 in main /root/libxml2/xmllint.c:3759 #7 0x7f920fcc7ec4 (/lib/x86_64-linux-gnu/libc.so.6+0x21ec4) #8 0x40fad9 in _start (/root/libxml2/xmllint+0x40fad9) I git bisected it back to the following commit, which is meant to stop the parser on an unterminated entity This shows that there the parser is running through xmlParseMarkupDecl, and then instate is set to XML_PARSER_EOF (in xmlStopParser), but looking at the source for xmlParseMarkupDecl, on line 6990, the instate is changed to XML_PARSER_DTD.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"Otherwise, struct xmlElementContent could contain unexpected null pointers, leading to a null deref when post-validating documents which aren't well-formed and parsed in recovery mode."," 	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                           depth + 1);"
Bug 758588: Heap-based buffer overread in xmlParserPrintFileContextInternal., 	    ctxt->input->cur += tlen + 1;
Truncated UTF-8 input can cause out-of-bounds array access.,-		if (*cur < 0xC0) {
==40644==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eef7 at pc 0x7ff28073d830 bp 0x7ffe05f5ec10 sp 0x7ffe05f5ec08.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
Free input buffer in xmlHaltParser.,"+        if (ctxt->input->buf != NULL) {
+            xmlFreeParserInputBuffer(ctxt->input->buf);
+            ctxt->input->buf = NULL;
+        }"
Heap-based buffer overread in xmlDictAddString. ,"     return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));"
bug report: Global buffer-overflow in the htmlParseTryOrFinish function., 	    ctxt->input->free = NULL;
Make sure to set 'attvalue' to NULL after freeing it.,+		    xmlFree(attvalue);
"Use-after-free vulnerability in the xmlSAX2AttributeNs function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2 and OS X before 10.11.5, allows remote attackers to cause a denial of service via a crafted XML document.",-		if (alloc != 0) xmlFree(attvalue);
Advancing to the next character in case of an error while parsing regexp leads to an out of bounds access.,"     if (end < start) {
 	ERROR(""End of range is before start of range"");
     } else {
+        NEXTL(len);"
Fix some potential problems on reallocation failures.,"+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));"
Heap use-after-free in xmlSAX2AttributeNs.,-		if (alloc != 0) xmlFree(attvalue);
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure.,         ctxt->input->end = ctxt->input->cur;
Fix nullptr deref with XPath logic ops.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval &= arg2->boolval;"
The pointers from the context input were not properly reset after that call which can do reallocations.,		size_t current = ctxt->input->cur - ctxt->input->base;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,-        cur->nodeMax *= 2;
The attached document will cause an out of bounds heap read access in the function xmlParseXMLDecl.,            encoding = xmlParseEncName(ctxt);
Avoid extra processing of MarkupDecl when EOF.,"+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"libxml2 before 2.7.8, as used in Google Chrome before 7.0.517.44, Apple Safari 5.0.2 and earlier, and other products, reads from invalid memory locations during processing of malformed XPath expressions, which allows context-dependent attackers to cause a denial of service (application crash) via a crafted XML document.",     if (cur == NULL) cur = ctxt->context->node;
"For https://bugzilla.gnome.org/show_bug.cgi?id=759020 * parser.c: (xmlParseStartTag2): Attribute strings are only valid if the base does not change, so add another check where the base may change.",+		if ((attvalue != NULL) && (alloc != 0)) {
Buffer overflow errors originating from xmlBufGetInputBase in 2.9.0.," 	xmlParserInputBufferPush(ctxt->input->buf, 1, ""\r"");"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags. ,-    if (ctxt->input->base != base) goto base_changed;
==25920==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010810 at pc 0x0000004a2f25 bp 0x7ffc81805ae0 sp 0x7ffc81805290.," 	    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-        cur->nodeMax *= 2;
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-	    val1->nodeMax *= 2;
"The xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.3 does not properly prevent entity expansion, which allows context-dependent attackers to cause a denial of service (CPU consumption) via crafted XML data, a different vulnerability than CVE-2014-3660.","+		if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
+		    (ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
+		    goto int_error;"
"A remote attacker could provide a specially-crafted XML file that, when processed would lead to excessive CPU consumption (denial of service).","+	if (replacement < XML_MAX_TEXT_LENGTH)
+	    return(0);"
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for external entity references replacement (--noent option) was requested / enabled during the XML file parsing.",ent->checked = ctxt->nbentities - oldnbent;
Fix default template processing on namespace nodes.,"+    if (cur->type == XML_NAMESPACE_DECL)
+        return;"
The attached document will cause an out of bounds heap read access in the function xmlParseXMLDecl.,"            if (RAW != '""') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,-            } else if (*cur < 0xF8) {
heap-buffer-overflow in xmlStrncat <https://bugzilla.gnome.org/show_bug.cgi?id=763071>. ,     ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));
The pointers from the context input were not properly reset after that call which can do reallocations.,		size_t current = ctxt->input->cur - ctxt->input->base;
Fix infinite loop in LZMA decompression.,while (strm->avail_out && ret != LZMA_STREAM_END);
The pointers from the context input were not properly reset after that call which can do reallocations.,"+		size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);"
The count was incremented before the allocation and not fixed in case of failure.,"+	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *
 				      sizeof(xmlNodePtr));"
"A denial of service flaw was found in the way libxml2, a library providing support to read, modify and write XML and HTML files, performed string substitutions when entity values for entity references replacement (--noent option) was requested / enabled during the XML file parsing.","+        if (replacement < XML_PARSER_NON_LINEAR * consumed)
+	    return(0);"
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,"+                   ((cur->type == XML_DOCUMENT_NODE) ||
+                    (cur->type == XML_ELEMENT_NODE))) {"
"Hey, There appears to be an out-of-bounds read in libxml2 (2.9.2)."," 		xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,"
"If entities expansion in the XML parser is asked for, it is possble to craft relatively small input document leading to excessive on-the-fly content generation.","+	if (replacement < XML_MAX_TEXT_LENGTH)
+	    return(0);"
A race condition in chown_one() of systemd allows an attacker to cause systemd to set arbitrary permissions on arbitrary files.,"-        if (name)
-                r = fchownat(fd, name, uid, gid, AT_SYMLINK_NOFOLLOW);"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
So let's follow suit and only accept numbers in decimal notation.,"+        r = safe_atou32_full(s, 10, &uid);"
don't accept arbitrarily sized journal data fields.,"+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                if (r == 0) 
+                        break;"
journal-remote: set a limit on the number of fields in a message.,"+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                r = read_line(f, LONG_LINE_MAX, &line);"
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,+        unit_add_to_gc_queue(u);
"In systemd 223 through 235, a remote DNS server can respond with a custom crafted DNS NSEC resource record to trigger an infinite loop in the dns_packet_read_type_window() function of the 'systemd-resolved' service and cause a DoS of the affected service. ","        if (p->question->n_keys != 1)
                return 0;"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        else if (r == -E2BIG)
+                                log_warning_errno(r, ""Entry with more fields than the maximum of %u, aborting connection %p."",
+                                                  ENTRY_FIELD_COUNT_MAX, connection);"
journal: do not remove multiple spaces after identifier in syslog message.,"+        e += strspn(p + e, WHITESPACE);"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g.","+                r = read_line(f, LONG_LINE_MAX, &line);"
let's rework the recursive logic to use O_PATH.,"+        xsprintf(procfs_path, ""/proc/self/fd/%i"", fd);"
journal: do not remove multiple spaces after identifier in syslog message.,"+        if (p[e] != '\0' && strchr(WHITESPACE, p[e]))
+                e++;"
"When executing the udevadm trigger command, a memory leak may occur.","         r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);"
nss-mymachines: do not allow overlong machine names.,"+        if (e - p > HOST_NAME_MAX - 1) 
+                goto not_found;"
systemd-resolved through 233 allows remote attackers to cause a denial of service (daemon crash) via a crafted DNS response with an empty question section.,"        if (p->question->n_keys != 1)
                return 0;"
Units that failed to load were never cleaned up.,+        unit_add_to_gc_queue(u);
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,         unit_add_to_dbus_queue(u);
resolved: fix loop on packets with pseudo dns types.,"+                for (; bitmask; bit++, bitmask >>= 1)"
"A malicious DNS server can exploit this via a response with a specially crafted TCP payload to trick systemd-resolved into allocating a buffer that's too small, and subsequently write arbitrary data beyond the end of it.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
"This behaviour is definitely not expected by users, since tools generally only accept decimal numbers (e.g.","+        r = safe_atou32_full(s, 10, &uid);"
journald: don't accept arbitrarily sized journal data fields.,"+                        if (l > DATA_SIZE_MAX) {
+                                log_debug(""Received binary data block too large, ignoring."");
+                                break;
+                        }"
"Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.",-#define ENTRY_SIZE_MAX (1024*1024*32)
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","-                        if (r == -E2BIG)
-                                log_warning_errno(r, ""Entry is too above maximum of %u, aborting connection %p."","
nss-mymachines: do not allow overlong machine names.,"+        if (e - p > HOST_NAME_MAX - 1)
+                goto not_found;"
journal-remote: set a limit on the number of fields in a message.,"+                        if (r == -ENOBUFS)
+                                log_warning_errno(r, ""Entry is above the maximum of %u, aborting connection %p."",
                                                  DATA_SIZE_MAX, connection);"
"systemd 37-1 does not properly handle non-existent services, which causes a denial of service (failure of login procedure).",+        unit_add_to_gc_queue(u);
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
garbage collect units with load error.,+        unit_add_to_gc_queue(u);
So it seems that it's not uncommon for dhcp6-client to get the length wrong.,"+        if (*buflen < offsetof(DHCP6Option, data) + len)"
A race condition in chown_one() of systemd allows an attacker to cause systemd to set arbitrary permissions on arbitrary files.,"-                if (!S_ISLNK(st->st_mode))
-                        r = fchmodat(fd, name, st->st_mode, 0);"
A stack-based buffer overflow vulnerability was found in getpwnam()/getgrnam() functions of NSS module nss-mymachines provided by systemd.,"        r = parse_uid(e + 1, &uid);"
basic/user-util: always use base 10 for user/group numbers.,         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
bus_open leak sd_event_source when udevadm trigger.,+        b->io_event_source = sd_event_source_unref(b->io_event_source);
An out-of-bounds read when parsing a crafted syslog message that could lead to information disclosure.,         *buf = p + e;
journald: don't accept arbitrarily sized journal data fields.,+#define DATA_SIZE_MAX (1024*1024*64)
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        if (r == -ENOBUFS)
+                                log_warning_errno(r, ""Entry is above the maximum of %u, aborting connection %p."",
                                                  DATA_SIZE_MAX, connection);"
"An integer overflow, leading to heap-based buffer overflow flaw was found in the way journald functionality of systemd, a system and service manager, processed native messages.","+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
So let's follow suit and only accept numbers in decimal notation.,         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
journal: do not remove multiple spaces after identifier in syslog message.,"-        e += strspn(p + e, WHITESPACE);"
An out-of-bounds read when parsing a crafted syslog message that could lead to information disclosure.,"-        e += strspn(p + e, WHITESPACE);"
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,-                        return -errno;
It was possible to reach the 128K limit of units by attempting to load a bunch of nonsense.,+        unit_add_to_gc_queue(u);
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g.","+                if (r < 0)
+                        return log_error_errno(r, ""Failed to read serialization line: %m"");"
This can lead to a denial of service attack or arbitrary code execution in some cases.,"-                        if (r == -E2BIG)
-                                log_warning_errno(r, ""Entry is too above maximum of %u, aborting connection %p."","
"An integer overflow, leading to heap-based buffer overflow flaw was found in the way journald functionality of systemd, a system and service manager, processed native messages.",-#define ENTRY_SIZE_MAX (1024*1024*32)
Stack-based buffer overflow in the getpwnam and getgrnam functions of the NSS module nss-mymachines in systemd.,"        r = parse_uid(e + 1, &uid);"
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,"-               if (!fgets(line, sizeof(line), f)) {"
dhcp6 packet size calculation fixes.,"+        if (*buflen < offsetof(DHCP6Option, data) + len)"
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g. change the main-pid, control-pid, etc.)","+                if (r < 0)
+                        return log_error_errno(r, ""Failed to read serialization line: %m"");"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
"This behaviour is definitely not expected by users, since tools generally only accept decimal numbers (e.g.",         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
resolved: simplify alloc size calculation.,"+        a = MAX(mtu, DNS_PACKET_HEADER_SIZE);"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
A buffer overflow vulnerability in the dhcp6 client of systemd allows a malicious dhcp6 server to overwrite heap memory in systemd-networkd.,        *buflen -= sizeof(DHCP6Option);
This can be used to improperly influence systemd execution and possibly lead to root privilege escalation.,"-                        if (feof(f))
-                                return 0;"
fix loop on packets with pseudo dns types.,"+        if (!p->question)
+                return 0;"
"Integer overflow in the valid_user_field function in journal/journald-native.c in systemd allows remote attackers to cause a denial of service (crash) and possibly execute arbitrary code via a large journal data field, which triggers a heap-based buffer overflow.","+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
"A malicious DNS server can exploit this via a response with a specially crafted TCP payload to trick systemd-resolved into allocating a buffer that's too small, and subsequently write arbitrary data beyond the end of it.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
journald: don't accept arbitrarily sized journal data fields.,"+                        if ((uint64_t) remaining < e - p + 1 + sizeof(uint64_t) + l + 1 ||
                             e[1+sizeof(uint64_t)+l] != '\n') {"
basic/user-util: always use base 10 for user/group numbers.,"+        r = safe_atou32_full(s, 10, &uid);"
The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().,-            u_int addr_size = 4;
which could cause an out-of-bounds read when decoding an invalid packet.,         optlen = EXTRACT_16BITS(tlv + 2);
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
CVE-2017-13025/IPv6 mobility: Add a bounds check before fetching data,+			ND_TCHECK_128BITS(&bp[i+2]);
"In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo), put it right.",-                if(len < 1)
Fix some bounds checks.,+	ND_TCHECK(*k);
In aodv_extension() do a bounds check on the extension header before we look at it.,+	ND_TCHECK(*ep);
This fixes a buffer over-read discovered by Kamil Frankowicz.,"-	ND_TCHECK2(dp[0], 0);"
This fixes a buffer over-read discovered by Kamil Frankowicz.,-					ND_TCHECK(dp[0]);
This fixes a buffer over-read discovered by Yannick Formaggio.,-	if (len < sizeof(*prep)) {
Do bounds checking when comparing strings.,"+	if (!ND_TTEST2(*str2, tl1)) {
+		return 0;
+	}"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,-        while (len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+			if (optlen == 6)
 				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_MP).,"                 ND_TCHECK2(opt[i+2], cap_len);"
"If it returns a negative number, it hasn't necessarily filled in buf, so just return immediately; this is similar to the IPv4 code path, wherein we just return a negative number, and print nothing, on an error.","+        if (plenbytes < 0)
+            return plenbytes;"
The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_print().," 			if (dp->icmp6_data16[1] & 0xc0)
 				ND_PRINT((ndo,"" ""));"
fix bounds checks for UNI.,"+                    if(subobj_len < 4 || subobj_len > total_subobj_len)
                         goto invalid;"
fix bounds checks for UNI,"+                    if (total_subobj_len < 4)
+                        goto invalid;"
"It can fail, so make sure it doesn't before comparing its result with the password.","+	if (strcmp(user_password, crypt_password) != 0)"
CVE-2017-13037/IP: Add bounds checks when printing time stamp options.,+	ND_TCHECK(cp[2]);
Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         type = *(tptr);
Check before fetching the length from the included packet's IPv4 header.,+		ND_TCHECK_16BITS(&ip->ip_len);
"clean up some other bounds checks,","-            if (msg_tlen < 4)
-                goto trunc;"
CVE-2017-12896/ISAKMP: Do bounds checks in isakmp_rfc3948_print().,+	ND_TCHECK(bp[0]);
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \0.,+	len = strlen (ptr);
The Apple PKTAP parser in tcpdump before 4.9.2 has a buffer over-read in print-pktap.c:pktap_if_print().,"-			hdrlen += printer(ndo, h, p);"
The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().,"-	else if (l_strnstart(""END"", 4, (const char *)bp, length))"
tcpdump.org tcpdump 4.9.2 is affected by: CWE-126: Buffer Over-read.,"         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));"
In aodv_extension() do a bounds check on the extension header before we look at it., 	switch (ep->type) {
This fixes a buffer over-read,"                     ND_PRINT((ndo, ""\n\t\tRestart Flags: [%s], Restart Time %us"","
Add length checks.,"+	ND_TCHECK2(*p, CHDLC_HDRLEN);"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:nfs_printfh().,"-		strncpy(temp, sfsname, NFSX_V3FHMAX);"
"While we're at it, clean up some other bounds checks, so we check that we have a complete IPv4 message header if it's IPv4 and a complete IPv6 message header if it's IPv6.","+            ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
"Check before fetching the ""access"" part of the NFSv3 ACCESS results.",+				ND_TCHECK(dp[4]);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-	if (!ND_TTEST2(*ar_tpa(ap), PROTO_LEN(ap))) {"
CVE-2017-12899/DECnet: Fix bounds checking.,+	    ND_TCHECK(rhp->rh_short.sh_flags);
Prevent a possible buffer overread in chdlc_print() and replace the custom check in chdlc_if_print() with a standard check in chdlc_print() so that the latter certainly does not over-read even when reached via juniper_chdlc_print()., 	proto = EXTRACT_16BITS(&p[2]);
do sanity checks on PHB header length before allocating memory.,"+	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
+            (total_length > BT_SHB_INSANE_MAX)) {"
Don't crash if crypt() fails., 		return -1;
"Include a test for the ""check before fetching the ""access"" part..."" fix, using the capture supplied by the reporter(s).",-				ND_TCHECK(dp[2]);
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.","+            if (subl == 0)
+                break;"
The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,-				if (chars_processed >= data_size) {
Add more bounds checks.,"+            ND_TCHECK2(p[0], 2);"
This fixes a buffer over-read,"             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_start),"
Add two bounds checks before fetching data, 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
This fixes a buffer over-read,"-	while (tp->e_nxt)
-		if (tp->e_addr0 == i &&
-		    tp->e_addr1 == j &&
-		    tp->e_addr2 == k &&
-		    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""NUL "", 4, (const char *)bp, length))"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_multicast_vpn().,"-            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);"
Calculate the reply payload length in a local variable.,+	replylen = 0;
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.",+	ND_TCHECK(*idp);
The Babel parser in tcpdump before 4.9.3 has a buffer over-read in print-babel.c:babel_print_v2().,-                if(len < 1)
The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().,         vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,"             ND_PRINT((ndo, ""\n\t    IOS version: %u.%u, EIGRP version %u.%u"",
                    tlv_ptr.eigrp_tlv_sw_version->ios_major,"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply()., 	astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.,"+	if (total_length < sizeof(*bhdrp) + sizeof(*shbp) + sizeof(struct block_trailer) ||
+            (total_length > BT_SHB_INSANE_MAX)) {"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio,"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.", 			while (cp < ep && cp < ep2) {
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
Buffer Over-read.,"         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));"
(for 4.9.3) CVE-2018-14882/ICMP6 RPL: Add a missing bounds check.,+                ND_TCHECK(opt->rpl_dio_len);
The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_nodeinfo_print()., 			if (cp[0] == ep - cp - 1) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 	ptr = cp[2] - 1;
"The loop can be executed more than once (that's kinda the whole point of a loop), so the check has to be made each time through the loop, not just once before the loop is executed.","+		    ND_TCHECK2(tptr[0], 3);"
Clean up bounds checking.,-		if (j * sizeof(*ni) != length - 4)
CVE-2017-12996/PIMv2: Make sure PIM TLVs have the right length.,+				if (olen != 4) {
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,             bit_length = tlv_ptr.eigrp_tlv_ip_ext->plen;
Check that the entire ar_stat field is present in the capture.,+	ND_TCHECK(dp[0]);
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""RPY "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP RPY""));"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.",           len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;
(for 4.9.3) CVE-2018-14465/RSVP: Add a missing bounds check in rsvp_obj_print().,+                ND_TCHECK_32BITS(obj_tptr);
The arguments to memcpy() were completely wrong.,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
CVE-2017-16808/AoE: Add a missing bounds check.,"+		ND_TCHECK_LEN(cp, MAC_ADDR_LEN);"
In rx_cache_insert() and rx_cache_find() properly read the serviceId field of the rx_header structure as a 16-bit integer. ,+		    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&
This fixes a buffer over-read discovered by Kim Gwan Yeong., 		ni6 = (const struct icmp6_nodeinfo *)dp;
CVE-2017-13025/IPv6 mobility: Add a bounds check before fetching data.,+			ND_TCHECK_128BITS(&bp[i+2]);
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",             l2info->proto = EXTRACT_16BITS(p);
This fixes a buffer over-read,"             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_start),"
The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().,-            if (!saw_digit)
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""SEQ "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP SEQ""));"
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-					ND_PRINT((ndo, "" ?0x%04x?"", EXTRACT_16BITS(bp+2)));"
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""ERR "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ERR""));"
Add length checks.,"+                if (length < 2)
+                    goto trunc;"
"In aoev1_reserve_print() check bounds, before trying to print an Ethernet address."," 		ND_PRINT(""\n\tEthernet Address %u: %s"", i, etheraddr_string(ndo, cp));"
Fix processing of TIM IE.,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
"When bgp_attr_print() tried to decode the variable-length nexthop value for the NSAP VPN case, it did not check that the declared length is good to interpret the value as a mapped IPv4 or IPv6 address.",-                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)
Add an intermediate bounds check to make it safe.,+		if (caplen < hdrlen + 1) {
CVE-2017-13049/Rx: add a missing bounds check for Ubik.,+			ND_TCHECK_32BITS(bp);
The VRRP parser in tcpdump before 4.9.3 has a buffer over-read in print-vrrp.c:vrrp_print().," 				ND_PRINT((ndo, "", (bad vrrp cksum %x)"",
 					EXTRACT_16BITS(&bp[6])));"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		    i -= sizeof(*ni), ++ni) {"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         vqp_obj_type = EXTRACT_32BITS(vqp_obj_tlv->obj_type);
CVE-2017-13022/IP: Add bounds checks to ip_printroute().,"+			if (ip_printroute(ndo, cp, option_len) == -1)
+				goto trunc;"
The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print().," 		ND_PRINT((ndo, ""\n\t      Area address (length: %u): %s"","
Add more bounds checks.,"+        ND_TCHECK2(p[0], 3);"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().," 				ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64,
 						EXTRACT_32BITS(&dp[4]),
 						EXTRACT_32BITS(&dp[2]),
 						EXTRACT_64BITS(&dp[0])));"
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,             bit_length = tlv_ptr.eigrp_tlv_ip_int->plen;
This fixes a buffer over-read,-		for (ni = rp->rip6_nets; i >= sizeof(*ni);
CVE-2017-13023/IPv6 mobility: Add a bounds check before fetching data.,+			ND_TCHECK_16BITS(&bp[i+2]);
Clean up other length tests while we're at it.,"-   for (i=0; *data && i < length ; i++, data++)"
"Move a return to make the code a bit cleaner (i.e., make it more obvious that if we don't have enough of the PGM header, we just print the source and destination IP addresses, mark it as incomplete PGM, and don't try to look at the PGM header).",-			return;
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-12993/Juniper: Add more bounds checks.,+        ND_TCHECK(*gh);
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"")""));"
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.",+	ND_TCHECK(*idp);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options"," 			else
+				ND_PRINT((ndo, "" [optlen != 6]""));"
CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+			nhdr.caplen = caplen;
The OSPFv3 parser in tcpdump before 4.9.3 has a buffer over-read in print-ospf6.c:ospf6_print_lshdr().,-	ND_TCHECK(lshp->ls_type);
"could over-read the input buffer,","         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,                     subobj_len  = EXTRACT_16BITS(obj_tptr);
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+        if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
+          goto trunc;"
This fixes a buffer over-read,"+   for (i=0; i < length && *data; i++, data++)
        ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 	    bw.i = EXTRACT_32BITS(obj_tptr+offset+4);
The PPP parser in tcpdump before 4.9.2 has a buffer over-read in print-ppp.c:handle_mlppp().,"     ND_PRINT((ndo, ""seq 0x%03x, Flags [%s], length %u"",
            (EXTRACT_16BITS(p))&0x0fff, 
            bittok2str(ppp_ml_flag_values, ""none"", *p & 0xc0),"
fix VPN route target bounds checks,"-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print()., 		len -= advance;
"The IKEv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c, several functions.",-	ND_TCHECK(*ext);
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",         extracted_ethertype = EXTRACT_16BITS(p);
The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_id().,"         snprintf(pos, sizeof(id) - (pos - id), ""%02x"", *cp++);"
CVE-2017-13005/NFS: Add two bounds checks before fetching data.,"+	if (!ND_TTEST(rp->rm_call.cb_proc))
+		return (0);"
The IKEv1 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c:ikev1_id_print().,"-			if (len < 20)
-				ND_PRINT((ndo,"" len=%d [bad: < 20]"", len));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
"This is what BIND 9.11.0-P2 does; it not only detects pointers that loop, as ""point backwards"" means ""point before anything we\'ve processed so far, including what we\'re processing right now"", so the pointer can\'t point to itself (as that\'s what we\'re processing right now).",+				if (offset >= max_offset) {
Rearrange those steps the correct way around.,-            bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
Use ND_TTEST() rather than comparing against ndo->ndo_snapend ourselves; it's easy to get the tests wrong.,"-    if (*pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" status=(""));"
Add a missing bounds check in icmp_print().,+				ND_TCHECK_16BITS(&dp->icmp_cksum);
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""ERR "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ERR""));"
The IP parser in tcpdump before 4.9.2 has a buffer over-read in print-ip.c:ip_printts()., 	ptr = cp[2] - 1;
CVE-2017-13014/White Board: Do more bounds checks.,"+	if (len < sizeof(*prep) || !ND_TTEST(*prep))
 		return (-1);"
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \\0.,+	len = strlen (ptr);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         len = EXTRACT_16BITS(tptr+2);
CVE-2017-12993/Juniper: Add more bounds checks.,+        ND_TCHECK(*ih);
CVE-2017-13022/IP: Add bounds checks to ip_printroute().,"+		ND_TCHECK2(cp[len], 4);"
Clean up bounds checking.,"-		if (j == 1
-		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
-		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
-			ND_PRINT((ndo, "" ripng-req dump""));
-			break;"
Ryan Ackroyd had independently identified this buffer over-read later by means of fuzzing and provided the packet capture file for the test., 			if (optlen > 2) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",                     af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;
The total length of the OID is the OID length plus the length of the OID length itself.,"+        if (tlen < 1U + oid_len) {
             return 0;
         }"
This fixes a buffer over-read,                         for (i = 0; i < tptr[1] * as_size; i += as_size) {
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check","         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
"It can fail, so make sure it doesn't before comparing its result with the password.",+	if (crypt_password == NULL)
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_attr_print() (MP_REACH_NLRI).,-                                if (EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)
"Add a length check to fix that and remove a useless boundary check from a loop because the boundary is tested for the full length of ""V"" before the switch block.","+            if (subl == 0)
+                break;"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
This caused an out-of-bounds read and could cause a write.,"-	if (ptr[strlen(ptr) - 1] == '\n')
-		ptr[strlen(ptr) - 1] = '\0';"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,-					ND_TCHECK(dp[0]);
CVE-2017-13002/AODV: Add some missing bounds checks.,+	ND_TCHECK(*ep);
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;","-			hdrlen += printer(ndo, h, p);"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"")""));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_MCID_MIN_LEN);"
"Also, put the buffer on the stack; no reason to make it static.",-		static char temp[NFSX_V3FHMAX+1];
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""RPY "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP RPY""));"
"Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst (if the request had extra stuff at the end, so that the variable is non-zero).",-			plen+= strlen(d->description);
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-	i = min(length, amt);"
offset has already been advanced to point to the bitmap; we shouldn't add the amount to advance again.,"-			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);"
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","+	as_printf(ndo, asbuf, sizeof(asbuf), EXTRACT_32BITS(pptr + 1));"
CVE-2017-12993/Juniper: Add more bounds checks.,"+        ND_TCHECK2(p[0], 2);"
CVE-2017-12985/IPv6: Check for print routines returning -1 when running past the end.,"                 if (in_cksum(vec, 1)) {"
CVE-2017-13690/IKEv2: Fix some bounds checks.,+	ND_TCHECK(*idp);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
This fixes a buffer overflow,"-                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
-                                     sepstr, lp->s);"
"The bounds check in esis_print() tested one pointer at the beginning of a loop that incremented another, make the trivial fix.",-                    ND_TCHECK(*pptr);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-	ND_TCHECK(*ext);
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-					unsigned_relts_print(ndo, *(bp+1));"
Rearrange those steps the correct way around.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                 ND_PRINT((ndo, "" FASTv%u"",
                        EAP_TTLS_VERSION(*(tptr + 5))))"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""ERR "", 4, (const char *)bp, length))"
This fixes a buffer over-read,-	amt = ndo->ndo_snapend - dat;
The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().,-    if (*bp != '\r')
CVE-2017-13690/IKEv2: Fix some bounds checks.,"+	ND_TCHECK2(*ext, sizeof(a));"
"The White Board protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-wb.c:wb_prep(), several functions.", 	n = EXTRACT_32BITS(&prep->pp_n);
Rearrange those steps the correct way around.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
"Also, make the buffer bigger.",+                    bufp += string_size;
Fixup the part of rsvp_obj_print() that decodes the GENERALIZED_UNI object from RFC 3476 Section 3.1 to check the sub-objects inside that object more thoroughly.,"+                    if(subobj_len < 4 || subobj_len > total_subobj_len)
                         goto invalid;"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-	ND_TCHECK(*ext);
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	if (!ND_TTEST2(*str2, tl1)) {
+		return 0;
+	}"
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \0.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,"-		        ND_TCHECK2(tptr[3], 8);"
add a missing length check,"+        if (tlv_len < 6) {
+            return hexdump;
+        }"
Calculate the reply payload length in a local variable.," 		if (d->name)
+			replylen += strlen(d->name);"
The OSPFv3 parser in tcpdump before 4.9.2 has a buffer over-read in print-ospf6.c:ospf6_decode_v3().," 		ND_PRINT((ndo, ""\n\tOptions [%s]"",
 		          bittok2str(ospf6_option_values, ""none"",
 		          EXTRACT_32BITS(&hellop->hello_options))));"
This fixes a buffer over-read,-				if (EXTRACT_16BITS(bp+2) != 0) {
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.","                    tok2str(juniper_protocol_values,""Unknown"",gh->proto),"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-          ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_BVID_MIN_LEN);"
This fixes a buffer over-read discovered by Kamil Frankowicz., 	astat = (enum sunrpc_accept_stat) EXTRACT_32BITS(dp);
CVE-2017-13690/IKEv2: Fix some bounds checks.,-	ND_TCHECK(*ext);
"The TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop counter will overflow and you can loop infinitely.",         	i=i+3;
"Add bounds checks,","+    ND_TCHECK2(*tptr, 2);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",             subtype = *(tptr+4);
Add two bounds checks before fetching data, 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
Fix a bounds check,"+        if (tlen < 1U + oid_len) {
             return 0;
         }"
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.","+	ND_TCHECK2(*ext, sizeof(a));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
CVE-2017-13028/BOOTP: Add a bounds check before fetching data This,+	ND_TCHECK(bp->bp_flags);
Improve bounds and length checks.,"+	if (length < CHDLC_HDRLEN)
+		goto trunc;"
The VTP parser in tcpdump before 4.9.2 has a buffer over-read in print-vtp.c:vtp_print()., 	    len = *tptr;
fix VPN route target bounds checks,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-	ND_TCHECK(*ext);
This fixes a buffer over-read discovered by Kamil Frankowicz.," 			ND_PRINT((ndo, "" c %04x"", EXTRACT_32BITS(&dp[0])));"
CVE-2017-12989/RESP: Make sure resp_get_length() advances the pointer for invalid lengths.,"+    if (*bp != '\r') {
+        bp++;
         goto invalid;
+    }"
(for 4.9.3) CVE-2018-16228/HNCP: make buffer access safer.,"+        if (plenbytes < 0)
+            return plenbytes;"
Add a bounds check before fetching data,+		ND_TCHECK_32BITS(&hellop->hello_options);
"After we advance the pointer by the length value in the buffer, make sure it points to something in the captured data.", 	s += (*s) + 1;
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-12995/Check for DNS compression pointers that don't point backwards.,+				if (offset >= max_offset) {
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
Need to test bounds check for the last field of the structure lsa6_hdr.,+	ND_TCHECK(lshp->ls_length);
(for 4.9.3) CVE-2018-14463/VRRP: Add a missing bounds check in vrrp_print().,"+			if (in_cksum(vec, 1)) {"
Do bounds checking as we access items.,+	ND_TCHECK(rp->rip6_vers);
fix an Extended IS Reachability sub-TLV,"+            if (subl == 0)
+                break;"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		if (j == 1
-		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
-		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
-			ND_PRINT((ndo, "" ripng-req dump""));
-			break;"
"While we're at it, add the RFC number, and check the validity of the length for the Hello extension.",+		if (ep->length < 4) {
put an existing bounds check right,+                    ND_TCHECK(*tptr);
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().," 		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,=B105
This fixes a buffer over-read, 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,"                     ND_PRINT((ndo, "" %s (%u),"",
                            tok2str(eap_type_values, ""unknown"", *(tptr+count)),
                            *(tptr + count)));"
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_RESTART).,"                     ND_PRINT((ndo, ""\n\t\tRestart Flags: [%s], Restart Time %us"","
CVE-2017-12989/RESP: Make sure resp_get_length() advances the pointer for invalid lengths.,"+    if (*bp != '\n') {
+        bp++;
         goto invalid;
+    }"
"Check before fetching the ""access"" part of the NFSv3 ACCESS results.",-				ND_TCHECK(dp[2]);
This fixes a buffer over-read discovered by Bhargava Shastry.," 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));"
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levom??ki.,-				chars_processed++;
Enforce a limit on how many times smb_fdata() can recurse.,"+		if (depth == 10)
+			ND_PRINT((ndo, ""(too many nested levels, not recursing)""));"
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check","+        if (tlv_len < 6) {
+            return hexdump;
+        }"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_extd_ip_reach().,         status_byte=*(tptr++);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
Clean up bounds checking.,"-		if (j * sizeof(*ni) != length - 4)
-			ND_PRINT((ndo, "" ripng-req %d[%u]:"", j, length));"
Calculate the reply payload length in a local variable.," 		if (d->description)
+			replylen += strlen(d->description);"
CVE-2017-13032/RADIUS: Check whether a byte exists before testing its value.,"+           if (length < 1)
+              goto trunc;"
"Check for running out of packet data before checking for running out of captured data, and distinguish between running out of packet data (which might just mean ""no more strings"") and running out of captured data (which means ""truncated"").",+	if (!ND_TTEST(**pptr)) {
"The TLV length here is 9 bits long, not 8 bits long, so an 8-bit loop counter will overflow and you can loop infinitely.",+    u_int i;
CVE-2017-13008/IEEE 802.11: Fix TIM bitmap copy to copy from p + offset.,"+			memcpy(tim.bitmap, p + offset, tim.length - 3);"
The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().,-	uint8_t  ip6r0_slmap[3];
Add missing checks to dhcpv6_print().,"+        if (i + 4 + optlen > length)
+            return -1;"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+	struct pcap_pkthdr nhdr;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 	ND_PRINT((ndo, "", Config Rev %x"", EXTRACT_32BITS(tptr)));"
In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo),"+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
add some bounds checks,"+        if (sizeof(struct vqp_obj_tlv_t) > tlen)
+            goto trunc;"
"However, dhcpv6_print() in the same file didn't do the same for the DHCPv6 options within the HNCP DHCPv6-Data TLV value, which could cause an out-of-bounds read when decoding an invalid packet.",         optlen = EXTRACT_16BITS(tlv + 2);
CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().,+                    space_left -= string_size;
In rx_cache_insert() and rx_cache_find() properly read the serviceId field of the rx_header structure as a 16-bit integer. ,+	rxent->serviceId = EXTRACT_16BITS(&rxh->serviceId);
Calculate the reply payload length in a local variable.,+		replylen += sizeof(struct rpcap_findalldevs_if);
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.","-                ND_TCHECK2(*tptr, 4);"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		j = length / sizeof(*ni);
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,"                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio"
Don't crash if crypt() fails.,+		return -1;
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_DIGEST_MIN_LEN);"
(for 4.9.3) CVE-2018-14882/ICMP6 RPL: Add a missing bounds check,+                ND_TCHECK(opt->rpl_dio_len);
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,"             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_ext->cable_start),"
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.","+	ND_TCHECK2(*ext, sizeof(a));"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_rt_routing_info().,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
Prevent a possible buffer overread in chdlc_print() and replace the custom check in chdlc_if_print() with a standard check in chdlc_print() so that the latter certainly does not over-read even when reached via juniper_chdlc_print().,"+	return chdlc_print(ndo, p, h->len);"
CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+	struct pcap_pkthdr nhdr;
"Also, put the buffer on the stack; no reason to make it static.",+		char temp[NFSX_V3FHMAX+1];
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 			ND_PRINT((ndo, ""(refresh: %u)"",
 				EXTRACT_16BITS(&bp[i+2]) << 2));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",                     subobj_len  = EXTRACT_16BITS(obj_tptr);
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""ANS "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ANS""));"
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them.,+	len = dp->ip6r_len;
Add more bounds checks.,+        ND_TCHECK(*gh);
"If one is, don't run past the end.","+    if (sysid_len > id_len)
+        sysid_len = id_len;"
CVE-2017-13015/EAP: Add more bounds checks.,+                ND_TCHECK_8BITS(tptr + 5);
Check for DNS compression pointers that don't point backwards.,+				if (offset >= max_offset) {
This fixes a buffer over-read,             l2info->proto = EXTRACT_16BITS(p);
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,+                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
offset has already been advanced to point to the bitmap; we shouldn't add the amount to advance again.,"-			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);"
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-				ND_PRINT((ndo, ""v%d"", *bp));"
This fixes a buffer overflow,+                    space_left -= string_size;
CVE-2017-12998/IS-IS: Check for 2 bytes if we're going to fetch 2 bytes.,"+        if (!ND_TTEST2(*tptr, 2)) 
             return (0);"
CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().,+                    space_left -= string_size;
"The bounds check in esis_print() tested one pointer at the beginning of a loop that incremented another, make the trivial fix.",+                    ND_TCHECK(*tptr);
"When those functions tried to read 32 bits the extra 16 bits could be outside of the bounds checked in rx_print() for the rx_header structure, as serviceId is the last field in that structure.",-		    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&
Improve bounds and length checks.,"+                if (length < 2)
+                    goto trunc;"
CVE-2017-12992/RIPng: Clean up bounds checking.,"-		if (j == 1
-		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
-		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
-			ND_PRINT((ndo, "" ripng-req dump""));
-			break;"
The telnet parser in tcpdump before 4.9.2 has a buffer over-read in print-telnet.c:telnet_parse().," 		if (*p != IAC)
 			goto pktend;"
add checks to make sure the subTLV fits within the TLV.,"+      	if (stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN)
+      	  goto trunc;"
"do a common check to make sure we captured the entire subTLV,","+    ND_TCHECK2(*(tptr), stlv_len);"
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",             l2info->proto = EXTRACT_16BITS(p);
"In aoev1_reserve_print() check bounds, before trying to print an Ethernet address.","+		ND_TCHECK_LEN(cp, MAC_ADDR_LEN);"
Calculate the reply payload length in a local variable.,+				replylen += (sizeof(struct rpcap_sockaddr) * 4);
fix VPN route target bounds checks,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
"clean up some other bounds checks,","-            ND_TCHECK2(*msg_data, 4);"
CVE-2017-13687/CHDLC: Improve bounds and length checks.,"+	ND_TCHECK2(*p, CHDLC_HDRLEN);"
"clean up some other bounds checks,","-        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+    ND_TCHECK2(*(tptr), stlv_len);"
This fixes a buffer over-read,             bit_length = tlv_ptr.eigrp_tlv_ip_ext->plen;
"Add bounds checks,","+          if (stlv_len < 8)
+            goto trunc;"
(for 4.9.3) CVE-2018-14461/LDP: Fix a bounds check.,+	TLV_TCHECK(12);
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	if (l_strnstart(""MSG"", 4, (const char *)bp, length))"
Add a missing option length check., 		case DH6OPT_RECONF_MSG:
The Cisco HDLC parser in tcpdump before 4.9.2 has a buffer over-read in print-chdlc.c:chdlc_print().,"+	return chdlc_print(ndo, p, h->len);"
(for 4.9.3) CVE-2018-14468/FRF.16: Add a missing length check.,+                if (ie_len != 4) {
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst,			plen+= strlen(d->name);
The ISAKMP parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c:isakmp_rfc3948_print()., 	if(length == 1 && bp[0]==0xff) {
Add a bounds check and a comment to bgp_capabilities_print().,+                    ND_TCHECK_8BITS(opt + i + 5);
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,-        tptr = tptr + sizeof(struct isis_subtlv_spb_mcid);
Add two bounds checks before fetching data,"+	if (!ND_TTEST(rp->rm_call.cb_proc))
+		return (0);"
Add missing checks to make this safe.,"+                                else if (tlen == BGP_VPN_RD_LEN + 3 + sizeof(struct in6_addr)
+                                         && EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)"
"We might, for example, want to make sure the upper 2 bits of the label length/pointer byte are 00 or 11, and that if we encounter a pointer and jump backwards to what we think is a label the label ends before the beginning of the last label we processed, to make sure the pointer doesn't point backwards into the *middle* of a label, and also make sure the entire name is <= 255 bytes long.",+				if (offset >= max_offset) {
Add more bounds checks.,"+        ND_TCHECK2(p[0], 2);"
Properly terminate all struct tok arrays.,"+    { 0, NULL},"
"The IKEv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c, several functions.",-	ND_TCHECK(*ext);
don't print the address as an IPv4 address.,"+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+            if (!ext_dp->icmp_length &&
+                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		if (j * sizeof(*ni) != length - 4)
CVE-2017-12999/IS-IS: Add a missing length check.,"+	        ND_TCHECK2(*tptr, alen);"
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_MP).,"                    ND_PRINT((ndo, ""\n\t\tAFI %s (%u), SAFI %s (%u)"",
                           tok2str(af_values, ""Unknown"",
                                      EXTRACT_16BITS(opt+i+2)),"
CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.,"+				ND_PRINT((ndo,"")""));"
add checks to make sure the subTLV fits within the TLV.,+        while (stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
This fixes a buffer over-read discovered by Kamil Frankowicz.,-		temp[sizeof(temp) - 1] = '\0';
CVE-2017-13015/EAP: Add more bounds checks.,+        ND_TCHECK_8BITS(tptr);
(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \\0.,+	len = strlen (ptr);
Properly check for buffer overflow in bittok2str_internal().,+                    space_left -= string_size;
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check","+        if (tlv_len < 6) {
+            return hexdump;
+        }"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+    ND_TCHECK2(*(tptr), stlv_len);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-            u_int addr_size = 4;
Properly terminate all struct tok arrays.,"+    { 0,  NULL},"
fix decoding of MVPN route types 6 and 7 RFC 6514 Section 4.6 defines the structure for Shared Tree Join (6) and Source Tree Join (7) multicast VPN route types.,+            pptr += BGP_VPN_RD_LEN + 4;
The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().,"-            ND_TCHECK2(*msg_data, 4);"
Fixup the part of rsvp_obj_print() that decodes the GENERALIZED_UNI object from RFC 3476 Section 3.1 to check the sub-objects inside that object more thoroughly.,"+                    if (total_subobj_len < 4)
+                        goto invalid;"
CVE-2017-12987/IEEE 802.11: Fix processing of TIM IE.,"+			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);"
The FRF.16 parser in tcpdump before 4.9.3 has a buffer over-read in print-fr.c:mfr_print().,"                 ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));"
(for 4.9.3) LMP: Add some missing bounds checks,+	    ND_TCHECK_8BITS(obj_tptr + offset + 3);
The ICMPv6 parser in tcpdump before 4.9.3 has a buffer over-read in print-icmp6.c.,                 opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);
NULL pointer dereference,"-	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)"
CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"")""));"
"While we're at it, clean up some other bounds checks, so we check that we have a complete IPv4 message header if it's IPv4 and a complete IPv6 message header if it's IPv6.","+            ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
This fixes a buffer over-read,"-				unsigned_relts_print(ndo, EXTRACT_16BITS(bp));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
Several protocol parsers in tcpdump before 4.9.2 could cause a buffer over-read in addrtoname.c:lookup_bytestring().,"-	while (tp->e_nxt)
-		if (tp->e_addr0 == i &&
-		    tp->e_addr1 == j &&
-		    tp->e_addr2 == k &&
-		    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,"-			    print_unknown_data(ndo, tptr+3,""\n\t      "", length-3);"
In aodv_extension() do a bounds check on the extension header before we look at it., 	switch (ep->type) {
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,         type = *(tptr);
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""RPY "", 4, (const char *)bp, length))"
Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
Add a missing bounds check in rsvp_obj_print().,+                ND_TCHECK_32BITS(obj_tptr);
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,"-		    ND_TCHECK2(tptr[3], length - 3);"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
This fixes a buffer over-read,         switch (ih->type) {
This fixes a buffer over-read discovered by Kamil Frankowicz.,-	if (caplen <= 1) {
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,             subtype = *(tptr+4);
The RSVP parser in tcpdump before 4.9.3 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,"                 ND_PRINT((ndo, ""%s  CT: %u"",
                        ident,
                        EXTRACT_32BITS(obj_tptr) & 0x7));"
"Add bounds checks,","+    if (len < stlv_len)
+      goto trunc;"
CVE-2017-13048/RSVP: fix decoding of Fast Reroute objects.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().," 			ND_PRINT((ndo, ""(refresh: %u)"",
 				EXTRACT_16BITS(&bp[i+2]) << 2));"
Add more bounds checks.,+        ND_TCHECK(*mh);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-            pptr += BGP_VPN_RD_LEN;
CVE-2017-12993/Juniper: Add more bounds checks.,+    ND_TCHECK(p[0]);
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check and could over-read the input buffer, put it right.","+        if (tlv_len < 6) {
+            return hexdump;
+        }"
CVE-2017-12900/Properly terminate all struct tok arrays.,"+    { 0,  NULL},"
(for 4.9.3) CVE-2018-14462/ICMP: Add a missing bounds check in icmp_print().,+				ND_TCHECK_16BITS(&dp->icmp_cksum);
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+            if (!ext_dp->icmp_length &&
+                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {"
"In ldp_tlv_print(), the FT Session TLV length must be 12, not 8 (RFC3479)",+	TLV_TCHECK(12);
CVE-2017-12898/NFS: Fix bounds checking.,+				ND_TCHECK(dp[4]);
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		    i -= sizeof(*ni), ++ni) {"
CVE-2017-13021/ICMP6: Add a missing bounds check.,+			ND_TCHECK(dp->icmp6_data16[1]);
Add two missing bounds checks,"+	if (strcmp((const char *)(data1 + 2), MAILSLOT_BROWSE_STR) == 0) {"
add DHCPv4-Data bounds checks,"+        if (i + 2 > length)
+            return -1;"
This fixes a buffer over-read discovered by Kamil Frankowicz.," 		if (length < sizeof(struct aodv_hello))
 			goto trunc;"
CVE-2017-13044/HNCP: add DHCPv4-Data bounds checks.,"+        if (i + 2 + optlen > length)
+            return -1;"
Add two missing bounds checks,"+	ND_TCHECK2(*(data1 + 2), strlen(PIPE_LANMAN_STR) + 1);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.",=B105
"While we're at it, print a truncation error if the packets are truncated, rather than just, in effect, ignoring the result of the routines that print particular packet types.","+		ND_PRINT((ndo, ""%s"", tstr));"
"Don't pass the remaining caplen - that's too hard to get right, and we were getting it wrong in at least one case;",-	if (caplen <= 1) {
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
This fixes a buffer over-read discovered by Bhargava Shastry., 				uint16_t icmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);
CVE-2017-13035/Properly handle IS-IS IDs shorter than a system ID (MAC address).,+    for (i = 1; i <= sysid_len; i++) {
This fixes a buffer over-read,"-				ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(bp)));"
This fixes a buffer over-read,         status_byte=*(tptr++);
"rt6_print(), ah_print(), and esp_print() return -1 if they run up against the end of the packet while dissecting; if that happens, stop dissecting, don't try to fetch the next header value, because 1) *it* might be past the end of the packet and 2) we won't be using it in any case, as we'll be exiting the loop.","+			if (advance < 0)
+				return;"
add checks to make sure the subTLV fits within the TLV.,"+    if (len < stlv_len)
+      goto trunc;"
Check for print routines returning -1 when running past the end.,"+                       in_cksum(vec, 1) ? ""in"" : """",
+                       hlen));"
"print_prefix() has a buffer and does not initialize it. It may call decode_prefix6(), which also does not initialize the buffer on invalid input. When that happens, make sure to return from print_prefix() before trying to print the [still uninitialized] buffer.","+        if (plenbytes < 0)
+            return plenbytes;"
CVE-2017-13048/RSVP: fix decoding of Fast Reroute objects.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
CVE-2017-13690/IKEv2: Fix some bounds checks.,-	ND_TCHECK(*ext);
The IKEv1 parser in tcpdump before 4.9.3 has a buffer over-read in print-isakmp.c:ikev1_n_print().,+			ND_TCHECK_32BITS(cp);
Add a missing bounds check.,+		ND_TCHECK(*p);
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,"             ND_PRINT((ndo, ""\n\t     Cable-Range: %u-%u, nexthop: "",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_int->cable_start),"
Add bounds checks to ip_printroute().,"+			if (ip_printroute(ndo, cp, option_len) == -1)
+				goto trunc;"
add a missing length check,"+	        ND_TCHECK2(*tptr, alen);"
"decode_multicast_vpn() didn't implement the Source AS field of that structure properly, adjust the offsets to put it right.",-            pptr += BGP_VPN_RD_LEN;
Use ND_TTEST() for the bounds checks in isoclns_print().,+	if (!ND_TTEST(*p)) {
CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+			nhdr.len = length;
(for 4.9.3) SMB: Add two missing bounds checks,"+	if (strcmp((const char *)(data1 + 2), MAILSLOT_BROWSE_STR) == 0) {"
CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_RESTART).,                            EXTRACT_16BITS(opt+i+2)&0xfff));
add DHCPv6-Data bounds checks,"+        if (i + 4 > length)
+            return -1;"
"The Zephyr parser in tcpdump before 4.9.2 has a buffer over-read in print-zephyr.c, several functions.","-    if (*pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
This fixes a buffer over-read,"-   for (i=0; *data && i < length ; i++, data++)"
Add missing checks to dhcpv6_print().,"+        if (i + 4 > length)
+            return -1;"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-        if (tlen < oid_len) {
"Check for running out of packet data before checking for running out of captured data, and distinguish between running out of packet data (which might just mean ""no more strings"") and running out of captured data (which means ""truncated"").","+	if (*len == 0) {
+	    return NULL;
+	}"
Clean up bounds checking.,"-	if (ndo->ndo_snapend < dat)
-		return;"
add some bounds checks,"+            if (vqp_obj_len != 4)
+                goto trunc;"
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" attrs=(""));"
This fixes a buffer over-read,"-				ND_PRINT((ndo, ""v%d"", *bp));"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		for (ni = rp->rip6_nets; i >= sizeof(*ni);
"rt6_print(), ah_print(), and esp_print() return -1 if they run up against the end of the packet while dissecting; if that happens, stop dissecting, don't try to fetch the next header value, because 1) *it* might be past the end of the packet and 2) we won't be using it in any case, as we'll be exiting the loop.","+			if (advance < 0)
+				return;"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,+                vec[0].len = hlen;
"rt6_print(), ah_print(), and esp_print() return -1 if they run up against the end of the packet while dissecting; if that happens, stop dissecting, don't try to fetch the next header value, because 1) *it* might be past the end of the packet and 2) we won't be using it in any case, as we'll be exiting the loop.","+			if (advance < 0)
+				return;"
CVE-2017-13046/BGP: fix an existing bounds check for PMSI Tunnel.,"+                ND_TCHECK2(tptr[0], 5);"
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().," 		ip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));"
(for 4.9.3) LMP: Add some missing bounds checks,+	    ND_TCHECK_32BITS(obj_tptr + offset + 4);
CVE-2017-13042/HNCP: add DHCPv6-Data bounds checks.,"+        if (i + 4 + optlen > length)
+            return -1;"
"It also fetched the varying number of octets of the route target field from 4 octets lower than the correct offset, put it right.","-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.",             for (te_class = 0; te_class < (subl-1)/4; te_class++) {
"An IPv6 address plus subnet mask is 32 bytes, not 20 bytes.","-			if (len < 20)
-				ND_PRINT((ndo,"" len=%d [bad: < 20]"", len));"
(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
"The loop can be executed more than once (that's kinda the whole point of a loop), so the check has to be made each time through the loop, not just once before the loop is executed.","+		    ND_TCHECK2(tptr[0], 3);"
CVE-2017-12993/Juniper: Add more bounds checks.,"+            ND_TCHECK2(p[0], 2);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 		opt_type = *bp++;
CVE-2017-12898/NFS: Fix bounds checking.,-				ND_TCHECK(dp[2]);
This fixes an infinite loop," 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);"
This fixes a buffer over-read discovered by Kamil Frankowicz., 	int mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,"                 ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                        tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                        *(tptr + 5)));"
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",     *endp = bp;
CVE-2017-12994/BGP: Move a test inside a loop.,"+		    ND_TCHECK2(tptr[0], 3);"
"Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst (if the request had extra stuff at the end, so that the variable is non-zero).",			plen+= strlen(d->name);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 		    ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));"
Add length checks.,+                ND_TCHECK_16BITS(p);
This fixes a buffer over-read,"                    tok2str(juniper_protocol_values,""Unknown"",gh->proto),"
The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().,"+   for (i=0; i < length && *data; i++, data++)
        ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                    ND_PRINT((ndo, ""\n\t\tAFI %s (%u), SAFI %s (%u)"",
                           tok2str(af_values, ""Unknown"",
                                      EXTRACT_16BITS(opt+i+2)),"
Add bounds checks when printing time stamp options.,+	ND_TCHECK(cp[2]);
CVE-2017-13028/BOOTP: Add a bounds check before fetching data.,+	ND_TCHECK(bp->bp_flags);
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+				ND_PRINT((ndo,"")""));"
has a buffer over-read,                 opt = (const struct rpl_dio_genoption *)(((const char *)opt) + optlen);
"If it returns a negative number, it hasn't necessarily filled in buf, so just return immediately; this is similar to the IPv4 code path, wherein we just return a negative number, and print nothing, on an error.","         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));"
The PGM parser in tcpdump before 4.9.2 has a buffer over-read in print-pgm.c:pgm_print()., 		opt_type = *bp++;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levom??ki.,-				if (chars_processed >= data_size) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-                ND_TCHECK2(tptr[0], 5);"
"While we're at it, print a truncation error if the packets are truncated, rather than just, in effect, ignoring the result of the routines that print particular packet types.","+		ND_PRINT((ndo, ""%s"", tstr));"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+            if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN)
+              goto trunc;"
CVE-2017-13004/Juniper: Add a bounds check.,+            ND_TCHECK_16BITS(p+l2info->cookie_len);
This fixes a buffer over-read,-	uint8_t  ip6r0_reserved;
Do some additional length checks while we're at it.,"+		    ND_TCHECK2(tptr[3], length);"
"Add bounds checks,","         ND_PRINT((ndo, ""\n\t        RES: %d V: %d A: %d D: %d"",
                         (*(tptr) >> 5), (((*tptr)>> 4) & 0x01),"
CVE-2017-13015/EAP: Add more bounds checks.,+                ND_TCHECK_8BITS(tptr + 5);
rpcapd/daemon.c in libpcap before 1.9.1 allows attackers to cause a denial of service (NULL pointer dereference and daemon crash) if a crypt() call fails.,"+	crypt_password = crypt(password, user_password);"
"Update to reflect the actual IPv6 RFC. In RFC 1883, the Type 0 routing header had a 1-byte reserved field and a 3-byte strict/loose bit map; in RFC 2460, that changed to a 4-byte reserved field.",+	uint32_t ip6r0_reserved;
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+			ND_PRINT((ndo,"" attrs=(""));"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"                 if (in_cksum(vec, 1)) {"
This fixes a buffer over-read,             l2info->proto = EXTRACT_16BITS(p);
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.",+	ND_TCHECK(*k);
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_MCID_MIN_LEN);"
CVE-2017-13005/NFS: Add two bounds checks before fetching data., 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
This fixes a buffer over-read,-	TLV_TCHECK(8);
Add two bounds checks before fetching data, 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levom??ki.,-					return (NULL);
Add missing checks to make this safe.,"+                                if (tlen == BGP_VPN_RD_LEN + 4 + sizeof(struct in_addr)
+                                    && EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().,"-			memcpy(tim.bitmap, p + offset + 3, tim.length - 3);"
The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_id()., 	pos += strlen(pos);
The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().,         	i=i+3;
The ISO CLNS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isoclns_print().,-	if (caplen <= 1) {
The RESP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-resp.c:resp_get_length().,-    if (*bp != '\n')
CVE-2017-13053/BGP: fix VPN route target bounds checks.,"-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
This fixes a buffer over-read, 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().,"-	else if (l_strnstart(""ANS "", 4, (const char *)bp, length))"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+    if (len < stlv_len)
+      goto trunc;"
CVE-2017-13015/EAP: Add more bounds checks.,+            ND_TCHECK_8BITS(tptr+4);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options"," 			else
+				ND_PRINT((ndo, "" [optlen != 4 or 6]""));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-                ND_TCHECK2(*tptr, 4);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-        len = len - sizeof(struct isis_subtlv_spb_mcid);
don't print the address as an IPv4 address.,"+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
Add bounds checks to ip_printroute().,+	ND_TCHECK(cp[2]);
"It also fetched the varying number of octets of the route target field from 4 octets lower than the correct offset, put it right.","-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
has a buffer over-read,+	len = dp->ip6r_len;
This fixes an infinite loop.,-    uint8_t i;
fix decoding of MVPN route types 6 and 7 RFC 6514 Section 4.6 defines the structure for Shared Tree Join (6) and Source Tree Join (7) multicast VPN route types.,"+            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-	i -= (sizeof(struct rip6) - sizeof(struct netinfo6));
In aoev1_reserve_print() check bounds before trying to print an Ethernet address.,"+		ND_TCHECK_LEN(cp, MAC_ADDR_LEN);"
Add a bounds check in name_len().,"+	ND_TCHECK2(*s, 1);"
CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data,+			ND_TCHECK_16BITS(&bp[i+2]);
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them., 	ND_TCHECK(dp->ip6r_segleft);
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them., 	ND_TCHECK(dp->ip6r_segleft);
"An IPv6 address plus subnet mask is 32 bytes, not 20 bytes.","+			if (len < 32)
+				ND_PRINT((ndo,"" len=%d [bad: < 32]"", len));"
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.","         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "",
                    EXTRACT_32BITS(&mh->service_id),"
(for 4.9.3) CVE-2018-14466/Rx: fix an over-read bug,-		    rxent->serviceId == EXTRACT_32BITS(&rxh->serviceId) &&
add DHCPv6-Data bounds checks,"+        if (i + 4 + optlen > length)
+            return -1;"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:nfs_printfh().,-		temp[sizeof(temp) - 1] = '\0';
This fixes a buffer over-read discovered by Yannick Formaggio.,"-			hdrlen += printer(ndo, h, p);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 	pos += strlen(pos);
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" status=(""));"
CVE-2017-13015/EAP: Add more bounds checks.,+                    ND_TCHECK_32BITS(tptr + 6);
The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print().,"                        isonsap_string(ndo, tptr, alen)));"
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check and could over-read the input buffer, put it right.","+        if (tlv_len < 6) {
+            return hexdump;
+        }"
Don't use an 8-bit loop counter.,-    uint8_t i;
"Check for running out of packet data before checking for running out of captured data, and distinguish between running out of packet data (which might just mean ""no more strings"") and running out of captured data (which means ""truncated"").",+	if (!ND_TTEST(**pptr)) {
Add a bounds check before fetching data,+			ND_TCHECK_16BITS(&bp[i+2]);
Improve bounds and length checks.,"+	ND_TCHECK2(*p, CHDLC_HDRLEN);"
CVE-2017-13005/NFS: Add two bounds checks before fetching data.,"+	if (!ND_TTEST(rp->rm_call.cb_vers))
+		return (0);"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		if (trunc)
-			ND_PRINT((ndo, ""[|ripng]""));"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-            ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN);"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
CVE-2017-13053/BGP: fix VPN route target bounds checks.,+	ND_TCHECK_32BITS(pptr + 1);
has a buffer over-read,-	len = dp->ip6r_len;
print_prefix() has a buffer and does not initialize it.,"+        if (plenbytes < 0)
+            return plenbytes;"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+				ND_PRINT((ndo, "" (elapsed time %u)"", EXTRACT_16BITS(option + 6)));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",             pptr += opli;
The BGP parser in tcpdump before 4.9.3 has a buffer over-read in print-bgp.c:bgp_capabilities_print() (BGP_CAPCODE_RESTART).,"                            ((opt[i+2])&0x80) ? ""R"" : ""none"","
CVE-2017-12901/EIGRP: Do more length checks.,+            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_sw_version)) {
This fixes a buffer over-read discovered by Yannick Formaggio.,"-			hdrlen += printer(ndo, h, p);"
In aodv_extension() do a bounds check on the extension header before we look at it.,+	ND_TCHECK(*ep);
This fixes a buffer over-read,"-					ND_PRINT((ndo, "", interval ""));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"")""));"
Properly check for buffer overflow in bittok2str_internal().,+                    space_left -= string_size;
"Also, make the buffer bigger.",+                    bufp += string_size;
Don't fetch the length field from the header until after we've checked for the existence of a field at or after that field., 	ND_TCHECK(dp->ip6r_segleft);
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,"-                ND_TCHECK2(tptr[0], 5);"
The command-line argument parser in tcpdump before 4.9.3 has a buffer overflow in tcpdump.c:get_next_file().,"-	if (ptr[strlen(ptr) - 1] == '\n')
-		ptr[strlen(ptr) - 1] = '\0';"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-	if (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))
-		return;"
Add more bounds checks.,+    ND_TCHECK(p[0]);
CVE-2017-12988/TELNET: Add a missing bounds check.,+		ND_TCHECK(*p);
"When bgp_attr_print() tried to decode the variable-length nexthop value for the NSAP VPN case, it did not check that the declared length is good to interpret the value as a mapped IPv4 or IPv6 address.",-                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)
This fixes a buffer over-read discovered by Kamil Frankowicz.,-				ND_TCHECK(dp[2]);
CVE-2017-13047/ES-IS: put an existing bounds check right.,-                    ND_TCHECK(*pptr);
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,"-	ND_TCHECK2(dp[0], 0);"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"")""));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
(for 4.9.3) LMP: Add some missing bounds checks,+	    ND_TCHECK_32BITS(obj_tptr + offset + 8);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
 				EXTRACT_16BITS(&bp[i+2]),
 				EXTRACT_16BITS(&bp[i+4])));"
The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().,-            int name_entries_valid = 0;
"In aoev1_reserve_print() check bounds, before trying to print an Ethernet address."," 		ND_PRINT(""\n\tEthernet Address %u: %s"", i, etheraddr_string(ndo, cp));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","         snprintf(pos, sizeof(id) - (pos - id), ""%02x"", *cp++);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,-        len = len - sizeof(struct isis_subtlv_spb_mcid);
This fixes a buffer over-read,-		for (ni = rp->rip6_nets; i >= sizeof(*ni);
CVE-2017-12993/Juniper: Add more bounds checks.,"+        ND_TCHECK2(p[0], 3);"
Do bounds checking as we access items.,"+		for (ni = rp->rip6_nets; length_left >= sizeof(*ni);
+		    length_left -= sizeof(*ni), ++ni) {
+			ND_TCHECK(*ni);"
"The White Board protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-wb.c:wb_prep(), several functions.",-	if (len < sizeof(*prep)) {
This fixes a buffer over-read discovered by Yannick Formaggio., 	n = EXTRACT_32BITS(&prep->pp_n);
"In ldp_tlv_print(), the FT Session TLV length must be 12, not 8 (RFC3479)",-	TLV_TCHECK(8);
The IKEv1 parser in tcpdump before 4.9.3 has a buffer over-read in print-isakmp.c:ikev1_n_print().," 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));"
"Move a return to make the code a bit cleaner (i.e., make it more obvious that if we don't have enough of the PGM header, we just print the source and destination IP addresses, mark it as incomplete PGM, and don't try to look at the PGM header).",-			return;
The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().,"-	else if (l_strnstart(""SEQ "", 4, (const char *)bp, length))"
Pass a properly updated struct pcap_pkthdr to the sub-dissector.,"+			hdrlen += printer(ndo, &nhdr, p);"
"When bgp_attr_print() tried to decode the variable-length nexthop value for the NSAP VPN case, it did not check that the declared length is good to interpret the value as a mapped IPv4 or IPv6 address.","+                                if (tlen == BGP_VPN_RD_LEN + 4 + sizeof(struct in_addr)
+                                    && EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)"
"While we're at it, clean up some other bounds checks, so we check that we have a complete IPv4 message header if it's IPv4 and a complete IPv6 message header if it's IPv6.","-        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
"Add bounds checks,","+            if (stlv_len < ISIS_SUBTLV_SPB_INSTANCE_VLAN_TUPLE_LEN)
+              goto trunc;"
The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv4_print().,         optlen = (uint8_t)tlv[1];
CVE-2017-12901/EIGRP: Do more length checks.,+            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_ip_ext)) {
CVE-2017-13053/BGP: fix VPN route target bounds checks.,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_multicast_vpn().,-            pptr += BGP_VPN_RD_LEN;
This fixes a buffer over-read,"-    if (*len <= 0 || !pptr || !*pptr)
-	return NULL;"
"clean up some other bounds checks,","-        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
"do a common check to make sure we captured the entire subTLV,","+    ND_TCHECK2(*(tptr), stlv_len);"
Add two missing bounds checks,"+	ND_TCHECK2(*(data1 + 2), strlen(MAILSLOT_BROWSE_STR) + 1);"
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",     *endp = bp;
CVE-2017-13005/NFS: Add two bounds checks before fetching data.,"+	if (!ND_TTEST(rp->rm_call.cb_vers))
+		return (0);"
"Also, add some infinite-pointer-loop captures.",+				if (offset >= max_offset) {
Do bounds checking.,+    if (!ND_TTEST_16BITS(p)) {
This fixes a buffer over-read discovered by Bhargava Shastry.,+			ND_TCHECK_32BITS(cp);
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.","+            if (subl == 0)
+                break;"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+                       in_cksum(vec, 1) ? ""in"" : """",
+                       hlen));"
In mfr_print() check this before trying to read those 4 bytes.,"                 ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));"
The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,                     af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;
The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().,-	uint8_t  ip6r0_reserved;
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().,+                vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
CVE-2017-13045/VQP: add some bounds checks.,"+            if (vqp_obj_len != ETHER_ADDR_LEN)
+                goto trunc;"
In rx_cache_insert() and rx_cache_find() properly read the serviceId field of the rx_header structure as a 16-bit integer.,+		    rxent->serviceId == EXTRACT_16BITS(&rxh->serviceId) &&
This fixes a buffer over-read,"-	i = min(length, amt);"
The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().,            if (length < 3)
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,-				if (*(bp+1) != 0) {
Check for print routines returning -1 when running past the end.,"+            if (!ext_dp->icmp_length &&
+                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {"
This fixes a buffer over-read,"-    if (*pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"                 if (in_cksum(vec, 1)) {"
Reverse the test in a for loop to test the length before testing whether we have a null byte.,"+   for (i=0; i < length && *data; i++, data++)
        ND_PRINT((ndo, ""%c"", (*data < 32 || *data > 126) ? '.' : *data));"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+                       in_cksum(vec, 1) ? ""in"" : """",
+                       hlen));"
This fixes a buffer over-read,            if (*data <= 0x1F)
CVE-2017-13016/ES-IS: Fix printing of addresses in RD PDUs.,"-		if (netal == 0)
-			ND_PRINT((ndo, ""\n\t  %s"", etheraddr_string(ndo, snpa)));"
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them.,-	len = dp->ip6r_len;
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,"             ND_PRINT((ndo, ""\n\t    holdtime: %us, k1 %u, k2 %u, k3 %u, k4 %u, k5 %u"",
                    EXTRACT_16BITS(tlv_ptr.eigrp_tlv_general_parm->holdtime),"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.",-        len = len - sizeof(struct isis_subtlv_spb_mcid);
(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely.,+	len = strlen (ptr);
The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().,         vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);
"The ARP parser in tcpdump before 4.9.2 has a buffer over-read in print-arp.c, several functions.","-	if (!ND_TTEST2(*ar_tpa(ap), PROTO_LEN(ap))) {"
"Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst (if the request had extra stuff at the end, so that the variable is non-zero).",-		plen+= sizeof(struct rpcap_findalldevs_if);
(for 4.9.3) CVE-2018-14467/BGP: Fix BGP_CAPCODE_MP.,+                    ND_TCHECK_8BITS(opt + i + 5);
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (ATMTPROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong tplen>""));"
CVE-2017-13005/NFS: Add two bounds checks before fetching data., 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
(for 4.9.3) CVE-2018-14879/fix -V to fail invalid input safely get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \\0.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions."," 				cp = ikev1_attrmap_print(ndo, cp,
 					(ep < ep2) ? ep : ep2, map, nmap);"
This fixes a buffer over-read,-		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
"Also, put the buffer on the stack; no reason to make it static.",+		char temp[NFSX_V3FHMAX+1];
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
This fixes a buffer over-read,     tlen=len-sizeof(struct eigrp_common_header);
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"")""));"
Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst,-			plen+= strlen(d->description);
CVE-2017-12987/IEEE 802.11: Fix processing of TIM IE.,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
"In ldp_tlv_print(), the FT Session TLV length must be 12, not 8 (RFC3479).",+	TLV_TCHECK(12);
Prevent a possible buffer overread in chdlc_print() and replace the custom check in chdlc_if_print() with a standard check in chdlc_print() so that the latter certainly does not over-read even when reached via juniper_chdlc_print().,"                 if (*(p+1) == 0x81 ||
                     *(p+1) == 0x82 ||
                     *(p+1) == 0x83)"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;","-			hdrlen += printer(ndo, h, p);"
Add some missing bounds checks.,+	ND_TCHECK(*ep);
"In isis_print_is_reach_subtlv() one of the case blocks did not check that the sub-TLV ""V"" is actually present and could over-read the input buffer.",                 bw.i = EXTRACT_32BITS(tptr);
"Add bounds checks,","+        if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
+          goto trunc;"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.",           tptr = tptr + 2;
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,     tlen=len-sizeof(struct eigrp_common_header);
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
This fixes a buffer over-read,"-					unsigned_relts_print(ndo, *(bp+1));"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+				ND_PRINT((ndo, "" (elapsed time %u)"", EXTRACT_32BITS(option + 6)));"
Fix TIM bitmap copy to copy from p + offset.,"+			memcpy(tim.bitmap, p + offset, tim.length - 3);"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
This fixes a buffer over-read," 		ND_PRINT((ndo, ""\n\t      Area address (length: %u): %s"","
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""NUL "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP NUL""));"
CVE-2017-12900/Properly terminate all struct tok arrays.,"+    { 0, NULL},"
Check for print routines returning -1 when running past the end.,"                 if (in_cksum(vec, 1)) {"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,"                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio,"
Improve bounds and length checks.,+                ND_TCHECK_16BITS(p);
Enforce a limit on how many times bgp_attr_print() can recurse.,"+			if (!bgp_attr_print(ndo, atype, p, alen, 0))
 				goto trunc;"
(for 4.9.3) CVE-2018-14881/BGP: Fix BGP_CAPCODE_RESTART.,+                    ND_TCHECK_16BITS(opt + i + 2);
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;","+			hdrlen += printer(ndo, &nhdr, p);"
The LLDP parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-lldp.c:lldp_private_8021_print().,-    uint8_t i;
"It can fail, so make sure it doesn't before comparing its result with the password.",+		return -1;
This fixes a buffer over-read,-	uint8_t  ip6r0_slmap[3];
This fixes a buffer over-read,"-		if (j == 1
-		    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6
-		    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {
-			ND_PRINT((ndo, "" ripng-req dump""));
-			break;"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (ATMTPROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong tplen>""));"
(for 4.9.3) CVE-2018-14466/Rx: fix an over-read bug.,-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
"If we're skipping over padding before the *real* flags, check whether the real flags are in the captured data before fetching it.",+	    ND_TCHECK(rhp->rh_short.sh_flags);
CVE-2017-13031/Check for the presence of the entire IPv6 fragment header.,-	ND_TCHECK(dp->ip6f_offlg);
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \\0.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
only print it as a MAC address if it's 6 bytes long.,"+		if (snpal == 6)
+			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
+			       snpal,
+			       etheraddr_string(ndo, snpa)));"
The BEEP parser in tcpdump before 4.9.2 has a buffer over-read in print-beep.c:l_strnstart().,"-	else if (l_strnstart(""RPY "", 4, (const char *)bp, length))"
This fixes a buffer overflow,+                    space_left -= string_size;
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""ANS "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP ANS""));"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+				ND_PRINT((ndo,"")""));"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options."," 			else
+				ND_PRINT((ndo, "" [optlen != 4 or 6]""));"
CVE-2017-12992/RIPng: Clean up bounds checking.,"-		if (j * sizeof(*ni) != length - 4)
-			ND_PRINT((ndo, "" ripng-req %d[%u]:"", j, length));"
This fixes a buffer over-read,"-		    i -= sizeof(*ni), ++ni) {"
CVE-2017-13044/HNCP: add DHCPv4-Data bounds checks.,"+        if (i + 2 > length)
+            return -1;"
This fixes a buffer over-read,"-	if (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))
-		return;"
The Rx protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-rx.c:ubik_print()., 			temp = EXTRACT_32BITS(bp);
CVE-2017-13020/VTP: Add some missing bounds checks.,+	ND_TCHECK_32BITS(tptr);
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","-		ND_PRINT((ndo,"")""));"
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.",         switch (ih->type) {
fix bounds checks for UNI.,"+                    if (total_subobj_len < 4)
+                        goto invalid;"
This fixes a buffer over-read discovered by Kamil Frankowicz.," 				ND_PRINT((ndo, "" %u (%u) bytes @ %"" PRIu64,
 						EXTRACT_32BITS(&dp[4]),
 						EXTRACT_32BITS(&dp[2]),
 						EXTRACT_64BITS(&dp[0])));"
rpcapd/daemon.c in libpcap before 1.9.1 allows attackers to cause a denial of service (NULL pointer dereference and daemon crash) if a crypt() call fails.,"-	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""ANS "", 4, (const char *)bp, length))"
"The loop can be executed more than once (that's kinda the whole point of a loop), so the check has to be made each time through the loop, not just once before the loop is executed.","-		ND_TCHECK2(tptr[0], 3);"
"Update to reflect the actual IPv6 RFC. In RFC 1883, the Type 0 routing header had a 1-byte reserved field and a 3-byte strict/loose bit map; in RFC 2460, that changed to a 4-byte reserved field.",+	uint8_t  ip6r0_segleft;
"We do bounds checks based on the TLV length, so if the TLV's length is too short, and we don't check for that, we could end up fetching data past the end of the TLV - including past the length of the captured data in the packet.",+				if (olen != 4) {
This fixes an infinite loop,-    if (*bp != '\r')
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:decode_rt_routing_info().,"-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 			ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));"
The EIGRP parser in tcpdump before 4.9.2 has a buffer over-read in print-eigrp.c:eigrp_print().,         tlv_tlen=eigrp_tlv_len-sizeof(struct eigrp_tlv_header);
This fixes a buffer over-read,-                                else if (EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)
CVE-2017-13041/ICMP6: Add more bounds checks.,+			ND_TCHECK(cp[0]);
CVE-2017-12901/EIGRP: Do more length checks.,+        if (eigrp_tlv_len < sizeof(struct eigrp_tlv_header)) {
In mfr_print() check this before trying to read those 4 bytes.,+                if (ie_len != 4) {
No need to test other fields.,-	ND_TCHECK(lshp->ls_seq);
This fixes a buffer over-read,"         if (EXTRACT_24BITS(p) == 0xfefe03 || 
             EXTRACT_24BITS(p) == 0xaaaa03) {"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;",+			nhdr.caplen = caplen;
Add a missing bounds check in vrrp_print().,+				ND_TCHECK_16BITS(&bp[6]);
This fixes a buffer over-read,+	TLV_TCHECK(12);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.","+			if (optlen == 6)
 				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
This fixes a buffer over-read, 	    switch (EXTRACT_16BITS(bp)) {
This fixes a buffer over-read discovered by Kamil Frankowicz.,"-		strncpy(temp, sfsname, NFSX_V3FHMAX);"
Add length checks.,"+	if (length < CHDLC_HDRLEN)
+		goto trunc;"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
(for 4.9.3) LMP: Add some missing bounds checks,+	    ND_TCHECK_8BITS(obj_tptr + offset + 2);
"The Zephyr parser in tcpdump before 4.9.2 has a buffer over-read in print-zephyr.c, several functions.","-    if (*len <= 0 || !pptr || !*pptr)
-	return NULL;"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+			ND_PRINT((ndo,"")""));"
Check for print routines returning -1 when running past the end.,"+            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {"
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""SEQ "", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP SEQ""));"
"Also, put the buffer on the stack; no reason to make it static.",-		static char temp[NFSX_V3FHMAX+1];
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,"+                if (subtype == EAP_TYPE_TTLS)
+                    ND_PRINT((ndo, "" TTLSv%u"",
+                           EAP_TTLS_VERSION(*(tptr + 5))));"
The DCCP parser in tcpdump before 4.9.3 has a buffer over-read in print-dccp.c:dccp_print_option()., 			if (optlen > 2) {
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",+    *endp = bp;
"CVE-2017-12894/In lookup_bytestring(), take the length of the byte string into account.","+	while (tp->bs_nxt)
+		if (nlen == tp->bs_nbytes &&
+		    tp->bs_addr0 == i &&
+		    tp->bs_addr1 == j &&
+		    tp->bs_addr2 == k &&
+		    memcmp((const char *)bs, (const char *)(tp->bs_bytes), nlen) == 0)
 			return tp;"
This fixes a buffer over-read,"                            ((opt[i+2])&0x80) ? ""R"" : ""none"","
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"-	else if (l_strnstart(""END"", 4, (const char *)bp, length))"
CVE-2017-13725/IPv6 R.H.: Check for the existence of all fields before fetching them.,-	len = dp->ip6r_len;
Add a missing bounds check,+		ND_TCHECK(*p);
CVE-2017-13007/PKTAP: Pass a properly updated struct pcap_pkthdr to the sub-dissector.,"+			hdrlen += printer(ndo, &nhdr, p);"
hncp_print_rec() validates each HNCP TLV to be within the declared as well as the on-the-wire packet space.,"+        if (i + 4 + optlen > length)
+            return -1;"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
The ICMPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp6.c:icmp6_nodeinfo_print()., 		ni6 = (const struct icmp6_nodeinfo *)dp;
CVE-2017-12992/RIPng: Clean up bounds checking.,-		if (j * sizeof(*ni) != length - 4)
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,-            vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 		ND_PRINT((ndo, "" %s"", ipaddr_string(ndo, &cp[len])));"
add some bounds checks,"+            if (vqp_obj_len != ETHER_ADDR_LEN)
+                goto trunc;"
don't print the address as an IPv4 address.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
"We've already advanced the pointer past the PAN ID, if present; it now points to the address, so don't add 2 to it.","-			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p + 2)));"
"Some of them are variable-length, with a field giving the total length, and therefore they can be shorter than 6 octets.","+    if (sysid_len > id_len)
+        sysid_len = id_len;"
CVE-2017-12901/EIGRP: Do more length checks.,+            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_at_int)) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         switch(vqp_obj_type) {
"rt6_print(), ah_print(), and esp_print() return -1 if they run up against the end of the packet while dissecting; if that happens, stop dissecting, don't try to fetch the next header value, because 1) *it* might be past the end of the packet and 2) we won't be using it in any case, as we'll be exiting the loop.","+			if (advance < 0)
+				return;"
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+			ND_PRINT((ndo,"" status=(""));"
CVE-2017-13045/VQP: add some bounds checks.,"+            if (vqp_obj_len != 4)
+                goto trunc;"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;",+			nhdr.caplen = caplen;
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" status=(""));"
CVE-2017-13053/BGP: fix VPN route target bounds checks.,"-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
add some bounds checks,"+        if (vqp_obj_len > tlen)
+            goto trunc;"
Add the missing check.,"+	if (len > 0 && ptr[len - 1] == '\n')
+		ptr[len - 1] = '\0';"
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,"                     ND_PRINT((ndo, "" len %u"", EXTRACT_32BITS(tptr + 6)));"
This fixes a buffer over-read,-	i -= (sizeof(struct rip6) - sizeof(struct netinfo6));
The LLDP parser in tcpdump before 4.9.2 has a buffer over-read in print-lldp.c:lldp_mgmt_addr_tlv_print().,-        if (tlen < oid_len) {
CVE-2017-13036/OSPFv3: Add a bounds check before fetching data.,+		ND_TCHECK_32BITS(&hellop->hello_options);
This fixes a buffer over-read, 	ui = EXTRACT_32BITS(tptr);
Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+			nhdr.len = length;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-            ND_TCHECK2(*msg_data, 4);"
The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print().," 			advance = esp_print(ndo, cp, len, (const u_char *)ip6, &enh, &padlen);"
The EAP parser in tcpdump before 4.9.2 has a buffer over-read in print-eap.c:eap_print().,         len = EXTRACT_16BITS(tptr+2);
Add more bounds checks.,+        ND_TCHECK(*ih);
Clean up bounds checking.,"-		if (trunc)
-			ND_PRINT((ndo, ""[|ripng]""));"
Pass a properly updated struct pcap_pkthdr to the sub-dissector.,+			nhdr.caplen = caplen;
(for 4.9.3) CVE-2018-14466/Rx: fix an over-read bug,-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
"Add bounds checks,","+    if (len < stlv_len)
+      goto trunc;"
has a buffer over-read,-	ND_TCHECK(lshp->ls_type);
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
Move a test inside a loop.,"+		    ND_TCHECK2(tptr[0], 3);"
CVE-2017-12992/RIPng: Clean up bounds checking.,"-	if (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))
-		return;"
ieee802_11_print() tried to access the Mesh Flags subfield of the Mesh Control field to find the size of the latter and increment the expected 802.11 header length before checking it is fully present in the input buffer.,+		if (caplen < hdrlen + 1) {
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().,-            vec[0].len = hlen;
The DCCP parser in tcpdump before 4.9.3 has a buffer over-read in print-dccp.c:dccp_print_option()., 			if (optlen == 6)
don't print the address as an IPv4 address.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
Check for the presence of the entire IPv6 fragment header.,-	ND_TCHECK(dp->ip6f_offlg);
The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,"-					ND_PRINT((ndo, ""<LOOP>""));"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
The DCCP parser in tcpdump before 4.9.3 has a buffer over-read in print-dccp.c:dccp_print_option().," 			else if (optlen == 4)
 				ND_PRINT((ndo, "" %u"", EXTRACT_16BITS(option + 2)));"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options.",+			switch (optlen) {
CVE-2017-12992/RIPng: Clean up bounds checking.,"-		if (trunc)
-			ND_PRINT((ndo, ""[|ripng]""));"
(for 4.9.3) CVE-2018-14469/ISAKMP: Add a missing bounds check.,+			ND_TCHECK_32BITS(cp);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         optlen = EXTRACT_16BITS(tlv + 2);
Fix printing of ISAKMPv1 Notification payload data.,"+				ND_PRINT((ndo,"")""));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-            int name_entries_valid = 0;
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-			if (len < 20)
-				ND_PRINT((ndo,"" len=%d [bad: < 20]"", len));"
The VTP parser in tcpdump before 4.9.2 has a buffer over-read in print-vtp.c:vtp_print().," 	ND_PRINT((ndo, "", Config Rev %x"", EXTRACT_32BITS(tptr)));"
"decode_multicast_vpn() didn't implement the Source AS field of that structure properly, adjust the offsets to put it right.",+            pptr += BGP_VPN_RD_LEN + 4;
This fixes a buffer over-read,"                        isonsap_string(ndo, tptr, alen)));"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.","-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_DIGEST_MIN_LEN);"
Ryan Ackroyd had independently identified this buffer over-read later by means of fuzzing and provided the packet capture file for the test., 			if (optlen == 6)
The LLDP parser in tcpdump before 4.9.2 has a buffer over-read in print-lldp.c:lldp_private_8023_print().,"         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
This fixes a buffer over-read,-	uint8_t  ip6r0_segleft;
CVE-2017-13688/OLSR: Do bounds checks before we fetch data.,"+            ND_TCHECK2(*msg_data, 4);"
CVE-2017-12901/EIGRP: Do more length checks.,+            if (tlv_tlen < sizeof(*tlv_ptr.eigrp_tlv_ip_int)) {
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+				ND_PRINT((ndo, "" (elapsed time %u)"", EXTRACT_16BITS(option + 6)));"
Several protocol parsers in tcpdump before 4.9.2 could cause a buffer overflow in util-print.c:bittok2str_internal().,+                    space_left -= string_size;
The LDP parser in tcpdump before 4.9.3 has a buffer over-read in print-ldp.c:ldp_tlv_print().,+	TLV_TCHECK(12);
CVE-2017-12902/Zephyr: Fix bounds checking.,+	if (!ND_TTEST(**pptr)) {
The BGP parser in tcpdump before 4.9.2 has a buffer over-read in print-bgp.c:bgp_attr_print().,                         for (i = 0; i < tptr[1] * as_size; i += as_size) {
Add two missing bounds checks,"+	if (strcmp((const char *)(data1 + 2), PIPE_LANMAN_STR) == 0) {"
NULL pointer dereference,"+	crypt_password = crypt(password, user_password);"
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.,-				if (chars_processed >= data_size) {
This fixes a buffer over-read,"-					ND_PRINT((ndo, "" ?0x%04x?"", EXTRACT_16BITS(bp+2)));"
The IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_extd_ip_reach().,"-        if (!ND_TTEST2(*tptr, 1))"
This addresses Include Security issue F12: [libpcap] Remote Packet Capture Daemon Null Pointer Dereference Denial of Service.,"-	if (strcmp(user_password, (char *) crypt(password, user_password)) != 0)"
CVE-2017-12901/EIGRP: Do more length checks.,+    if (len < sizeof(struct eigrp_common_header)) {
has buffer over-reads," 	smb_fdata(ndo, data1 + 2, f2, maxbuf - (paramlen + datalen), unicodestr);"
The RADIUS parser in tcpdump before 4.9.2 has a buffer over-read in print-radius.c:print_attr_string().,            if (*data <= 0x1F)
CVE-2017-13045/VQP: add some bounds checks.,"+        if (sizeof(struct vqp_obj_tlv_t) > tlen)
+            goto trunc;"
"After we advance the pointer by the length value in the buffer, make sure it points to something in the captured data.","+	ND_TCHECK2(*s, 1);"
Add more bounds checks.,"+            ND_TCHECK2(p[0], 2);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 	if (EXTRACT_16BITS(&bp->bp_secs))
 		ND_PRINT((ndo, "", secs %d"", EXTRACT_16BITS(&bp->bp_secs)));"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,"-		if (j * sizeof(*ni) != length - 4)
-			ND_PRINT((ndo, "" ripng-req %d[%u]:"", j, length));"
Using the same variable for the remaining request length and the reply length is confusing at best and can cause errors at worst,-				plen+= (sizeof(struct rpcap_sockaddr) * 4);
CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data.,+			ND_TCHECK_16BITS(&bp[i+2]);
CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data,+			ND_TCHECK_16BITS(&bp[i+2]);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 		ip_print(ndo, bp, EXTRACT_16BITS(&ip->ip_len));"
Add a missing bounds check in vrrp_print().,"+			if (in_cksum(vec, 1)) {"
CVE-2017-13689/IKEv1: Fix addr+subnet length check.,"+			if (len < 32)
+				ND_PRINT((ndo,"" len=%d [bad: < 32]"", len));"
The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,+                bw.i = EXTRACT_32BITS(obj_ptr.rsvp_obj_frr->bandwidth);
The IEEE 802.15.4 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_15_4.c:ieee802_15_4_if_print().,"-			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p + 2)));"
"When that happens, make sure to return from print_prefix() before trying to print the [still uninitialized] buffer.","+        if (plenbytes < 0)
+            return plenbytes;"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;",+			nhdr = *h;
CVE-2017-12900/Properly terminate all struct tok arrays.,"+    { 0, NULL}"
CVE-2017-13017/DHCPv6: Add a missing option length check., 		case DH6OPT_RECONF_MSG:
"Scan the list of netinfo6 entries based on the supplied packet length, without taking the captured length into account; let the aforementioned bounds checking handle that.","+		for (ni = rp->rip6_nets; length_left >= sizeof(*ni);
+		    length_left -= sizeof(*ni), ++ni) {
+			ND_TCHECK(*ni);"
The ICMP parser in tcpdump before 4.9.3 has a buffer over-read in print-icmp.c:icmp_print()., 				uint16_t icmp_sum = EXTRACT_16BITS(&dp->icmp_cksum);
CVE-2017-12990/Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" attrs=(""));"
The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().," 			ND_PRINT((ndo, ""(alt-CoA: %s)"", ip6addr_string(ndo, &bp[i+2])));"
add checks to make sure the subTLV fits within the TLV.,"+        if (stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN)
+          goto trunc;"
CVE-2017-13001/NFS: Don't copy more data than is in the file handle.,"+		if (stringlen > NFSX_V3FHMAX)
+			stringlen = NFSX_V3FHMAX;"
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-				unsigned_relts_print(ndo, EXTRACT_16BITS(bp));"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         vqp_obj_len = EXTRACT_16BITS(vqp_obj_tlv->obj_length);
The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,-				chars_processed++;
The LDP parser in tcpdump before 4.9.3 has a buffer over-read in print-ldp.c:ldp_tlv_print()., 	ui = EXTRACT_32BITS(tptr);
(for 4.9.3) CVE-2018-14463/VRRP: Add a missing bounds check in vrrp_print().,+				ND_TCHECK_16BITS(&bp[6]);
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (ATMTPROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong tplen>""));"
This fixes a buffer over-read discovered by Brian 'geeknik' Carpenter.,"     ND_PRINT((ndo, ""seq 0x%03x, Flags [%s], length %u"",
            (EXTRACT_16BITS(p))&0x0fff, 
            bittok2str(ppp_ml_flag_values, ""none"", *p & 0xc0),"
Add some missing bounds checks,+	ND_TCHECK(*ep);
CVE-2017-12900/Properly terminate all struct tok arrays.,"+    { 0, NULL }"
CVE-2017-13032/RADIUS: Check whether a byte exists before testing its value.,"+           if (length < 1)
+              goto trunc;"
In ikev1_n_print() check bounds before trying to fetch the replay detection status.,+			ND_TCHECK_32BITS(cp);
This fixes a stack exhaustion,"-                    if (!bgp_attr_print(ndo, atype, tptr, alen))"
The LDP parser in tcpdump before 4.9.3 has a buffer over-read in print-ldp.c:ldp_tlv_print().,-	TLV_TCHECK(8);
fix VPN route target bounds checks,+	ND_TCHECK_32BITS(pptr + 1);
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:xid_map_enter()., 	xmep->proc = EXTRACT_32BITS(&rp->rm_call.cb_proc);
Do bounds checking.,+    if (length < 2) {
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
Properly terminate all struct tok arrays.,"+    { 0, NULL }"
"Always print the SNPA, and flag it as such; only print it as a MAC address if it's 6 bytes long."," 		else
+			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
+			       snpal,
+			       linkaddr_string(ndo, snpa, LINKADDR_OTHER, snpal)));"
"This fixes a buffer overflow discovered by Bhargava Shastry, SecT/TU Berlin.",+                    space_left -= string_size;
The IPv6 routing header parser in tcpdump before 4.9.2 has a buffer over-read in print-rt6.c:rt6_print().,-	len = dp->ip6r_len;
(for 4.9.3) CVE-2018-14880/OSPFv3: Fix a bounds check.,+	ND_TCHECK(lshp->ls_length);
CVE-2017-13027/LLDP: Fix a bounds check.,"+        if (tlen < 1U + oid_len) {
             return 0;
         }"
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",+    *endp = bp;
Don't fetch the length field from the header until after we've checked for the existence of a field at or after that field.,+	len = dp->ip6r_len;
Fix bounds checking.,+	    ND_TCHECK(rhp->rh_short.sh_flags);
This fixes a buffer over-read discovered by Kamil Frankowicz., 	if(length == 1 && bp[0]==0xff) {
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                 ND_PRINT((ndo, "" subtype [%s] 0x%02x,"",
                        tok2str(eap_aka_subtype_values, ""unknown"", *(tptr+5)),
                        *(tptr + 5)));"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"")""));"
The DNS parser in tcpdump before 4.9.2 could enter an infinite loop due to a bug in print-domain.c:ns_print().,-					return (NULL);
Add two bounds checks before fetching data,"+	if (!ND_TTEST(rp->rm_call.cb_vers))
+		return (0);"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header; pass an updated header, just as we do for PPI.",+			nhdr.caplen = caplen;
"In lldp_private_8023_print() the case block for subtype 4 (Maximum Frame Size TLV, IEEE 802.3bc-2009 Section 79.3.4) did not include the length check and could over-read the input buffer, put it right.'","         ND_PRINT((ndo, ""\n\t    MTU size %u"", EXTRACT_16BITS(tptr + 4)));"
Identify the NET as such.,"+		if (netal != 0)
+			ND_PRINT((ndo, ""\n\t  NET (length: %u) %s"",
+			       netal,
+			       isonsap_string(ndo, neta, netal)));"
CVE-2017-12985/IPv6: Check for print routines returning -1 when running past the end.,"+            if (!ext_dp->icmp_length &&
+                ND_TTEST2(ext_dp->icmp_ext_version_res, plen - ICMP_EXTD_MINLEN)) {"
Add missing bounds check.,+			ND_TCHECK(tptr[1]);
This fixes a buffer over-read,"-		if (trunc)
-			ND_PRINT((ndo, ""[|ripng]""));"
"We do bounds checks based on the TLV length, so if the TLV's length is too short, and we don't check for that, we could end up fetching data past the end of the TLV - including past the length of the captured data in the packet.",+				if (olen != 4) {
This fixes a buffer over-read discovered by Bhargava Shastry.,"                 ND_PRINT((ndo, ""%s  CT: %u"",
                        ident,
                        EXTRACT_32BITS(obj_tptr) & 0x7));"
"While we're at it, print a truncation error if the packets are truncated, rather than just, in effect, ignoring the result of the routines that print particular packet types.","+		ND_PRINT((ndo, ""%s"", tstr));"
This fixes a buffer over-read,"         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
                    sh->svc_id,"
Add more bounds checks.,"+        ND_TCHECK2(p[0], 3);"
In ikev1_n_print() check bounds before trying to fetch the replay detection status.," 			ND_PRINT((ndo,""replay detection %sabled"",
 				  EXTRACT_32BITS(cp) ? ""en"" : ""dis""));"
"Don't pass the remaining caplen - that's too hard to get right, and we were getting it wrong in at least one case; just use ND_TTEST().",-	if (caplen <= 1) {
"After we advance the pointer by the length value in the buffer, make sure it points to something in the captured data.", 	s += (*s) + 1;
Enforce a limit on how many times bgp_attr_print() can recurse.,"+                    if (attr_set_level == 10)
+                        ND_PRINT((ndo, ""(too many nested levels, not recursing)""));"
Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","-	memcpy(&route_target, &pptr[1], (plen + 7) / 8);"
"Add bounds checks,","+    ND_TCHECK2(*(tptr), stlv_len);"
Add a bounds check and a comment to bgp_capabilities_print().,+                    ND_TCHECK_16BITS(opt + i + 2);
The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_is_reach_subtlv().,"-                ND_TCHECK2(*tptr, 4);"
CVE-2017-13010/BEEP: Do bounds checking when comparing strings.,"+	if (l_strnstart(ndo, ""MSG"", 4, (const char *)bp, length)) /* A REQuest */
 		ND_PRINT((ndo, "" BEEP MSG""));"
get_next_file() did not check the return value of strlen() and underflowed an array index if the line read by fgets() from the file started with \0.,+	len = strlen (ptr);
"If decode_prefix6() returns a negative number, don't print buf.","         plenbytes = decode_prefix6(ndo, prefix, max_length, buf, sizeof(buf));"
This fixes a buffer over-read discovered by Yannick Formaggio.," 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)
 			return;"
Add a missing bounds check in lmp_print_data_link_subobjs().,+	    ND_TCHECK_32BITS(obj_tptr + offset + 4);
In rx_cache_insert() and rx_cache_find() properly read the serviceId field of the rx_header structure as a 16-bit integer.,+	rxent->serviceId = EXTRACT_16BITS(&rxh->serviceId);
This fixes a buffer over-read,                            EXTRACT_16BITS(opt+i+2)&0xfff));
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-        ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
The IPv6 parser in tcpdump before 4.9.2 has a buffer over-read in print-ip6.c:ip6_print().," 			advance = rt6_print(ndo, cp, (const u_char *)ip6);"
(for 4.9.3) CVE-2018-14470/Babel: fix an existing length check.,"+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
The IPv6 mobility parser in tcpdump before 4.9.2 has a buffer over-read in print-mobility.c:mobility_opt_print().," 			ND_PRINT((ndo, ""(ni: ho=0x%04x co=0x%04x)"",
 				EXTRACT_16BITS(&bp[i+2]),
 				EXTRACT_16BITS(&bp[i+4])));"
CVE-2017-13054/LLDP: add a missing length check.,"+        if (tlv_len < 6) {
+            return hexdump;
+        }"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+				ND_PRINT((ndo, "" %u"", EXTRACT_32BITS(option + 2)));"
CVE-2017-13688/OLSR: Do bounds checks before we fetch data.,"+            ND_TCHECK2(*tptr, sizeof(struct olsr_msg4));"
In rsvp_obj_print() the case block for Class-Num 205 (FAST_REROUTE) from RFC 4090 Section 4.1 could over-read accessing the buffer contents before making the bounds check.,"                 if (obj_tlen < sizeof(struct rsvp_obj_frr_t))
                     return-1;"
This fixes a buffer over-read discovered by Kim Gwan Yeong., 			if (cp[0] == ep - cp - 1) {
CVE-2017-13051/RSVP: fix bounds checks for UNI.,"+                    if(subobj_len < 4 || subobj_len > total_subobj_len)
                         goto invalid;"
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().,-            vec[0].ptr = (const uint8_t *)(const void *)&ext_dp->icmp_ext_version_res;
The OLSR parser in tcpdump before 4.9.2 has a buffer over-read in print-olsr.c:olsr_print().,-            u_int name_entries = EXTRACT_16BITS(msg_data+2);
Add bounds checks when printing time stamp options.,"+		ND_TCHECK2(cp[len], hoplen);"
"When those functions tried to read 32 bits the extra 16 bits could be outside of the bounds checked in rx_print() for the rx_header structure, as serviceId is the last field in that structure.",-	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","-        ND_TCHECK2(*(tptr), ISIS_SUBTLV_SPB_DIGEST_MIN_LEN);"
CVE-2017-13687/CHDLC: Improve bounds and length checks.,"+                if (length < 2)
+                    goto trunc;"
CVE-2017-12895/ICMP: Check the availability of data before checksumming it.,"+            if (ND_TTEST2(ext_dp->icmp_ext_version_res, hlen)) {"
"The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.","         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u flags 0x%02x service-set-id 0x%04x iif %u: "",
                    sh->svc_id,"
This fixes a buffer over-read,-				if (*(bp+1) != 0) {
This fixes a buffer over-read,            if (length < 3)
Do bounds checking as we access items.,"+		for (ni = rp->rip6_nets; length_left >= sizeof(*ni);
+		    length_left -= sizeof(*ni), ++ni) {
+			ND_TCHECK(*ni);"
CVE-2017-13015/EAP: Add more bounds checks.,+                ND_TCHECK_8BITS(tptr + 5);
"The Zephyr parser in tcpdump before 4.9.2 has a buffer over-read in print-zephyr.c, several functions.","-    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
This fixes a buffer over-read,"-		        ND_TCHECK2(tptr[3], 8);"
CVE-2017-13016/ES-IS: Fix printing of addresses in RD PDUs.,"+		if (snpal == 6)
+			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
+			       snpal,
+			       etheraddr_string(ndo, snpa)));"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().," 			ND_PRINT((ndo, "" c %04x"", EXTRACT_32BITS(&dp[0])));"
This addresses Include Security issue F12: [libpcap] Remote Packet Capture Daemon Null Pointer Dereference Denial of Service.,"+	crypt_password = crypt(password, user_password);"
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.",         len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
fix an existing length check,"+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
"In aoev1_reserve_print() check bounds, before trying to print an Ethernet address.","+		ND_TCHECK_LEN(cp, MAC_ADDR_LEN);"
CVE-2017-13011/Properly check for buffer overflow in bittok2str_internal().,"+                    if (space_left <= 1)
+                        return (buf);"
"It can fail, so make sure it doesn't before comparing its result with the password.","+		pcap_snprintf(errbuf, PCAP_ERRBUF_SIZE, ""Authentication failed"");"
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options","+				ND_PRINT((ndo, "" [optlen != 6 or 8 or 10]""));"
"In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo), put it right.","+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
This fixes a buffer over-read,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
CVE-2017-13020/VTP: Add some missing bounds checks.,+	    ND_TCHECK_8BITS(tptr);
"decode_multicast_vpn() didn't implement the Source AS field of that structure properly, adjust the offsets to put it right.","+            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         optlen = (uint8_t)tlv[1];
The IP parser in tcpdump before 4.9.2 has a buffer over-read in print-ip.c:ip_printts().," 	if (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)
 		ND_PRINT((ndo, ""[bad ptr %u]"", cp[2]));"
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:xid_map_enter()., 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
This fixes a buffer over-read,"             ND_PRINT((ndo, ""\n\t    IOS version: %u.%u, EIGRP version %u.%u"",
                    tlv_ptr.eigrp_tlv_sw_version->ios_major,"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"")""));"
"Fix the bounds checking for the NFSv3 WRITE procedure to check whether the length of the opaque data being written is present in the captured data, not just whether the byte count is present in the captured data.",-				ND_TCHECK(dp[2]);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin."," 		ND_PRINT((ndo, ""%s%d@%s"", type, EXTRACT_32BITS(&cp[len+hoplen-4]),
 		       hoplen!=8 ? """" : ipaddr_string(ndo, &cp[len])));"
CVE-2017-12994/BGP: Move a test inside a loop.,"-		ND_TCHECK2(tptr[0], 3);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",           len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN;
Do some additional length checks while we're at it.,"+		        if (length < 8)
+		            goto trunc;"
don't print the address as an IPv4 address.,"+	if (pro != ETHERTYPE_IP && pro != ETHERTYPE_TRAIL)
+		ND_PRINT((ndo, ""<wrong proto type>""));"
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header;",+			nhdr.len = length;
CVE-2017-13024/IPv6 mobility: Add a bounds check before fetching data,+			ND_TCHECK_16BITS(&bp[i+4]);
CVE-2017-13015/EAP: Add more bounds checks.,+        ND_TCHECK_16BITS(tptr+2);
"Use a pointer of the correct type in ND_TCHECK(), or use ND_TCHECK2() and provide the correct length.",+	ND_TCHECK(*k);
The RSVP parser in tcpdump before 4.9.2 has a buffer over-read in print-rsvp.c:rsvp_obj_print().,"                 ND_PRINT((ndo, ""%s  Setup Priority: %u, Holding Priority: %u, Hop-limit: %u, Bandwidth: %.10g Mbps"",
                        ident,
                        (int)obj_ptr.rsvp_obj_frr->setup_prio,"
In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo),"+                if(len < 10)
                     ND_PRINT((ndo, ""/truncated""));"
CVE-2017-13047/ES-IS: put an existing bounds check right.,+                    ND_TCHECK(*tptr);
CVE-2017-13026/IS-IS: Clean up processing of subTLVs.,"-          ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN);"
Fix printing of ISAKMPv1 Notification payload data.,"+				ND_PRINT((ndo,"")""));"
The HNCP parser in tcpdump before 4.9.2 has a buffer over-read in print-hncp.c:dhcpv6_print().,         optlen = EXTRACT_16BITS(tlv + 2);
CVE-2017-13042/HNCP: add DHCPv6-Data bounds checks.,"+        if (i + 4 > length)
+            return -1;"
don't print the address as an IPv4 address.,=B105
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",+    *endp = bp;
The NFS parser in tcpdump before 4.9.2 has a buffer over-read in print-nfs.c:interp_reply().,-				ND_TCHECK(dp[2]);
CVE-2017-12993/Juniper: Add more bounds checks.,"+            ND_TCHECK2(p[0], 2);"
This fixes a buffer over-read,"-    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
-	return NULL;"
The VQP parser in tcpdump before 4.9.2 has a buffer over-read in print-vqp.c:vqp_print().,         switch(vqp_obj_type) {
This fixes an infinite loop discovered by Forcepoint's security researchers Otto Airamo & Antti Levomki.,"-					ND_PRINT((ndo, ""<LOOP>""));"
CVE-2017-13013/ARP: Fix printing of ARP protocol addresses.,"+	else if (ATMTPROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong tplen>""));"
Don't crash if crypt() fails.,+	if (crypt_password == NULL)
"The sub-dissector expects that the length and captured length will reflect the actual remaining data in the packet, not the raw amount including the PKTAP header; pass an updated header, just as we do for PPI.","+			hdrlen += printer(ndo, &nhdr, p);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",           tptr = tptr + 2;
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.",+        while (stlv_len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN)
This fixes an infinite loop, 			while (cp < ep && cp < ep2) {
CVE-2017-13005/NFS: Add two bounds checks before fetching data.,"+	if (!ND_TTEST(rp->rm_call.cb_proc))
+		return (0);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.", 			tp = (const u_char *)(dh6o + 1);
CVE-2017-12991/BGP: Add missing bounds check.,+			ND_TCHECK(tptr[1]);
CVE-2017-12902/Zephyr: Fix bounds checking.,"+	if (*len == 0) {
+	    return NULL;
+	}"
sf-pcapng.c in libpcap before 1.9.1 does not properly validate the PHB header length before allocating memory.,"+                              total_length,"
"Always print the SNPA, and flag it as such; only print it as a MAC address if it's 6 bytes long.","+		if (snpal == 6)
+			ND_PRINT((ndo, ""\n\t  SNPA (length: %u): %s"",
+			       snpal,
+			       etheraddr_string(ndo, snpa)));"
(for 4.9.3) SMB: Add two missing bounds checks,"+	ND_TCHECK2(*(data1 + 2), strlen(PIPE_LANMAN_STR) + 1);"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","             ND_PRINT((ndo, ""\n\t  Version %u, Entries %u%s"",
                    EXTRACT_16BITS(msg_data),
                    name_entries, (name_entries_valid == 0) ? "" (invalid)"" : """"));"
CVE-2017-13687/CHDLC: Improve bounds and length checks.,"+	if (length < CHDLC_HDRLEN)
+		goto trunc;"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",         len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN;
"The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c, several functions.","-          ND_TCHECK2(*tptr, ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN);"
"decode_rt_routing_info() didn't check bounds before fetching 4 octets of the origin AS field and could over-read the input buffer, put it right.","-	ND_TCHECK2(pptr[1], (plen + 7) / 8);"
Do bounds checking as we access items.,+	ND_TCHECK(rp->rip6_cmd);
CVE-2017-12992/RIPng: Clean up bounds checking.,"-	if (ndo->ndo_snapend < dat)
-		return;"
This fixes a buffer over-read,         tlv_tlen=eigrp_tlv_len-sizeof(struct eigrp_tlv_header);
CVE-2017-13045/VQP: add some bounds checks.,+        ND_TCHECK(*vqp_obj_tlv);
Ryan Ackroyd had independently identified this buffer over-read later by means of fuzzing and provided the packet capture file for the test.," 			else if (optlen == 4)
 				ND_PRINT((ndo, "" %u"", EXTRACT_16BITS(option + 2)));"
CVE-2017-13690/IKEv2: Fix some bounds checks.,-	ND_TCHECK(*ext);
The PIMv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-pim.c:pimv2_print().,"-				ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(bp)));"
CVE-2017-13687/CHDLC: Improve bounds and length checks.,+                ND_TCHECK_16BITS(p);
This fixes a buffer over-read,"             ND_PRINT((ndo, ""\n\t    Cable-range: %u-%u, Router-ID %u"",
                    EXTRACT_16BITS(&tlv_ptr.eigrp_tlv_at_cable_setup->cable_start),"
CVE-2017-12996/PIMv2: Make sure PIM TLVs have the right length.,+				if (olen != 2) {
Fix printing of ISAKMPv1 Notification payload data.,"+			ND_PRINT((ndo,"" attrs=(""));"
Do bounds checking when comparing strings.,"+	else if (l_strnstart(ndo, ""END"", 4, (const char *)bp, length))
 		ND_PRINT((ndo, "" BEEP END""));"
Fix some bounds checks.,+	ND_TCHECK(*idp);
Do more bounds checks.,"+	if (len < sizeof(*prep) || !ND_TTEST(*prep))
 		return (-1);"
"Check for running out of packet data before checking for running out of captured data, and distinguish between running out of packet data (which might just mean ""no more strings"") and running out of captured data (which means ""truncated"").","+	if (*len == 0) {
+	    return NULL;
+	}"
The RIPng parser in tcpdump before 4.9.2 has a buffer over-read in print-ripng.c:ripng_print().,-	amt = ndo->ndo_snapend - dat;
"The ISAKMP parser in tcpdump before 4.9.2 could enter an infinite loop due to bugs in print-isakmp.c, several functions.","+			ND_PRINT((ndo,"")""));"
In babel_print_v2() the non-verbose branch for an Update TLV compared the TLV Length against 1 instead of 10 (probably a typo),-                if(len < 1)
This fixes a buffer over-read, 	ft_flags = EXTRACT_16BITS(tptr);
This fixes a buffer over-read,-		trunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);
CVE-2017-13055/IS-IS: fix an Extended IS Reachability sub-TLV.,"+            if (subl == 0)
+                break;"
The OSPFv3 parser in tcpdump before 4.9.3 has a buffer over-read in print-ospf6.c:ospf6_print_lshdr().,-	ND_TCHECK(lshp->ls_seq);
"(for 4.9.3) CVE-2018-16229/DCCP: Fix printing ""Timestamp"" and ""Timestamp Echo"" options."," 			else
+				ND_PRINT((ndo, "" [optlen != 6]""));"
Several protocol parsers in tcpdump before 4.9.2 could cause a buffer overflow in util-print.c:bittok2str_internal().,+                    space_left -= string_size;
"Make sure that it always sends *endp before returning and that, for invalid lengths where we don't like a character in the length string, what it sets *endp to is past the character in question, so we don't run the risk of infinitely looping (or doing something else random) if a character in the length is invalid.",+    *endp = bp;
"The White Board protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-wb.c:wb_prep(), several functions."," 		if (wb_prep(ndo, (const struct pkt_prep *)(ph + 1), len) >= 0)
 			return;"
(for 4.9.3) SMB: Add two missing bounds checks,"+	ND_TCHECK2(*(data1 + 2), strlen(MAILSLOT_BROWSE_STR) + 1);"
CVE-2017-13045/VQP: add some bounds checks.,"+        if (vqp_obj_len > tlen)
+            goto trunc;"
The ISO ES-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:esis_print().,             pptr += opli;
CVE-2017-13034/PGM: Add a bounds check.,+	    ND_TCHECK_16BITS(bp);
This fixes a buffer over-read,         extracted_ethertype = EXTRACT_16BITS(p);
The ICMP parser in tcpdump before 4.9.2 has a buffer over-read in print-icmp.c:icmp_print().,+                vec[0].len = hlen;
Add a missing length check.,"+	        ND_TCHECK2(*tptr, alen);"
"While we're at it, fix a comment, and clean up printing of V1 Nonce, V2 Authentication payloads, and v2 Notice payloads.","+			ND_PRINT((ndo,"" status=(""));"
"Add bounds checks, do a common check to make sure we captured the entire subTLV, add checks to make sure the subTLV fits within the TLV.","+    if (len < stlv_len)
+      goto trunc;"
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.","                 ND_PRINT((ndo, ""0x%08x"", EXTRACT_32BITS(tptr)));"
Add two bounds checks before fetching data, 	xmep->vers = EXTRACT_32BITS(&rp->rm_call.cb_vers);
"This fixes a buffer overflow discovered by Bhargava Shastry, SecT/TU Berlin.","-                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
-                                     sepstr, lp->s);"
"While we're at it, print a truncation error if the packets are truncated, rather than just, in effect, ignoring the result of the routines that print particular packet types.","+		ND_PRINT((ndo, ""%s"", tstr));"
The IEEE 802.11 parser in tcpdump before 4.9.2 has a buffer over-read in print-802_11.c:parse_elements().,"-			memcpy(tim.bitmap, p + (tim.length - 3),
-			    (tim.length - 3));"
"If the protocol type isn't ETHERTYPE_IP or ETHERTYPE_TRAIL, or if the protocol address length isn't 4, don't print the address as an IPv4 address.","+	else if (PROTO_LEN(ap) != 4)
+		ND_PRINT((ndo, ""<wrong len>""));"
The DECnet parser in tcpdump before 4.9.2 has a buffer over-read in print-decnet.c:decnet_print()., 	    mflags = EXTRACT_LE_8BITS(rhp->rh_short.sh_flags);
CVE-2017-12897/ISO CLNS: Use ND_TTEST() for the bounds checks in isoclns_print().,+	if (!ND_TTEST(*p)) {
This fixes a buffer over-read,"-		    ND_TCHECK2(tptr[3], length - 3);"
The ISO IS-IS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isis_print_is_reach_subtlv().,                 bw.i = EXTRACT_32BITS(tptr);
"While we're at it, clean up some other bounds checks, so we check that we have a complete IPv4 message header if it's IPv4 and a complete IPv6 message header if it's IPv6.","-            ND_TCHECK2(*msg_data, 4);"
CVE-2017-13012/ICMP: Add a missing bounds check.,+		ND_TCHECK_16BITS(&ip->ip_len);
CVE-2017-13028/BOOTP: Add a bounds check before fetching data,+	ND_TCHECK(bp->bp_flags);
CVE-2017-12985/IPv6: Check for print routines returning -1 when running past the end.,"+                       in_cksum(vec, 1) ? ""in"" : """",
+                       hlen));"
The PGM parser in tcpdump before 4.9.2 has a buffer over-read in print-pgm.c:pgm_print()., 	    switch (EXTRACT_16BITS(bp)) {
This fixes a buffer over-read discovered by Henri Salo from Nixu Corporation., 			temp = EXTRACT_32BITS(bp);
"This fixes a buffer over-read discovered by Bhargava Shastry, SecT/TU Berlin.",-            u_int name_entries = EXTRACT_16BITS(msg_data+2);
This fixes a buffer over-read,"         if (ndo->ndo_eflag)
             ND_PRINT((ndo, ""service-id %u, iif %u, pkt-type %u: "",
                    EXTRACT_32BITS(&mh->service_id),"
The Cisco HDLC parser in tcpdump before 4.9.2 has a buffer over-read in print-chdlc.c:chdlc_print().,"-        return (chdlc_print(ndo, p,length));"
