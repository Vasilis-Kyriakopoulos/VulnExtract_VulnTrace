text,code
"The _bfd_slurp_extended_name_table function in bfd/archive.c in GNU binutils 2.24 and earlier allows remote attackers to cause a denial of service (invalid write, segmentation fault, and crash) via a crafted extended name table in an archive.","       bfd_ardata (abfd)->extended_names = (char *) bfd_zalloc (abfd, amt + 1);"
* vms-alpha.c (_bfd_vms_slurp_eihd): Make sure that there is enough data in the record before attempting to parse it.,"+         if (res == res_base)
+           return FALSE;"
"Your analysis of the bug was correct, although the correct thing to do was to jump to the error_ret label if the input buffer was too small.","+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
PR binutils/21665 bfd * opncls.c (get_build_id): Check that the section is beig enough to contain the whole note.,"+  if (size < sizeof (Elf_External_Note))
+    {
+      bfd_set_error (bfd_error_invalid_operation);
+      free (contents);
+      return NULL;
+    }"
Use to check for corrupt pair relocs.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
"The getvalue function in tekhex.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (stack-based buffer over-read and application crash) via a crafted tekhex file, as demonstrated by mishandling within the nm program.",-      int i;
Handle archives with corrupt extended name tables.,+         bfd_ardata (abfd)->extended_names_size = 0;
Use to check for corrupt pair relocs.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Handle EITR records in VMS Alpha binaries with overlarge command length parameters.,+      if (cmd_length < 4 || (ptr + cmd_length > maxptr + 4))
"GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.",-         if (data + ent - pltgot > data_end - addr_size)
PR binutils/22018 * elf32-i386.c (elf_i386_get_synthetic_symtab): Check for valid PLT section size.,"+      if (plt == NULL || plt->size == 0)
        continue;"
"The versados_mkobject function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not initialize a certain data structure, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+      tdata_type *tdata = bfd_zalloc (abfd, amt);"
PR 24829 * readelf.c (apply_relocations): Catch potential integer overflow whilst checking reloc location against section size.,-	  if ((rloc + reloc_size) > end || (rloc < start))
"Error in ""_bfd_hexdump"": heap-buffer-overflow","+      _bfd_hexdump (8, ptr, cmd_length - 4, 0);"
Fix snafu checking for invalid word offsets in ARM unwind information.,"+  if (
+      sec->sh_size < 4
+      || word_offset > (sec->sh_size - 4)
       || ((bfd_signed_vma) word_offset) < 0)
     return FALSE;"
"The getvalue function in tekhex.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (stack-based buffer over-read and application crash) via a crafted tekhex file, as demonstrated by mishandling within the nm program.",-         int offsetlen = flag & 0x7;
Check for buffer overrun when printing out rae insns.,"-                 if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
-                   {
-                     for (k = bpc - 1; k >= 0; k--)
-                       printf (""%02x"", (unsigned) data[j + k]);
-                     putchar (' ');
-                   }
-                 else"
Check for buffer overrun when printing out rae insns.,+                 if (j + bpc <= stop_offset * opb)
"The get_build_id function in opncls.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted file in which a certain size field is larger than a corresponding data field, as demonstrated by mishandling within the objdump program.",       oappend (names_bnd[modrm.reg]);
"fix out of range subtraction, seg fault from a NULL pointer and memory exhaustion, all from parsing corrupt binaries.","          if (archive_file_offset != 0)
            section.sh_size = archive_file_size - section.sh_offset;"
PR binutils/21345 * readelf.c (get_program_headers): Check for there being too many program headers before attempting to allocate space for them.,"+      if (conflictsno * sizeof (* iconf) > current_file_size)
+       {
+         error (_(""Overlarge number of conflicts detected: %lx\n""),
+                (long) conflictsno);
+         return FALSE;
+       }"
This can cause _objalloc_alloc to return a pointer to a memory region which is smaller than expected.,   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
Running size (or gdb and probably others) on the reproducer results in a buffer stack overflow.,-      char hdr[8];
"Your analysis of the bug was correct, although the correct thing to do was to jump to the error_ret label if the input buffer was too small.","+      if (PRIV (recrd.rec_size < test_len))
+       goto error_ret;"
Prevent invalid array accesses when disassembling a corrupt bfin binary.,"+#define regs_hi(x, i) REGNAME (decode_regs_hi[(((i) << 3) | (x)) & 31])"
Fix stack buffer overflows when parsing corrupt ihex files.,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
Check for buffer overflow before writing relocated values.,"+               if (start + reloc->r_offset + reloc_size >= end)
+                 error (_(""MN10300 sym diff reloc writes past end of section (%p vs %p)\n""),
+                        start + reloc->r_offset + reloc_size, end);
+               else
+                 byte_put (start + reloc->r_offset, value, reloc_size);"
"Error in ""ieee_object_p"": stack-buffer-overflow",-  unsigned char buffer[300];
But it does not forbid directory traversal in the paths.,"+      if (amt > (bfd_size_type) bfd_get_size (abfd))
+       goto byebye;"
Check for an empty or very small group section.,"+         if (idx == NULL || shdr->sh_size < 4)
+           {
+             _bfd_error_handler (_(""%B: group section '%A' has no contents""),
+                                 abfd, shdr->bfd_section);
+             elf_tdata (abfd)->group_sect_ptr[i] = NULL;
+             bfd_set_error (bfd_error_bad_value);
+             return FALSE;
+           }"
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,+  if (size < 0x24)
"When ""uvalue"" is a specific value, ""block_start + uvalue"" will cause integer overflow.", 	  rloc = start + rp->r_offset;
"Error in ""aarch64_ext_ldst_reglist"": global-buffer-overflow","   if (expected_num != data[value].num_elements || data[value].is_reserved)
     return 0;"
PR binutils/21581 (ieee_archive_p): Use a static buffer to avoid compiler bugs.,+  static unsigned char buffer[512];
Extend check of cmd_length.,+      if (cmd_length < 4 || (ptr + cmd_length > maxptr + 4))
(alpha_vms_object_p): Check for a truncated record.,"+         if (res == res_base)
+           return FALSE;"
PR binutils/17533 * archive.c (_bfd_slurp_extended_name_table): Handle archives with corrupt extended name tables.,"+      if (amt > (bfd_size_type) bfd_get_size (abfd))
+       goto byebye;"
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
"If reloc pointer is NULL, discard all saved state.","+      target_specific_reloc_handling (NULL, NULL, NULL, NULL, 0);"
Check for symbol table overflow before accessing symbol value.,"+           if (sym_index >= num_syms)
+             error (_(""RL78_SYM reloc contains invalid symbol index %lu\n""),
+                    sym_index);
+           else
+             {
+               saved_sym2 = symtab[sym_index].st_value;
+               saved_sym2 += reloc->r_addend;
+             }
            return TRUE;"
"opcodes/i386-dis.c in GNU Binutils 2.28 does not consider the number of registers for bnd mode, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.","+      if (reg > 0x3)
+       {
+         oappend (""(bad)"");
+         return;
+       }"
Use to check for corrupt pair relocs.,+       (alpha_vms_object_p): Check for a truncated record.
The print_symbol_for_build_attribute function in readelf.c in GNU Binutils 2017-04-12 allows remote attackers to cause a denial of service (invalid read and SEGV) via a crafted ELF file.,-  if (saved_file == NULL || file != saved_file)
Fix seg fault attempting to unget an EOF character.,"+             else if (ch2 != EOF)
                {
                  UNGET (ch2);
                }"
Fix address violation parsing a corrupt texhex format file.,"+  if (src >= endp)
+    return FALSE;"
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",+      unsigned int i;
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+                   if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                     {
+                       _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                           psindx);
+                       bfd_set_error (bfd_error_bad_value);
+                       return FALSE;
+                     }
+                    entry->code_section = PRIV (sections)[psindx];"
binutils/ * readelf.c (process_mips_specific): Remove error reporting from GOT[1] processing.,"-             error (_(""Invalid got entry - %#lx - overflows GOT table\n""),
-                    (long) ent);"
(_bfd_vms_slurp_egsd): Check for an invalid section index.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
PR other/54411: integer overflow in objalloc_alloc.,   len = (len + OBJALLOC_ALIGN - 1) &~ (OBJALLOC_ALIGN - 1);
"The process_otr function in bfd/versados.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.28, does not validate a certain offset, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted binary file, as demonstrated by mishandling of this file during ""objdump -D"" execution.",-      int i;
Joshua Rogers reported a stack buffer overflow in ihex.c (ihex_bad_byte).,"-       sprintf (buf, ""\\%03o"", (unsigned int) c);"
Fix stack buffer overflow when printing bad bytes in Intel Hex objects.,-         char hdr[8];
x86: Check for valid PLT section size Update x86 get_synthetic_symtab to check for valid PLT section size before examining PLT section contents.,"+      if (plt == NULL || plt->size == 0)
        continue;"
Fix seg-faults in objdump when disassembling a corrupt versados binary.,"-      tdata_type *tdata = bfd_alloc (abfd, amt);"
Fix seg-faults in objdump when disassembling a corrupt versados binary.,-      int i;
"Remove the extra error reporting code then, introduced with commit 75ec1fdbb797 (""Fix runtime seg-fault in readelf when parsing a corrupt MIPS binary."")","-             error (_(""Invalid got entry - %#lx - overflows GOT table\n""),
-                    (long) ent);"
* libbfd.c (_bfd_generic_get_section_contents): Check for and reject a section whoes size + offset is greater than the size of the entire file.,+  size = bfd_get_section_size (sect);
x86: Check for valid PLT section size Update x86 get_synthetic_symtab to check for valid PLT section size before examining PLT section contents.,"+      if (plt == NULL || plt->size == 0)
        continue;"
Fix stack buffer overflows when parsing corrupt ihex files.,-                 char datum = * ((char *) eopt + offset + len);
PR 21813 (alpha_vms_object_p): Check for a truncated record.,"+               if (psindx < 0 || psindx >= (int) PRIV (section_count))
+                 {
+                   _bfd_error_handler (_(""Corrupt EGSD record: its psindx field is too big (%#lx)""),
+                                       psindx);
+                   bfd_set_error (bfd_error_bad_value);
+                   return FALSE;
+                 }
+               entry->section = PRIV (sections)[psindx];"
Use to check for corrupt pair relocs.,"+  if (PRIV (recrd.buf_size) < sizeof (* eeom))
+    {
+      _bfd_error_handler (_(""Corrupt EEOM record - size is too small""));
+      bfd_set_error (bfd_error_bad_value);
+      return FALSE;
+    }"
> > binutils* objdump.c (disassemble_section): Skip any section that is > bigger > than the entire file.,"   if (inote.descsz == 0
       || inote.type != NT_GNU_BUILD_ID
       || inote.namesz != 4 
+      || strncmp (inote.namedata, ""GNU"", 4) != 0
+      || size < (12 + BFD_ALIGN (inote.namesz, 4) + inote.descsz))"
x86: Check for valid PLT section size Update x86 get_synthetic_symtab to check for valid PLT section size before examining PLT section contents.,"+      if (plts[j].type == plt_unknown
+         && (plt->size >= (lazy_plt->plt_entry_size
+                           + lazy_plt->plt_entry_size)))"
PR binutils/21962 * tekhex.c (getsym): Fix check for source pointer walking off the end of the input buffer.,"+  for (i = 0; i < len && (src + i) < endp; i++)
     dstp[i] = src[i];"
"The Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the PLT section size, which allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to elf_i386_get_synthetic_symtab in elf32-i386.c and elf_x86_64_get_synthetic_symtab in elf64-x86-64.c.","+      if (plt == NULL || plt->size == 0)
        continue;"
PR binutils/21595 * aarch64-dis.c (aarch64_ext_ldst_reglist): Check for an out of range value.,"+  if (value >= ARRAY_SIZE (data))
+    return 0;"
binutils* objdump.c (disassemble_section): Skip any section that is bigger than the entire file.,+  size = bfd_get_section_size (sect);
Fix stack buffer overflows when parsing corrupt ihex files.,-         char hdr[8];
Check for symbol table overflow before accessing symbol value.,"+               if (sym_index >= num_syms)
+                 error (_(""MN10300 reloc contains invalid symbol index %lu\n""),
+                        sym_index);"
(ihex_bad_byte): Prevent (now impossible to trigger) stack overflow and incorrect escape sequence handling.,-      char hdr[8];
* compress.c (bfd_get_full_section_contents): Check for and reject a section whoes size is greater than the size of the entire file.,+  if (size < 0x24)
Fixes out of array access. ,line[index] = (line[index / 3] + line[(index + 1) / 3] + line[(index + 2) / 3] + 1) / 3;
The studio profile decoder in libavcodec/mpeg4videodec.c in FFmpeg 4.0 before 4.0.4 and 4.1 before 4.1.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via crafted MPEG-4 video data.,             j = scantable[idx++];
More complex solutions like checking the path to limit access to only subdirectories of the hls path may work as an alternative.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.,"+            ret = sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32,
                    &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]);"
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,"+            if (avio_feof(pb)) {
+                return AVERROR_EOF;
+            }"
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.","+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme SGPD count exceeds implementation limit."");"
Issue 449958: Heap-buffer-overflow in media::CopyPlane.,"-             vpx_image->stride[VPX_PLANE_Y],"
"When a crafted ASF file, which claims a large ""name_len"" or ""count"" field in the header but does not contain sufficient backing data, is provided, the loops over the name and markers would consume huge CPU and memory resources, since there is no EOF check inside these loops.","+        if (avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
avcodec/mpeg4videodec: Check idx in mpeg4_decode_studio_block().,"+            if (idx > 63)
+                return AVERROR_INVALIDDATA;"
More complex solutions like checking the path to limit access to only subdirectories of the hls path may work as an alternative.,"static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
avformat/mms: Add missing chunksize check.,         p += chunksize;
avformat/rmdec: Fix DoS due to lack of eof check.,"+            for (j = 0; j < len; j++) {
+                if (avio_feof(pb))
+                    return AVERROR_INVALIDDATA;
                av_log(s, AV_LOG_DEBUG, ""%X"", avio_r8(pb));
+            }"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b2 - b6) >> 7)];
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.","+                        if (   h * mb_x + x >= s->width
+                            || v * mb_y + y >= s->height) {
+                        } else if (bits<=8) {"
Fixes use of freed memory.,"for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
             ff_h264_unref_picture(h, &h->DPB[i]);"
"The ff_frame_thread_init function in libavcodec/pthread_frame.c in FFmpeg before 2.7.2 mishandles certain memory-allocation failures, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via a crafted file, as demonstrated by an AVI file.",             goto error;
"The VideoFramePool::PoolImpl::CreateFrame function in media/base/video_frame_pool.cc in Google Chrome before 47.0.2526.73 does not initialize memory for a video-frame data structure, which might allow remote attackers to cause a denial of service (out-of-bounds memory access) or possibly have unspecified other impact by leveraging improper interaction with the vp3_h_loop_filter_c function in libavcodec/vp3dsp.c in FFmpeg.","+    for (size_t i = 0; i < num_planes; ++i) {
+      memset(frame->data(i),
+             0,
+             VideoFrame::PlaneSize(frame->format(),
+                                   i,
+                                   frame->coded_size()).GetArea());
+    }"
Fixes: out of array accesses.,-                xd_size += len;
Fixes: out of array access.,"-        strcpy(filename, sic->filename);"
FFmpeg before 2017-02-04 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame_common function in libavcodec/pngdec.c.,             uint8_t *row = &s->image_buf[s->image_linesize * y];
avcodec/pngdec: Fix off by 1 size in decode_zbuf().,"+        av_bprint_get_buffer(bp, 2, &buf, &buf_size);"
avformat/aadec: Check for scanf() failure.,"+            if (ret != 4)
+                return AVERROR_INVALIDDATA;"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","+            mpeg4_decode_profile_level(s, gb, &profile, &level);"
Avoids leaving stale pointers. ,+        r->cbp_chroma       = NULL;
Fixes: out of array read. ,"             get_bits(gb, 8);"
avcodec/utvideodec: Add several out of array read related checks.,"+            if (3 * ((dst + send * stride - dest + 7)/8) > get_bits_left(&cbit))
+                return AVERROR_INVALIDDATA;"
But files with sensitive information like private keys and passwords generally do not use common multimedia filename extensions.,"static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
"The ff_sbr_apply function in libavcodec/aacsbr.c in FFmpeg before 2.7.2 does not check for a matching AAC frame syntax element before proceeding with Spectral Band Replication calculations, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted AAC data.","+    if (id_aac != sbr->id_aac) {
+        av_log(ac->avctx, AV_LOG_ERROR,
+            ""element type mismatch %d != %d\n"", id_aac, sbr->id_aac);
+        sbr_turnoff(sbr);
+    }"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions. ",+    s->buf_size = avctx->width*avctx->height*2 + 1000;
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->intra_types_hist = NULL;
avcodec/gif: Fix lzw buffer size.,+    s->buf_size = avctx->width*avctx->height*2 + 1000;
"libavcodec/hevcdec.c in FFmpeg 3.4 and 4.1.2 mishandles detection of duplicate first slices, which allows remote attackers to cause a denial of service (NULL pointer dereference and out-of-array access) or possibly have unspecified other impact via crafted HEVC data.","-        av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");"
"libavcodec/gif.c in FFmpeg before 2.8.6 does not properly calculate a buffer size, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted .tga file, related to the gif_image_write_image, gif_encode_init, and gif_encode_close functions.",+    s->buf_size = avctx->width*avctx->height*2 + 1000;
avformat/rtmppkt: Check for packet size mismatches.,"+                size,"
"Validates the set channel layout as well as verifies that the received layout to the function matches the reference layout, so that it matches the implemented re-ordering logic.","+    if (layout == PREFIX_FOR_22POINT2 && tags == 16 && i == 8) {
+        const uint8_t (*reference_layout_map)[3] = aac_channel_layout_map[12];
+        for (int j = 0; j < tags; j++) {
+            if (layout_map[j][0] != reference_layout_map[j][0] ||
+                layout_map[j][2] != reference_layout_map[j][2])
+                goto end_of_layout_definition;
+        }"
Do not trust the counts.,"+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_edit, static_cast<size_t>(count));"
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
Fixes: out of array access.,    s->height = AV_RL16(&s->avctx->extradata[8]);
avcodec/xwddec: Check bpp more completely.,"+        } else if (bpp == 8 && pixdepth == 8) {
             avctx->pix_fmt = AV_PIX_FMT_GRAY8;
         }"
"libavcodec/tiff.c in FFmpeg before 2.8.6 does not properly validate RowsPerStrip values and YCbCr chrominance subsampling factors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted TIFF file, related to the tiff_decode_tag and decode_frame functions.",+    if (s->rps <= 0 || s->rps % s->subsampling[1]) {
"FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data.","+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
"The ff_rv34_decode_init_thread_copy function in libavcodec/rv34.c in FFmpeg before 2.7.2 does not initialize certain structure members, which allows remote attackers to cause a denial of service (invalid pointer access) or possibly have unspecified other impact via crafted (1) RV30 or (2) RV40 RealVideo data.",+        r->cbp_luma         = NULL;
"Validates the set channel layout as well as verifies that the received layout to the function matches the reference layout, so that it matches the implemented re-ordering logic.",+    if (layout == AV_CH_LAYOUT_22POINT2) {
"libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.","+            if (y >= avctx->height)
+                return AVERROR_INVALIDDATA;"
The decode_plane function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,"+                if (c->packed_stream_size[i][j] > left)
                     return AVERROR_INVALIDDATA;"
"In FFmpeg 4.0.1, due to a missing check of a profile value before setting it, the ff_mpeg4_decode_picture_header function in libavcodec/mpeg4videodec.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","-    s->avctx->level   = get_bits(gb, 4);"
Fixes: Out of array access. ,             j = scantable[idx++];
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.",   entries.resize(count);
avcodec/mjpegdec: Check index in ljpeg_decode_yuv_scan() before using it.,"+                        if (   h * mb_x + x >= s->width
+                            || v * mb_y + y >= s->height) {
+                        } else if (bits<=8) {"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b4) >> 7)];
avcodec/mpeg4videodec: Check read profile before setting it.,"+    if (*profile == 0 && *level == 8) {
+        *level = 0;"
"The init_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.2 does not enforce minimum-value and maximum-value constraints on tile coordinates, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted JPEG 2000 data.","+    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b3 + b7) >> 7)];
avcodec/mpegvideo: Clear pointers in ff_mpv_common_init(). ,"-    memset(&s->last_picture, 0, sizeof(s->last_picture));"
"The sws_init_context function in libswscale/utils.c in FFmpeg before 2.7.2 does not initialize certain pixbuf data structures, which allows remote attackers to cause a denial of service (segmentation violation) or possibly have unspecified other impact via crafted video data.","+    FF_ALLOCZ_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
The jpeg2000_decode_tile function in libavcodec/jpeg2000dec.c in FFmpeg before 2.8.6 allows remote attackers to cause a denial of service (out-of-bounds array read access) via crafted JPEG 2000 data.,-    if (s->cdef[0] < 0) {
FFmpeg before 2017-01-23 has an out-of-bounds write caused by a stack-based buffer overflow related to the decode_zbuf function in libavcodec/pngdec.c.,"+        if (buf_size < 2) {
             ret = AVERROR(ENOMEM);
             goto fail;
         }"
The decode_init function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via an AVI file.,         c->slices      = avctx->extradata[9] + 1;
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.","-  if (reader->version() == 1) {
-    RCHECK(reader->HasBytes(count * 20));
-  }"
Fixes: out of array read. ,"         av_log(avctx, AV_LOG_DEBUG, ""Encoder version %d.%d.%d.%d\n"",
                avctx->extradata[3], avctx->extradata[2],
                avctx->extradata[1], avctx->extradata[0]);"
avcodec/mpeg4videodec: Remove use of FF_PROFILE_MPEG4_SIMPLE_STUDIO as indicator of studio profile.,"     if(s->avctx->hwaccel && s->avctx->hwaccel->decode_slice           ||
        !s->cur_pic.f                                                  ||
-       s->cur_pic.field_picture                                       ||
-       s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO
+       s->cur_pic.field_picture
     )"
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.","+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme SBGP count exceeds implementation limit."");"
Integer overflow in the ape_decode_frame function in libavcodec/apedec.c in FFmpeg 2.4 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access and application crash) or possibly have unspecified other impact via a crafted APE file.,"-    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);"
avcodec/mjpegdec: Check index in ljpeg_decode_yuv_scan() before using it.,"+                        if (   h * mb_x + x >= s->width
+                            || v * mb_y + y >= s->height) {
+                        } else if (bits<=8) {"
Fixes out of array access.,-                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;
Fixes: out of array access.,             dst[y * linesize + x] = clr;
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.","+  base::CheckedNumeric<size_t> bytes_needed =
+      base::CheckMul(bytes_per_entry, static_cast<size_t>(count));"
avcodec/sanm: Reset sizes in destroy_buffers().,"+    init_sizes(ctx, 0, 0);"
avcodec/gif: Fix lzw buffer size.,"+    ff_lzw_encode_init(s->lzw, s->buf, s->buf_size,"
avformat/flvenc: Check audio packet size.,"+    if (par->codec_type == AVMEDIA_TYPE_AUDIO && !pkt->size) {
+        av_log(s, AV_LOG_WARNING, ""Empty audio Packet\n"");
+        return AVERROR(EINVAL);
+    }"
Check for size_t and vector resize() overflow to avoid OOB writes in vector allocation.,+  RCHECK(reader->HasBytes(bytes_needed.ValueOrDie()));
Failure to verify causes total_size > atom.size which will result in negative size calculations later on.,+            if (a.size == 1 && total_size + 8 <= atom.size) {
Fixes: out of array read.,"             v = get_bits(gb, 8);"
avcodec/faxcompr: Add missing runs check in decode_uncompressed().,"+        if (*runs >= runend) {
+            av_log(avctx, AV_LOG_ERROR, ""uncompressed run overrun\n"");
+            return AVERROR_INVALIDDATA;
+        }"
"The decode_ihdr_chunk function in libavcodec/pngdec.c in FFmpeg before 2.7.2 does not enforce uniqueness of the IHDR (aka image header) chunk in a PNG image, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted image with two or more of these chunks.","+    if (s->state & PNG_IHDR) {
+        av_log(avctx, AV_LOG_ERROR, ""Multiple IHDR\n"");
+        return AVERROR_INVALIDDATA;
+    }"
track_header in libavformat/vividas.c in FFmpeg 4.3.1 has an out-of-bounds write because of incorrect extradata packing.,"-                if (delta > data_len[j]) {
-                    return AVERROR_INVALIDDATA;
-                }"
avcodec/htmlsubtitles: Fixes denial of service due to use of sscanf in inner loop for handling braces.,+            an += scanbraces(in);
libavformat/movenc.c in FFmpeg 3.2 and 4.0.2 allows attackers to cause a denial of service (application crash caused by a divide-by-zero error) with a user crafted audio file when converting to the MOV audio format.,+        if (track->timescale > UINT16_MAX || !track->par->channels) {
ffserver: Check chunk size.,+            av_assert0(len <= c->chunk_size);
"In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","-    init_get_bits8(&gb, buf, size);"
avformat/hls: Check local file extensions.,"+    if (av_strstart(proto_name, ""file"", NULL)) {
+        if (strcmp(c->allowed_extensions, ""ALL"") && !av_match_ext(url, c->allowed_extensions)) {
+            av_log(s, AV_LOG_ERROR,
+                ""Filename extension of \'%s\' is not a common multimedia extension, blocked for security reasons.\n""
+                ""If you wish to override this adjust allowed_extensions, you can set it to \'ALL\' to allow all\n"",
+                url);
+            return AVERROR_INVALIDDATA;
+        }
+    }"
"The dnxhd decoder in FFmpeg before 3.2.6, and 3.3.x before 3.3.3 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted mov file.","-                if (dctx->remaining <= 0) {
-                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
-                    if (dctx->remaining <= 0)
-                        return dctx->remaining;"
There is a heap-buffer-overflow at libavfilter/vf_colorconstancy.c:282 in slice_get_derivative.,"                         dst[INDX2D(r, c, width)] += GAUSS(src, r + GINDX(filtersize, g), c,
-                                                          width, height, width, gauss[GINDX(filtersize, g)]);
+                                                          width, height, width, gauss[g]);"
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,"+            if (avio_feof(pb)) {
+                return AVERROR_EOF;
+            }"
"libavcodec/tiff.c in FFmpeg before 2.8.6 does not properly validate RowsPerStrip values and YCbCr chrominance subsampling factors, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via a crafted TIFF file, related to the tiff_decode_tag and decode_frame functions.","+            if (s->subsampling[i] <= 0) {
+                av_log(s->avctx, AV_LOG_ERROR, ""subsampling %d is invalid\n"", s->subsampling[i]);
+                return AVERROR_INVALIDDATA;
+            }"
"In FFmpeg 4.0.1, a missing check for failure of a call to init_get_bits8() in the avpriv_ac3_parse_header function in libavcodec/ac3_parser.c may trigger a NULL pointer dereference while converting a crafted AVI file to MPEG4, leading to a denial of service.","     err = ff_ac3_parse_header(&gb, hdr);"
swscale/utils: Clear pix buffers.,"+    FF_ALLOCZ_OR_GOTO(c, c->chrUPixBuf, c->vChrBufSize * 3 * sizeof(int16_t *), fail);"
avcodec/cavsdsp: use av_clip_uint8() for idct.,+        dst[i + 2*stride] = av_clip_uint8( dst[i + 2*stride] + ((b2 + b6) >> 7));
avcodec/mpeg4videodec: Remove use of FF_PROFILE_MPEG4_SIMPLE_STUDIO as indicator of studio profile.,"     if (avctx->bits_per_raw_sample > 8) {
-        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
+        av_assert1(s->studio_profile);
         return avctx->pix_fmt;
     }"
Clear pointers in ff_rv34_decode_init_thread_copy().,+        r->intra_types_hist = NULL;
"In line libavcodec/h264dec.c:500 in libav(v13_dev0), ffmpeg(n3.4), chromium(56 prior Feb 13, 2017), the return value of init_get_bits is ignored and get_ue_golomb(&gb) is called on an uninitialized get_bits context, which causes a NULL deref exception.","-            if (ret < 0)
-                return ret;"
Do not trust the counts.,+  RCHECK(count <= entries.max_size());
avcodec/msrledec: avcodec/msrledec: restructure msrle_decode_pal4() based on the line number instead of the pixel pointer.,+    int line = avctx->height - 1;
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.","else {
-    RCHECK(reader->HasBytes(count * 12));
-  }"
Clear pointers in ff_rv34_decode_init_thread_copy().,+        r->mb_type          = NULL;
avformat/nsvdec: Fix DoS due to lack of eof check in nsvs_file_offset loop.,"+        if(avio_feof(pb))
+            return AVERROR_INVALIDDATA;"
avcodec/dnxhddec: Move mb height check out of non hr branch.,         ctx->data_offset = 0x280;
The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg 3.0 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.,"     if (ctx->mb_height > 68 && ff_dnxhd_check_header_prefix_hr(header_prefix)) {
         ctx->data_offset = 0x170 + (ctx->mb_height << 2);
     }"
avformat/avidec: Fix infinite loop in avi_read_nikon().,-            while (avio_tell(s->pb) < tag_end) {
"A denial of service in the subtitle decoder in FFmpeg 3.2 and 4.1 allows attackers to hog the CPU via a crafted video file in Matroska format, because handle_open_brace in libavcodec/htmlsubtitles.c has a complex format argument to sscanf.","-            an += sscanf(in, ""{\\an%*1u}%n"", &len) >= 0 && len > 0;"
Fixes: out of array access.,-    av_assert0(decoded_buffer_size <= INT_MAX);
Check for bitstream end in read_quant_matrix_ext(). ,"+        if (get_bits_left(gb) < 64*8)
+            return AVERROR_INVALIDDATA;"
"FFmpeg before 2.8.12, 3.0.x and 3.1.x before 3.1.9, 3.2.x before 3.2.6, and 3.3.x before 3.3.2 does not properly restrict HTTP Live Streaming filename extensions and demuxer names, which allows attackers to read arbitrary files via crafted playlist data.","static const AVOption hls_options[] = {
     {""live_start_index"", ""segment index to start live streams at (negative values are from the end)"",
         OFFSET(live_start_index), AV_OPT_TYPE_INT, {.i64 = -3}, INT_MIN, INT_MAX, FLAGS},
+    {""allowed_extensions"", ""List of file extensions that hls is allowed to access"",
+        OFFSET(allowed_extensions), AV_OPT_TYPE_STRING,
+        {.str = ""3gp,aac,avi,flac,mkv,m3u8,m4a,m4s,m4v,mpg,mov,mp2,mp3,mp4,mpeg,mpegts,ogg,ogv,oga,ts,vob,wav""},
+        INT_MIN, INT_MAX, FLAGS},
     {NULL}
 };"
FFmpeg before commit 9807d3976be0e92e4ece3b4b1701be894cd7c2e1 contains a CWE-835: Infinite loop vulnerability in pva format demuxer that can result in a Vulnerability that allows attackers to consume excessive amount of resources like CPU and RAM.,             pes_header_data_length = avio_r8(pb);
"avcodec/pthread_frame: clear priv_data, avoid stale pointer in error case.",+            copy->priv_data = NULL;
Fixes out of array access,         sbr->kx[0] = sbr->kx[1];
avcodec/mjpegdec: Fix small picture upscale.,+                        ((uint16_t*)line)[w - 1] = ((uint16_t*)line)[(w - 1) / 3];
"The ljpeg_decode_yuv_scan function in libavcodec/mjpegdec.c in FFmpeg before 2.8.2 omits certain width and height checks, which allows remote attackers to cause a denial of service (out-of-bounds array access) or possibly have unspecified other impact via crafted MJPEG data.",+        prev_pkt[channel_id].read = 0;
avcodec/cdxl: Check format for BGR24.,+    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8) && c->format != CHUNKY) {
avcodec/mjpegdec: Check number of components for JPEG-LS.,"+        } else if (s->nb_components != 1) {
+            av_log(s->avctx, AV_LOG_ERROR, ""Unsupported number of components %d\n"", s->nb_components);
+            return AVERROR_PATCHWELCOME;
+        }"
Fixes: Infinite loop.,             pes_flags              = avio_rb16(pb);
MSE: Fix moar mp4 parsing security bugs.,+  RCHECK(sample_count <= sample_depends_on_.max_size());
avcodec/vp8: Do not use num_coeff_partitions in thread/buffer setup: The variable is not a constant and can lead to race conditions,"-                   FFMIN(s->num_coeff_partitions, avctx->thread_count) > 1;"
Revert to zero-initializing buffers for FFmpegVideoDecoder.,"+    for (size_t i = 0; i < num_planes; ++i) {
+      memset(frame->data(i),
+             0,
+             VideoFrame::PlaneSize(frame->format(),
+                                   i,
+                                   frame->coded_size()).GetArea());
+    }"
avformat/avidec: Fix memleak with dv in avi.,+                av_freep(&s->streams[0]->internal);
Fixes: out of array accesses.,"-            ret = ff_alloc_extradata(st->codecpar, 64 + xd_size + xd_size / 255);"
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.","+  RCHECK_MEDIA_LOGGED(bytes_needed.IsValid(), reader->media_log(),
+                      ""Extreme ELST count exceeds implementation limit."");"
Added one additional check for SampleEncryptionEntry (probably overkill).,+  size_t sample_count = reader->box_size() - reader->pos();
"An integer overflow in FFmpeg in Google Chrome prior to 57.0.2987.98 for Mac, Windows, and Linux and 57.0.2987.108 for Android allowed a remote attacker to perform an out of bounds memory write via a crafted video file, related to ChunkDemuxer.",   for (uint32_t i = 0; i < count; ++i) {
avcodec/g726: Add missing ADDB output mask.,"+    } else if (avctx->width % FONT_WIDTH || avctx->height % s->font_height) {
+        av_log(avctx, AV_LOG_ERROR, ""Invalid dimensions %d %d\n"", avctx->width, avctx->height);
+        return AVERROR(EINVAL);
     }"
check segment duration value of EXTINF. ,"+                if (duration < 0.001 * AV_TIME_BASE) {
+                    av_log(c->ctx, AV_LOG_WARNING, ""Cannot get correct #EXTINF value of segment %s,""
+                                    "" set to default value to 1ms.\n"", seg->url);
+                    duration = 0.001 * AV_TIME_BASE;
+                }"
The cavs_idct8_add_c function in libavcodec/cavsdsp.c in FFmpeg before 3.1.4 is vulnerable to reading out-of-bounds memory when decoding with cavs_decode. ,-        dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b1 - b5) >> 7)];
"Additionally, verify we have enough bytes to continue parsing before allocating vectors to store parsed data.",+  RCHECK(count <= entries.max_size());
track_header in libavformat/vividas.c in FFmpeg 4.3.1 has an out-of-bounds write because of incorrect extradata packing.,-                xd_size += len;
"In line libavcodec/h264dec.c:500 in libav(v13_dev0), ffmpeg(n3.4), chromium(56 prior Feb 13, 2017), the return value of init_get_bits is ignored and get_ue_golomb(&gb) is called on an uninitialized get_bits context, which causes a NULL deref exception. ","-            if (ret < 0)
-                return ret;"
avcodec/jpeg2000dec: Clip all tile coordinates.,"+    tile->coord[1][1] = av_clip((tiley + 1) * s->tile_height + s->tile_offset_y, s->image_offset_y, s->height);"
avformat/vividas: improve extradata packing checks in track_header().,avformat/vividas: improve extradata packing checks in track_header().
"In FFmpeg 4.0.1, improper handling of frame types (other than EAC3_FRAME_TYPE_INDEPENDENT) that have multiple independent substreams in the handle_eac3 function in libavformat/movenc.c may trigger an out-of-array access while converting a crafted AVI file to MPEG4, leading to a denial of service or possibly unspecified other impact.","+        } else {
+            if (hdr->substreamid != 0) {
+                avpriv_request_sample(mov->fc, ""Multiple non EAC3 independent substreams"");
+                ret = AVERROR_PATCHWELCOME;
+                goto end;
+            }
         }"
"Integer overflow in the ff_ivi_init_planes function in libavcodec/ivi.c in FFmpeg before 2.6.5, 2.7.x before 2.7.3, and 2.8.x through 2.8.2 allows remote attackers to cause a denial of service (out-of-bounds heap-memory access) or possibly have unspecified other impact via crafted image dimensions in Indeo Video Interactive data.",-    if (cfg->pic_width < 1 || cfg->pic_height < 1 ||
avcodec/msrledec: avcodec/msrledec: restructure msrle_decode_pal4() based on the line number instead of the pixel pointer.,+                line--;
avformat/rtmppkt: Check for packet size mismatches.,"+        av_log(NULL, AV_LOG_ERROR, ""RTMP packet size mismatch %d != %d\n"","
The decode_plane function in libavcodec/utvideodec.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out of array read) via a crafted AVI file.,"+                    if ((bits + 1) * 8 > get_bits_left(&pbit))
+                        return AVERROR_INVALIDDATA;"
"The destroy_buffers function in libavcodec/sanm.c in FFmpeg before 2.7.2 does not properly maintain height and width values in the video context, which allows remote attackers to cause a denial of service (segmentation violation and application crash) or possibly have unspecified other impact via crafted LucasArts Smush video data.","+    init_sizes(ctx, 0, 0);"
avcodec/ac3_parser: Check init_get_bits8() for failure.,"     err = ff_ac3_parse_header(&gb, hdr);"
The dnxhd_decode_header function in libavcodec/dnxhddec.c in FFmpeg 3.0 through 3.3.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a crafted DNxHD file.,if (buf_size < ctx->data_offset) {
"While ffmpeg calculating bytestream_end in ff_init_range_encoder() of libavcodec/rangecoder.c, it uses a small buf_size.",-             f->slice_count < MAX_SLICES && 3 < p - c->bytestream_start;
avcodec/ansi: Check dimensions.,"+    } else if (avctx->width % FONT_WIDTH || avctx->height % s->font_height) {
+        av_log(avctx, AV_LOG_ERROR, ""Invalid dimensions %d %d\n"", avctx->width, avctx->height);
+        return AVERROR(EINVAL);
     }"
The old factor of two seemed to be a workaround that fact and only padded to the left and bottom.,-    av_freep(&s->buffer);
zero initialize the rbsp buffer. ,"     if (rbsp->rbsp_buffer_alloc_size >= size &&
-        (!rbsp->rbsp_buffer_ref || av_buffer_is_writable(rbsp->rbsp_buffer_ref)))
+        (!rbsp->rbsp_buffer_ref || av_buffer_is_writable(rbsp->rbsp_buffer_ref))) {
+        av_assert0(rbsp->rbsp_buffer);
+        memset(rbsp->rbsp_buffer + min_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
         return;
+    }"
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,-			if (argc > MAX_PACK_ARGS) {
"While pruning trailing text from ar filenames, we did not check for an empty filename.","+       if (p < filename) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
+                   ""Found entry with empty filename"");
+               return (ARCHIVE_FATAL);
+       }"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.",		*bsz = 0U;
Issue #767: Buffer overflow printing a filename.,			outbuff[i] = '\0';
"(Each byte would get expanded to a four-charcter octal-style escape of the form ""\123"" resulting in >20 characters for the >5 byte multibyte character.)",-		if (i > (sizeof(outbuff) - 20)) {
ibarchive: heap-based buffer overflow in xml_data (archive_read_support_format_xar.c).,	while (char_cnt-- > 0) {
Fix typo in preprocessor macro in archive_read_format_zip_cleanup().,-#if HAVA_LZMA_H && HAVE_LIBLZMA
"libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service).",*buff = zip->uncompressed_buffer_pointer;
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,-			if (argc > MAX_PACK_ARGS) {
"libarchive version commit bf9aec176c6748f0ee7a678c5f9f9555b9a757c1 onwards (release v3.0.2 onwards) contains a CWE-125: Out-of-bounds Read vulnerability in 7zip decompression, archive_read_support_format_7zip.c, header_bytes() that can result in a crash (denial of service). This attack appears to be exploitable via the victim opening a specially crafted 7zip file.","-		*buff = __archive_read_ahead(a, 1, &bytes_avail);"
Avoid a double-free when a window size of 0 is specified.,"    new_window = realloc(rar->lzss.window, new_size);"
This means that in some cases is not enough do few hours of fuzzing and believe that there aren?????t more bugs????? A crafted file causes a stack-buffer overflow write.,-		if (i > (sizeof(outbuff) - 20)) {
"When reading OS X metadata entries in Zip archives that were stored without compression, libarchive would use the uncompressed entry size to allocate a buffer but would use the compressed entry size to limit the amount of data copied into that buffer.","+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Malformed OS X metadata entry: inconsistent size"");
+			return (ARCHIVE_FATAL);
+		}"
This is a simple NULL dereference leading to a crash.,"+    if (new_size == 0) {
+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+                        ""Zero window size is invalid."");
+      return (ARCHIVE_FATAL);
+    }"
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,+			numbers[argc++] = (unsigned long)mtree_atol(&p);
Fail with negative lha->compsize in lha_read_file_header_1(). ,"+	if (lha->compsize < 0)
+		goto invalid;"
archive_strncat_l(): allocate and do not convert if length == 0.,+       if (_p == NULL || n == 0) {
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.",			len = field[n].end - field[n].start;
bsdtar in libarchive before 3.2.0 allows remote attackers to cause a denial of service (infinite loop) via an ISO with a directory that is a member of itself.,	file->parent = parent;
"reject sparse blocks with negative size or offset, detect overflow when tracking sparse blocks","+       if (remaining < 0 || offset < 0) {
+               archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC, ""Malformed sparse map data"");
+               return (ARCHIVE_FATAL);
+       }"
"but only a few hundred bytes of data, causes a quasi-infinite loop.",	if (nrd < 0) {
Fix integer overflow when computing location of volume descriptor,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
Issue 761: Heap overflow reading corrupted 7Zip files.,			zip->entry_names = malloc(ll);
as->s[as->length] = '\0'; // **Heap overflow** occurs as it tries to write beyond the allocated heap memory.,			as->s[as->length] = '\0';
Fix typo in preprocessor macro in archive_read_format_zip_cleanup().,+#if HAVE_LZMA_H && HAVE_LIBLZMA
"libarchive version commit 9693801580c0cf7c70e862d305270a16b52826a7 onwards (release v3.2.0 onwards) contains a CWE-20: Improper Input Validation vulnerability in WARC parser - libarchive/archive_read_support_format_warc.c, _warc_read() that can result in DoS - quasi-infinite run time and disk usage from tiny file.","	rab = __archive_read_ahead(a, 1U, &nrd);"
Crash Type: Heap-buffer-overflow READ {*},-      filename[filename_size++] = '\0';
"If a 7-Zip archive declares a rediculously large number of substreams, it can overflow an internal counter, leading a subsequent memory allocation to be too small for the substream data.","+			if (unpack_streams > SIZE_MAX - UMAX_ENTRY) {
+				return (-1);
+			}"
Issue 403: Buffer underflow parsing 'ar' header.,"                if (ar->strtab == NULL || number > ar->strtab_size) {
                        archive_set_error(&a->archive, EINVAL,
+                           ""Can't find long filename for GNU/SVR4 archive entry"");
                        archive_entry_copy_pathname(entry, filename);
                        ar_parse_common_header(ar, entry, h);
+                       return (ARCHIVE_FATAL);
                }"
"If an OS X metadata entry is stored without compression, abort the entire archive if the compressed and uncompressed data sizes do not match.","+		if (rsrc->uncompressed_size != rsrc->compressed_size) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Malformed OS X metadata entry: inconsistent size"");
+			return (ARCHIVE_FATAL);
+		}"
Fix integer overflow when computing location of volume descriptor.,-	skipsize = LOGICAL_BLOCK_SIZE * vd->location;
"libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS.","    new_window = realloc(rar->lzss.window, new_size);"
"bsdtar: An error in archive_string_append_from_wcs() (archive_string.c) triggers an out-of-bounds write in heap memory that results into a crash, via a specially crafted archive file.",			end = as->s + as->buffer_length - MB_CUR_MAX -1;
Detect cycles in the ISO directory tree,"+	for (filep = parent; filep != NULL; filep = filep->parent) {
+		if (filep->offset == offset) {
+			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
+			    ""Directory structure contains loop"");
+			return (NULL);
+		}
+	}"
Fix typo in preprocessor macro in archive_read_format_zip_cleanup().,-#if HAVA_LZMA_H && HAVE_LIBLZMA
"The warc decoder only used read ahead, it wouldn't actually consume data that had previously been printed.","+	if (w->unconsumed) {
+		__archive_read_consume(a, w->unconsumed);
+		w->unconsumed = 0U;
+	}"
libarchive: bsdtar: heap-based buffer overflow in read_Header (archive_read_support_format_7zip.c).,"			h->attrBools = calloc((size_t)zip->numFiles,
			    sizeof(*h->attrBools));"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.",			st = field[n].start + 1;
Stack-based buffer overflow in the parse_device function in archive_read_support_format_mtree.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a crafted mtree file.,-			numbers[argc++] = (unsigned long)mtree_atol(&p);
"Integer signedness error in the archive_write_zip_data function in archive_write_set_format_zip.c in libarchive 3.1.2 and earlier, when running on 64-bit machines, allows context-dependent attackers to cause a denial of service (crash) via unspecified vectors, which triggers an improper conversion between unsigned and signed types, leading to a buffer overflow.","	return ((a->format_write_data)(a, buff, s));"
==27792==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010800 at pc 0x6169dd bp 0x7ffff41b2ef0 sp 0x7ffff41b2ee0.,"        p = __archive_read_ahead(a, ENC_HEADER_SIZE, NULL);"
"I've not been able to reproduce this, but have expanded the conversion buffer to 128 bytes on the belief that no multibyte character set has a single character of more than 32 bytes.",+		if (i > (sizeof(outbuff) - 128)) {
Fail if entry is too small for encryption header.,"+       if (0 == (zip->entry->zip_flags & ZIP_LENGTH_AT_END)) {
+           zip->entry_bytes_remaining -= ENC_HEADER_SIZE;
+       }"
Integer overflow in the archive_read_format_tar_skip function in archive_read_support_format_tar.c in libarchive before 3.2.0 allows remote attackers to cause a denial of service (crash) via a crafted tar file.,"+               if (!p->hole) {
+                       if (p->remaining >= INT64_MAX - request) {
+                               return ARCHIVE_FATAL;
+                       }
                        request += p->remaining;
+               }"
"The last of this batch is a quasi-infinite loop in the warc code (patch 4), where data isn't consumed after being written out, so a large Content-Length can be used to consume almost limitless time and space, leading to a DoS condition.",      new_size = rar_fls((unsigned int)rar->unp_size) << 1;
"libarchive 3.3.2 allows remote attackers to cause a denial of service (xml_data heap-based buffer over-read and application crash) via a crafted xar archive, related to the mishandling of empty strings in the atol8 function in archive_read_support_format_xar.c.",	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
"I suppose the cpio code could sanity-check the symlink size and return ARCHIVE_FATAL in this case without even trying to read it, but that would be a fairly minor improvement.","+		if (cpio->entry_bytes_remaining > 1024 * 1024) {
+			archive_set_error(&a->archive, ENOMEM,
+			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
+			return (ARCHIVE_FATAL);
+		}"
Issue #767: Buffer overflow printing a filename.,"			fprintf(f, ""%s"", outbuff);"
Fix user-after-free with `xmllint --xinclude --dropdtd`. ,-                   (cur->children->type != XML_XINCLUDE_START) &&
Avoid an out of bound access when serializing malformed strings.,-            } else if (*cur < 0xF8) {
"If the XPath stack is corrupted, for example by a misbehaving extension function, the ""and"" and ""or"" XPath operators could dereference NULL pointers.","-            valuePush(ctxt, arg1);"
==17901==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60300000ea56 at pc 0x46cfc5 bp 0x7fffffffc420 sp 0x7fffffffc400.B1+B39," 	    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,
 	            ""xmlParseEntityDecl: entity %s not terminated\n"", name);"
The count was incremented before the allocation and not fixed in case of failure.,+		set1->nodeMax *= 2;
==17867== ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe56c100c1 at pc 0xb6d62c bp 0x7ffe56c0fdd0 sp 0x7ffe56c0fdc8.,"-						ctxt->userData, &cur, 1);"
* xmlstring.c: (xmlStrncat): Return NULL if xmlStrlen returns a negative length.,"+    if (size < 0)
+        return(NULL)"
Avoid processing entities after encoding conversion failures.,"+    ret = xmlSwitchToEncodingInt(ctxt, handler, len);"
* xmlsave.c: xmlBufAttrSerializeTxtContent() if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,+            } else if ((*cur < 0xF0) && (cur [2] != 0)) {
Fix a potential freeing error in XPath,"-		xmlXPathReleaseObject(xpctxt, tmp);"
I've verified this bug is affecting latest PHP 5.6 with xml module which can cause a denial of service for applications accepting xpath/xslt.,"-            valuePush(ctxt, arg1);"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions.",-		set1->nodeMax *= 2;
Check that the XPath stack isn't empty and optimize the logic operators slightly.,"+            if (ctxt->value != NULL)
+                ctxt->value->boolval |= arg2->boolval;"
"Started by Chris Evans, I added a few more place where the error should have been set in the evaluation context.",+    ctxt->error = XPATH_INVALID_OPERAND;
Heap-based buffer overread in htmlCurrentChar.,"-        if ((*ctxt->input->cur == 0) &&
-            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0) &&
-            (ctxt->instate != XML_PARSER_COMMENT)) {"
Fixed by using a do-while loop so we always call htmlParseChunk() at least once.,+    } while (cur < size);
"Off-by-one error in libxml2, as used in Google Chrome before 19.0.1084.46 and other products, allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via unknown vectors.",-	    *cur++ = CUR;
arg1->boolval &= arg2->boolval; //and then the application is crashing here resulting in a Denial of Service condition.,"-            valuePush(ctxt, arg1);"
The count was incremented before the allocation and not fixed in case of failure.,+        cur->nodeMax *= 2;
Fix potential out of bound access.,-        while (buf[len - 1] == 0x20) len--;
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.," 	    if (temp == NULL) {
 	        xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		return(NULL);
 	    }"
Fix some potential problems on reallocation failures.,+		set1->nodeMax *= 2;
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.",-		set1->nodeMax *= 2;
Fix the semantic of XPath axis for namespace/attribute context nodes.,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
==2994== ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60040000d5d3 at pc 0x73320a bp 0x7fffffffc1e0 sp 0x7fffffffc1d8,"-        } else if ((*cur >= 0x80) && ((doc == NULL) ||
-                                      (doc->encoding == NULL))) {"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application."," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
If the string is not properly terminated do not try to convert to the given encoding.,"            if (RAW != '""') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions.",-        cur->nodeMax *= 2;
==35387==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200000eef7 at pc 0x7fa80a8da830 bp 0x7fff08c0f8f0 sp 0x7fff08c0f8e8,"         xmlRegAtomAddRange(ctxt, ctxt->atom, ctxt->neg,
 		           XML_REGEXP_CHARVAL, start, end, NULL);"
Fix inappropriate fetch of entities content.,"+		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+			(ctxt->validate != 0)) {
+			xmlLoadEntityContent(ctxt, ent);
+		    } else {
+			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
+		  ""not validating will not read content for PE entity %s\n"",
+		                      ent->name, NULL);
+		    }"
Fix out-of-bounds read with 'xmllint --htmlout'.,"    result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer);"
Fix a potential freeing error in XPath.,"+                if (tmp != contextObj)
+                    xmlXPathReleaseObject(xpctxt, tmp);"
Do not process encoding values if the declaration if broken.,"            if (RAW != '\'') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
Heap-based buffer overread in xmlParserPrintFileContextInternal., 	    ctxt->input->cur += tlen + 1;
Buffer overflow in libxml2 allows remote attackers to execute arbitrary code by leveraging an incorrect limit for port values when handling redirects.,     bp = (char*)xmlMallocAtomic(blen);
Fix inappropriate fetch of entities content.,"+		    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||
+			((ctxt->options & XML_PARSE_DTDVALID) != 0) ||
+			(ctxt->validate != 0)) {
+			xmlLoadEntityContent(ctxt, ent);
+		    } else {
+			xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,
+		  ""not validating will not read content for PE entity %s\n"",
+		                      ent->name, NULL);
+		    }"
"libxml2 through 2.9.1 does not properly handle external entities expansion unless an application developer uses the xmlSAX2ResolveEntity or xmlSetExternalEntityLoader function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.",-    if (ent->checked == 0) {
"libxml2 through 2.9.1 does not properly handle external entities expansion unless an application developer uses the xmlSAX2ResolveEntity or xmlSetExternalEntityLoader function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.",} else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {
"XML external entity (XXE) vulnerability in the xmlStringLenDecodeEntities function in parser.c in libxml2 before 2.9.4, when not in validating mode, allows context-dependent attackers to read arbitrary files or cause a denial of service (resource consumption) via unspecified vectors.","-		    xmlLoadEntityContent(ctxt, ent);"
"The fix for this would be to check the instate in xmlParseMarkupDecl after it parses an entry, and if EOF is reached, then stop.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"READ of size 1 at 0x000000c136a1 thread T0 #0 0x45736f in xmlNextChar /root/libxml2/parserInternals.c:535 #1 0x4fd936 in xmlParseInternalSubset /root/libxml2/parser.c:8447 #2 0x52717b in xmlParseDocument /root/libxml2/parser.c:10836 #3 0x55b5b6 in xmlDoRead /root/libxml2/parser.c:15324 #4 0x55b5b6 in xmlReadFile /root/libxml2/parser.c:15386 #5 0x4183b7 in parseAndPrintFile /root/libxml2/xmllint.c:2401 #6 0x40de46 in main /root/libxml2/xmllint.c:3759 #7 0x7f920fcc7ec4 (/lib/x86_64-linux-gnu/libc.so.6+0x21ec4) #8 0x40fad9 in _start (/root/libxml2/xmllint+0x40fad9) I git bisected it back to the following commit, which is meant to stop the parser on an unterminated entity This shows that there the parser is running through xmlParseMarkupDecl, and then instate is set to XML_PARSER_EOF (in xmlStopParser), but looking at the source for xmlParseMarkupDecl, on line 6990, the instate is changed to XML_PARSER_DTD.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
"Off-by-one error in libxml2, as used in Google Chrome before 19.0.1084.46 and other products, allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via unknown vectors.",-	    *cur++ = CUR;
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references."," 	rep = xmlStringDecodeEntities(ctxt, ent->content,
 				  XML_SUBSTITUTE_REF, 0, 0, 0);"
Fix missing error status in XPath evaluation. ,"         if (tmp == NULL) {
             xmlGenericError(xmlGenericErrorContext, ""realloc failed !\n"");
+            ctxt->error = XPATH_MEMORY_ERROR;
             return (0);
         }"
"If the XPath stack is corrupted, for example by a misbehaving extension function, the ""and"" and ""or"" XPath operators could dereference NULL pointers.",-            arg1->boolval &= arg2->boolval;
Fix some potential problems on reallocation failures.,-        cur->nodeMax *= 2;
"The xz_decomp function in xzlib.c in libxml2 2.9.8, if --with-lzma is used, allows remote attackers to cause a denial of service (infinite loop) via a crafted XML file that triggers LZMA_MEMLIMIT_ERROR, as demonstrated by xmllint, a different vulnerability than CVE-2015-8035.",while (strm->avail_out && ret != LZMA_STREAM_END);
Check return value of recursive calls to xmlParseElementChildrenContentDeclPriv and return immediately in case of errors.,"+            if (last == NULL) {
+		if (ret != NULL)
+		    xmlFreeDocElementContent(ctxt->myDoc, ret);
+		return(NULL);
+            }"
"An integer overflow, leading to heap-based buffer overflow was found in the way libxml, XML files manipulation library, processed certain XPath expressions."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
"The xmlNextChar function in libxml2 2.9.2 does not properly check the state, which allows context-dependent attackers to cause a denial of service (heap-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.a", 	    xmlParsePI(ctxt);
"Otherwise, struct xmlElementContent could contain unexpected null pointers, leading to a null deref when post-validating documents which aren't well-formed and parsed in recovery mode.", 	    elem = xmlParseName(ctxt);
"libxml2 2.9.0-rc1 and earlier, as used in Google Chrome before 21.0.1180.89, does not properly support a cast of an unspecified variable during handling of XSL transforms, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document, related to the _xmlNs data structure in include/libxml/tree.h.","+    if (cur->type == XML_NAMESPACE_DECL)
+        return;"
Bug 758605: Heap-based buffer overread in xmlDictAddString., 	if ((*in > 0) && (*in < 0x80)) {
==4210==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6290000051ff at pc 0x000000533c8f bp 0x7ffdb38c4830 sp 0x7ffdb38c4828.,-        if (ctxt->input->cur[tlen] == '>') {
Fix inappropriate fetch of entities content.,"-		    xmlLoadEntityContent(ctxt, ent);"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,"-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
If the string is not properly terminated do not try to convert to the given encoding.,"            if (RAW != '\'') {
                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);
+               xmlFree((xmlChar *) encoding);
+               return(NULL);
            }"
==17901==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60300000ea56 at pc 0x46cfc5 bp 0x7fffffffc420 sp 0x7fffffffc400.B1+B39," 		xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,"
Fix the semantic of XPath axis for namespace/attribute context nodes. ,"+    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
+	(ctxt->context->node->type == XML_NAMESPACE_DECL))
+	return(NULL);"
Validate UTF8 in xmlEncodeEntities.,"+		if (((cur[0] & 0xC0) != 0xC0) ||
+		    ((cur[1] & 0xC0) != 0x80) ||
+		    (((cur[0] & 0xE0) == 0xE0) && ((cur[2] & 0xC0) != 0x80)) ||
+		    (((cur[0] & 0xF0) == 0xF0) && ((cur[3] & 0xC0) != 0x80)) ||
+		    (((cur[0] & 0xF8) == 0xF8))) {"
"Double free vulnerability in libxml2, as used in Google Chrome before 14.0.835.163, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.",+    ctxt->error = XPATH_INVALID_OPERAND;
==17867== ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe56c100c1 at pc 0xb6d62c bp 0x7ffe56c0fdd0 sp 0x7ffe56c0fdc8.,"-					    ctxt->userData, &cur, 1);"
"If entities expansion in the XML parser is asked for, it is possble to craft relatively small input document leading to excessive on-the-fly content generation.",+    if (replacement != 0) {
"libxml2 2.9.0-rc1 and earlier, as used in Google Chrome before 21.0.1180.89, does not properly support a cast of an unspecified variable during handling of XSL transforms, which allows remote attackers to cause a denial of service or possibly have unknown other impact via a crafted document, related to the _xmlNs data structure in include/libxml/tree.h.", 	while (cur != NULL) {
"Off-by-one error in libxml2, as used in Google Chrome before 19.0.1084.46 and other products, allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via unknown vectors.","else {
-		*cur++ = '^';
-		*cur++ = CUR;
-	    }"
"Integer overflow in xpath.c in libxml2 2.6.x through 2.6.32 and 2.7.x through 2.7.8, and libxml 1.8.16 and earlier, allows context-dependent attackers to cause a denial of service (crash) and possibly execute arbitrary code via a crafted XML file that triggers a heap-based buffer overflow when adding a new namespace node, related to handling of XPath expressions."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.","-		    set1->nodeTab, set1->nodeMax * sizeof(xmlNodePtr));"
The htmlParseTryOrFinish function in HTMLparser.c in libxml2 2.9.4 allows attackers to cause a denial of service (buffer over-read) or information disclosure.,	    ctxt->input->free((xmlChar *) ctxt->input->base);
"The xmlNextChar function in libxml2 2.9.2 does not properly check the state, which allows context-dependent attackers to cause a denial of service (heap-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
==25920==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x631000010810 at pc 0x0000004a2f25 bp 0x7ffc81805ae0 sp 0x7ffc81805290., 	if ((*in > 0) && (*in < 0x80)) {
Fix some potential problems on reallocation failures.,"+	    temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *
 					     sizeof(xmlNodePtr));"
if not stop everything we have an internal state error.,-        ctxt->instate = XML_PARSER_EOF;
The processing of namespace and attributes nodes was not compliant to the XPath-1.0 specification.,"+    if (cur != NULL) {
+        if ((cur->type == XML_ATTRIBUTE_NODE) ||
+            (cur->type == XML_NAMESPACE_DECL))
+            return(NULL);
+        if (cur->children != NULL)
+            return cur->children ;
+    }"
Heap-based buffer overread in xmlDictAddString., 	if ((*in > 0) && (*in < 0x80)) {
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,-            } else if (*cur < 0xF0) {
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.",-            arg1->boolval |= arg2->boolval;
"The (1) xmlParserEntityCheck and (2) xmlParseAttValueComplex functions in parser.c in libxml2 2.9.3 do not properly keep track of the recursion depth, which allows context-dependent attackers to cause a denial of service (stack consumption and application crash) via a crafted XML document containing a large number of nested entity references.",+			++ctxt->depth;
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds," 	if (temp == NULL) {
 	    xmlXPathErrMemory(NULL, ""growing nodeset\n"");
 	    return;
 	}"
Fix some potential problems on reallocation failures.,"-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
Fix infinite loop in LZMA decompression. ,while (strm->avail_out && ret != LZMA_STREAM_END);
Heap-based buffer overflow in the xmlGROW function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to obtain sensitive process memory information via unspecified vectors.,-        ctxt->instate = XML_PARSER_EOF;
A NULL pointer dereference vulnerability exists in the xpath,"-            valuePush(ctxt, arg1);"
The xmlParseMisc function in parser.c in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (out-of-bounds heap read) via unspecified vectors related to incorrect entities boundaries and start tags.,-	if (ctxt->input->base != base) goto base_changed;
libxml2 20904-GITv2.9.4-16-g0741801 is vulnerable to a heap-based buffer over-read in the xmlDictAddString function in dict.c.,        if ((*in > 0) && (*in < 0x80)) {
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,-		set1->nodeMax *= 2;
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
Fix missing error status in XPath evaluation.,+                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
Approvement in LZMA error handling which prevents an infinite loop.,"+        if ((state->how != GZIP) &&
+            (ret != LZMA_OK) && (ret != LZMA_STREAM_END)) {
+            xz_error(state, ret, ""lzma error"");
+            return -1;
+        }"
Adds further checks to partial fix in 50f06b3e.,"+		if (((cur[0] & 0xC0) != 0xC0) ||
+		    ((cur[1] & 0xC0) != 0x80) ||
+		    (((cur[0] & 0xE0) == 0xE0) && ((cur[2] & 0xC0) != 0x80)) ||
+		    (((cur[0] & 0xF0) == 0xF0) && ((cur[3] & 0xC0) != 0x80)) ||
+		    (((cur[0] & 0xF8) == 0xF8))) {"
arg1->boolval &= arg2->boolval; //and then the application is crashing here resulting in a Denial of Service condition.,"-            valuePush(ctxt, arg1);"
Unless explicietely asked for when validating or replacing entities with their value.,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,+	    xmlStopParser(ctxt);
"Proposed Fix: The fix should be easy, just check for null values in arg1 before dereferencing in both cases.","+            if (ctxt->value != NULL)
+                ctxt->value->boolval |= arg2->boolval;"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application.","-	temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *"
==17867== ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe56c100c1 at pc 0xb6d62c bp 0x7ffe56c0fdd0 sp 0x7ffe56c0fdc8.,"-						ctxt->userData, &cur, 1);"
"Double free vulnerability in libxml2 2.7.8 and other versions, as used in Google Chrome before 8.0.552.215 and other products, allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to XPath handling.","+                if (tmp != contextObj)
+                    xmlXPathReleaseObject(xpctxt, tmp);"
"A vulnerability found in libxml2 in versions before 2.9.11 shows that it did not propagate errors while parsing XML mixed content, causing a NULL dereference."," 	    last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,
                                                           depth + 1);"
Fix memory leak in xmlParseBalancedChunkMemoryRecover.,-    newDoc->oldNs = NULL;
Move from a block list to an allow list approach to avoid descending into other node types that can't contain elements.,-                   (cur->children->type != XML_XINCLUDE_START) &&
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,+	    xmlStopParser(ctxt);
"The xmlBufAttrSerializeTxtContent function in xmlsave.c in libxml2 allows context-dependent attackers to cause a denial of service (out-of-bounds read and application crash) via a non-UTF-8 attribute value, related to serialization.",-            } else if (*cur < 0xF8) {
Do not fetch external parsed entities.,"+    if ((ent->checked == 0) &&
+        ((ent->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY) ||
+         (ctxt->options & (XML_PARSE_NOENT | XML_PARSE_DTDVALID)))) {"
The HTML parser was too optimistic when processing comments and didn't check for the end of the stream on the first 2 characters,"-    if (!IS_CHAR(cur)) {
-       htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,
-                    ""Comment not terminated \n<!--%.50s\n"", buf, NULL);
-       xmlFree(buf);
-    }"
The pointers from the context input were not properly reset after that call which can do reallocations.,+	size_t current = ctxt->input->cur - ctxt->input->base;
Avoid processing entities after encoding conversion failures.,+    return(ret);
The count was incremented before the allocation and not fixed in case of failure * xpath.c: corrects a few instances where the available count of some structure is updated before we know the allocation actually succeeds,-        cur->nodeMax *= 2;
"The xz_head function in xzlib.c in libxml2 before 2.9.6 allows remote attackers to cause a denial of service (memory consumption) via a crafted LZMA file, because the decoder functionality does not restrict memory usage to what is required for a legitimate file.",             xmlFree(state->out);
"Started by Chris Evans, I added a few more place where the error should have been set in the evaluation context.","         if (tmp == NULL) {
             xmlGenericError(xmlGenericErrorContext, ""realloc failed !\n"");
+            ctxt->error = XPATH_MEMORY_ERROR;
             return (0);
         }"
"The xmlPArserPrintFileContextInternal function in libxml2 before 2.9.4, as used in Apple iOS before 9.3.2, OS X before 10.11.5, tvOS before 9.2.1, and watchOS before 2.2.1, allows remote attackers to cause a denial of service (heap-based buffer over-read) via a crafted XML document.",-        if (ctxt->input->cur[tlen] == '>') {
"A patch to do this is below: diff --git a/parser.c b/parser.c index a65e4cc..04b0e58 100644 --- a/parser.c +++ b/parser.c @@ -6970,6 +6970,15 @@ xmlParseMarkupDecl(xmlParserCtxtPtr ctxt) { xmlParsePI(ctxt); } } + + /* + * If the parser eached end of file, then stop while we know it is failing.","+    if (ctxt->instate == XML_PARSER_EOF)
+        return;"
Fix missing error status in XPath evaluation. ,+                        ctxt->error = XPATH_UNDEF_PREFIX_ERROR;
arg1->boolval |= arg2->boolval; //crashing here due to null deref.,-            arg1->boolval &= arg2->boolval;
The count was incremented before the allocation and not fixed in case of failure.," 		temp = (xmlNodePtr *) xmlRealloc(
+		    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));"
"The xmlBufAttrSerializeTxtContent function in xmlsave.c in libxml2 allows context-dependent attackers to cause a denial of service (out-of-bounds read and application crash) via a non-UTF-8 attribute value, related to serialization.",-            } else if (*cur < 0xF0) {
"Because of that omission, the parser failed to detect attribute recursions in certain documents before running out of stack space."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						      XML_SUBSTITUTE_REF,
 						      0, 0, 0);"
"A remote attacker could provide a specially-crafted XML file, which once opened in an application linked against libxml would cause that application to crash, or, potentially, execute arbitrary code with the privileges of the user running the application."," 		if (temp == NULL) {
 		    xmlXPathErrMemory(NULL, ""merging nodeset\n"");
 		    return(NULL);
 		}"
Avoid processing entities after encoding conversion failures.,"+    if ((ret < 0) || (ctxt->errNo == XML_I18N_CONV_FAILED)) {
+        xmlStopParser(ctxt);
+	ctxt->errNo = XML_I18N_CONV_FAILED;
+    }"
Fix some potential problems on reallocation failures.,+        cur->nodeMax *= 2;
Fix inappropriate fetch of entities content For https://bugzilla.gnome.org/show_bug.cgi?id=761430.,"-		    xmlLoadEntityContent(ctxt, ent);"
Fix nullptr deref with XPath logic ops.,"-            valuePush(ctxt, arg1);"
The error handling of Conditional Section also need to be straightened as the structure of the document can't be guessed on a failure there and it's better to stop parsing as further errors are likely to be irrelevant.,-        cur->nodeMax *= 2;
I've verified this bug is affecting latest PHP 5.6 with xml module which can cause a denial of service for applications accepting xpath/xslt.,"-            valuePush(ctxt, arg1);"
Approvement in LZMA error handling which prevents an infinite loop.,while (strm->avail_out && ret != LZMA_STREAM_END);
"When we hit a convwersion failure when switching encoding it is bestter to stop parsing there, this was treated as a fatal error but the parser was continuing to process to extract more errors, unfortunately that makes little sense as the data is obviously corrupt and can potentially lead to unexpected behaviour.","+    if ((ret < 0) || (ctxt->errNo == XML_I18N_CONV_FAILED)) {
+        xmlStopParser(ctxt);
+	ctxt->errNo = XML_I18N_CONV_FAILED;
+    }"
if an attribute value is not UTF-8 be more careful when serializing it as we may do an out of bound access as a result.,+            } else if ((*cur < 0xF8) && (cur [2] != 0) && (cur[3] != 0)) {
"It is possible to trigger a stack overflow using a carefully crafted invalid xml file, the stack overflow occurs before libxml2 determines the xml file is invalid."," 			rep = xmlStringDecodeEntities(ctxt, ent->content,
 						  XML_SUBSTITUTE_REF, 0, 0, 0);"
"libxml2 through 2.9.1 does not properly handle external entities expansion unless an application developer uses the xmlSAX2ResolveEntity or xmlSetExternalEntityLoader function, which allows remote attackers to cause a denial of service (resource consumption), send HTTP requests to intranet servers, or read arbitrary files via a crafted XML document, aka an XML External Entity (XXE) issue.",ent->checked = ctxt->nbentities - oldnbent;
The xmlSAX2TextNode function in SAX2.c in the push interface in the HTML parser in libxml2 before 2.9.3 allows context-dependent attackers to cause a denial of service (stack-based buffer over-read and application crash) or obtain sensitive information via crafted XML data.,"-						ctxt->userData, &cur, 1);"
* HTMLparser.c: (htmlParseName): Add bounds check.,"+    if (ctxt->input->base > ctxt->input->cur - len)
+       return(NULL);"
I've verified this bug is affecting latest PHP 5.6 with xml module which can cause a denial of service for applications accepting xpath/xslt.,-            arg1->boolval |= arg2->boolval;
A race condition in chown_one() of systemd allows an attacker to cause systemd to set arbitrary permissions on arbitrary files.,"-        else
-                r = fchown(fd, uid, gid);"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
"In systemd through 233, certain sizes passed to dns_packet_new in systemd-resolved can cause it to allocate a buffer that's too small.","-        else
-                a = mtu - UDP_PACKET_HEADER_SIZE;"
"The allocation size was calculated in a complicated way, and for values close to the page size we would actually allocate less than requested.","-        if (mtu <= UDP_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_SIZE_START;"
don't accept arbitrarily sized journal data fields.,+#define DATA_SIZE_MAX (1024*1024*64)
An out-of-bounds read when parsing a crafted syslog message that could lead to information disclosure.,         *buf = p + e;
don't accept arbitrarily sized journal data fields.,"+                        if (l > DATA_SIZE_MAX) {
+                                log_debug(""Received binary data block too large, ignoring."");
+                                break;
+                        }"
resolved: fix loop on packets with pseudo dns types,"+                for (; bitmask; bit++, bitmask >>= 1)"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","+                        if (r == -ENOBUFS)
+                                log_warning_errno(r, ""Entry is above the maximum of %u, aborting connection %p."",
                                                  DATA_SIZE_MAX, connection);"
bugfix of null pointer p->question dereferencing (#6020),"        if (p->question->n_keys != 1)
                return 0;"
"Existing use of E2BIG is replaced with ENOBUFS (entry too long), and E2BIG is reused for the new error condition (too many fields).","-                        if (r == -E2BIG)
-                                log_warning_errno(r, ""Entry is too above maximum of %u, aborting connection %p."","
bus_open leak sd_event_source when udevadm trigger.,"         r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);"
chown-recursive: let's rework the recursive logic to use O_PATH.,"+        xsprintf(procfs_path, ""/proc/self/fd/%i"", fd);"
"A malicious DNS server can exploit this via a response with a specially crafted TCP payload to trick systemd-resolved into allocating a buffer that's too small, and subsequently write arbitrary data beyond the end of it.","-        if (a < DNS_PACKET_HEADER_SIZE)
-                a = DNS_PACKET_HEADER_SIZE;"
"This behaviour is definitely not expected by users, since tools generally only accept decimal numbers.","+        r = safe_atou32_full(s, 10, &uid);"
"This behaviour is definitely not expected by users, since tools generally only accept decimal numbers.",         assert_cc(sizeof(uid_t) == sizeof(uint32_t));
"Function unit_deserialize() in file unit.c does not properly handle lines longer than LINE_MAX and the content of a property longer than that is parsed as part of the serialized state, allowing an attacker to corrupt the state of the service (e.g.","+                if (r == 0) 
+                        break;"
